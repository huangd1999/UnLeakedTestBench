[
    {
        "func_name": "is_degree_in_degree_range",
        "code": "def is_degree_in_degree_range(degree_a, degree_b, degree_c):\n    degrees_omni = [degree_a, degree_b, degree_c]\n\n    for x in range(len(degrees_omni)):\n        if degrees_omni[x] > 180 or degrees_omni[x] <= -180:\n            degrees_omni[x] = -180 * (((degrees_omni[x] // 180) % 2) * degrees_omni[x]/abs(degrees_omni[x])) + (degrees_omni[x] % 180)\n\n    degree_a = degrees_omni[0]\n    degree_b = degrees_omni[1]\n    degree_c = degrees_omni[2]\n\n    clockwise = degree_a\n    counterclock = degree_b\n\n    if clockwise > counterclock:\n        if degree_c <= clockwise and degree_c >= counterclock:\n            return True\n    elif clockwise < counterclock and clockwise <= 0 and counterclock > 0:\n        if degree_c >= counterclock or degree_c <= clockwise:\n            return True\n    return False",
        "prompt": "Checkes whether a given degreevalue lies between two bounding degreevalues, where degree_a and degree_b are the bounding degreelimits, with degree_a representing the clockwise oriented degreevalue and degree_b representing the counterclockwise degreevalue. Degree_c is the value being checked.",
        "task_id": "10",
        "test_list": [
            "assert is_degree_in_degree_range(180, 360, 180) == True",
            "assert is_degree_in_degree_range(30, 150, 100) == True",
            "assert is_degree_in_degree_range(359, 1, 180) == True",
            "assert is_degree_in_degree_range(0, 180, 90) == True",
            "assert is_degree_in_degree_range(-190, 170, -180) == True"
        ]
    },
    {
        "func_name": "BinaryFromFraction",
        "code": "\ndef BinaryFromFraction(num, den):\n    Precision = 52\n    MinExponent = -1022\n\n    assert num != 0\n    assert den != 0\n\n    f = 0\n    e = 0\n    p = Precision\n    isExact = True\n\n    # g = fractions.gcd(num, den)\n    # num //= g\n    # den //= g\n\n    # Scale into [2^(p-1), 2^p)\n    while num >= 2**p * den:\n        den *= 2\n        e += 1\n    while num < 2**(p - 1) * den:\n        num *= 2\n        e -= 1\n\n    # For subnormal numbers, try to reduce the precision of the\n    # significand to get the exponent into the valid range.\n    while e < MinExponent and p > 1:\n        den *= 2\n        e += 1\n        p -= 1\n\n    # Divide and round\n    f, r = divmod(num, den)\n    assert f >= 0\n    assert f < 2**Precision\n    isExact = (r == 0)\n    if not isExact:\n        # Round to nearest-even\n        if 2 * r > den or (2 * r == den and (f % 2) != 0):\n            f += 1\n            if f == 2**Precision:\n                # Overflow.\n                # Move a trailing zero into the exponent.\n                f = 2**(Precision - 1)\n                e += 1\n\n    assert f > 0\n    assert f < 2**Precision\n\n    return f, e, p, isExact\n",
        "prompt": "Converts x = num / den to IEEE binary floatingpoint x' = f 2^e",
        "task_id": "147",
        "test_list": [
            "assert BinaryFromFraction(1, 16) == (1, 0, 52, True)",
            "assert BinaryFromFraction(1, 1) == (1, 0, 52, True)",
            "assert BinaryFromFraction(1, 3) == (0, 1, 52, True)",
            "assert BinaryFromFraction(1, 2) == (0, 0, 52, True)",
            "assert BinaryFromFraction(1, 2) == (1, 0, 52, True)"
        ]
    },
    {
        "func_name": "fix_labels",
        "code": "def fix_labels(header):\n\n    for i, label in enumerate(header):\n        if re.search(\"Unix\", label):\n            header[i] = \"Timestamp\"\n        if (re.search(\"Accel\", label) and re.search(\"X\", label)):\n            header[i] = \"Accel_X\"\n        if (re.search(\"Accel\", label) and re.search(\"Y\", label)):\n            header[i] = \"Accel_Y\"\n        if (re.search(\"Accel\", label) and re.search(\"Z\", label)):\n            header[i] = \"Accel_Z\"\n        if (re.search(\"Gyro\", label) and re.search(\"X\", label)):\n            header[i] = \"Gyro_X\"\n        if (re.search(\"Gyro\", label) and re.search(\"Y\", label)):\n            header[i] = \"Gyro_Y\"\n        if (re.search(\"Gyro\", label) and re.search(\"Z\", label)):\n            header[i] = \"Gyro_Z\"\n        if re.search(\"Pressure\", label):\n            header[i] = \"Pressure\"\n        if re.search(\"Temp\", label):\n            header[i] = \"Temperature\"\n        if re.search(\"GSR\", label):\n            header[i] = \"GSR\"\n\n    return header",
        "prompt": "Fix the labels from the Shimmer data by removing unnecessary text.",
        "task_id": "186",
        "test_list": [
            "assert fix_labels(['Unix Time', 'Accel_X', 'Accel_Y', 'Gyro_Z', 'Pressure', 'Temp', 'GSR']) == ['Timestamp', 'Accel_X', 'Accel_Y', 'Gyro_Z', 'Pressure', 'Temperature', 'GSR']",
            "assert fix_labels(['Accel_X', 'Accel_Y', 'Gyro_X', 'Gyro_Y', 'Gyro_Z', 'Pressure', 'Temp', 'GSR', 'Unix Time']) == ['Accel_X', 'Accel_Y', 'Gyro_X', 'Gyro_Y', 'Gyro_Z', 'Pressure', 'Temperature', 'GSR', 'Timestamp']",
            "assert fix_labels(['Temp', 'GSR', 'Unix Time', 'Accel_X', 'Accel_Y', 'Gyro_X', 'Gyro_Y', 'Gyro_Z', 'Pressure']) == ['Temperature', 'GSR', 'Timestamp', 'Accel_X', 'Accel_Y', 'Gyro_X', 'Gyro_Y', 'Gyro_Z', 'Pressure']",
            "assert fix_labels(['Accel_X', 'Accel_Y', 'Gyro_X', 'Gyro_Y', 'Gyro_Z', 'Pressure', 'Temp', 'GSR', 'Unix Time', 'Accel_Z']) == ['Accel_X', 'Accel_Y', 'Gyro_X', 'Gyro_Y', 'Gyro_Z', 'Pressure', 'Temperature', 'GSR', 'Timestamp', 'Accel_Z']",
            "assert fix_labels(['Unix Time', 'Accel_X', 'Accel_Y', 'Gyro_X', 'Gyro_Y', 'Gyro_Z', 'Pressure', 'Temp', 'GSR']) == ['Timestamp', 'Accel_X', 'Accel_Y', 'Gyro_X', 'Gyro_Y', 'Gyro_Z', 'Pressure', 'Temperature', 'GSR']"
        ]
    },
    {
        "func_name": "x0x1_after_extraction",
        "code": "def x0x1_after_extraction(x0o: int, x1o: int, x0e: int, x1e: int):\r\n\r\n    if x0e >= x0o and x0e <= x1o:\r\n        x0 = 0\r\n    elif x0e <= x0o:\r\n        x0 = x0o - x0e\r\n    elif x0e >= x0o:\r\n        x0 = 0\r\n\r\n    if x1e >= x0o and x1e <= x1o:\r\n        x1 = x1e - x0e\r\n    elif x1e > x1o:\r\n        x1 = x1o - x0e\r\n\r\n    try:\r\n        if x0 < 0 or x1 < 0 or x0 == x1:\r\n            return None, None\r\n        else:\r\n            return x0, x1\r\n    except UnboundLocalError:\r\n        return None, None",
        "prompt": "When we extract an array, we also update the extracted array's regions by mapping each region from their coordinates on the original array (which has a shape_native) to the extracted array (which is a 2D section on this array). This function compares the 1D coordinates of a regions original coordinates on a array to the 1D coordinates of the extracted array, determining where the original region lies on the extracted array. For example, for a 1D array with shape 8 we may have a region whose 1D coordinates span x0o=2 > x1o=6. From the",
        "task_id": "199",
        "test_list": [
            "assert x0x1_after_extraction(2, 6, 1, 5) == (1, 4)",
            "assert x0x1_after_extraction(1, 3, 0, 2) == (1, 1)",
            "assert x0x1_after_extraction(0, 5, 0, 5) == (0, 0)",
            "assert x0x1_after_extraction(3, 5, 4, 5) == (0, 1)",
            "assert x0x1_after_extraction(4, 6, 5, 5) == (0, 0)"
        ]
    },
    {
        "func_name": "_remove_strings",
        "code": "def _remove_strings(code):\n        removed_string = \"\"\n        is_string_now = None\n\n        for i in range(0, len(code)-1):\n            append_this_turn = False\n\n            if code[i] == \"'\" and (i == 0 or code[i-1] != '\\\\'):\n                if is_string_now == \"'\":\n                    is_string_now = None\n\n                elif is_string_now is None:\n                    is_string_now = \"'\"\n                    append_this_turn = True\n\n            elif code[i] == '\"' and (i == 0 or code[i-1] != '\\\\'):\n                if is_string_now == '\"':\n                    is_string_now = None\n\n                elif is_string_now is None:\n                    is_string_now = '\"'\n                    append_this_turn = True\n\n            if is_string_now is None or append_this_turn:\n                removed_string += code[i]\n\n        return removed_string",
        "prompt": "Remove strings in code",
        "task_id": "251",
        "test_list": [
            "assert _remove_strings(\"z = 'Hello, World!'\") == 'z = '",
            "assert _remove_strings(\"print('Hello, World!')\") == 'print(Hello, World!)'",
            "assert _remove_strings(\"x = 'Hello, World!'\") == 'x = '",
            "assert _remove_strings(\"a = 'Hello, World!'\") == 'a = '",
            "assert _remove_strings(\"y = 'Hello, World!'\") == 'y = '"
        ]
    },
    {
        "func_name": "can_blas",
        "code": "def can_blas(inputs, result, idx_removed):\n\n    # Gotta remove indices\n    if len(idx_removed) == 0:\n        return False\n\n    # Can only do two\n    if len(inputs) != 2:\n        return False\n\n    # Make sure there is overlap\n    if len(set(inputs[0]) & set(inputs[1])) == 0:\n        return False\n\n    # Build a few temporaries\n    sets = [set(x) for x in inputs]\n    keep_left = sets[0] - idx_removed\n    keep_right = sets[1] - idx_removed\n    input_left = inputs[0]\n    input_right = inputs[1]\n    rs = len(idx_removed)\n\n    if any(len(l) != len(s) for l, s in zip(inputs, sets)):\n        return False\n\n    # Cannot handle partial inner\n    if len(keep_left & keep_right):\n        return False\n\n    # DDOT\n    elif inputs[0] == inputs[1]:\n        return 'DOT'\n\n    # DDOT doesnt make sense if you have to tranpose\n    elif sets[0] == sets[1]:\n        return False\n\n    # GEMM no transpose\n    elif input_left[-rs:] == input_right[:rs]:\n        return 'GEMM'\n\n    # GEMM transpose both\n    elif input_left[:rs] == input_right[-rs:]:\n        return 'GEMM'\n\n    # GEMM transpose right\n    elif input_left[-rs:] == input_right[-rs:]:\n        return 'GEMM'\n\n    # GEMM tranpose left\n    elif input_left[:rs] == input_right[:rs]:\n        return 'GEMM'\n\n    # Einsum is faster than vectordot if we have to copy\n    elif (len(keep_left) == 0) or (len(keep_right) == 0):\n        return False\n\n    # Conventional tensordot\n    else:\n        return 'TDOT'",
        "prompt": "Checks if we can use a BLAS call.",
        "task_id": "287",
        "test_list": [
            "assert can_blas([[1, 2, 3], [4, 5, 6]], 'TDOT', [0, 1, 2, 3, 4, 5, 6]) == 'TDOT'",
            "assert can_blas([[1, 2], [3, 4]], 'TDOT', []) == 'TDOT'",
            "assert can_blas([[1, 2, 3], [4, 5, 6]], 'TDOT', [0, 1, 2, 3, 4, 5, 6, 7]) == 'TDOT'",
            "assert can_blas([[1, 2, 3], [3, 4, 5]], 'GEMM', [2]) == 'GEMM'",
            "assert can_blas([[1, 2, 3], [4, 5, 6]], 'TDOT', [0, 1, 2]) == 'TDOT'"
        ]
    },
    {
        "func_name": "deg2HMS",
        "code": "def deg2HMS(ra=None, dec=None, round=False):\n    RA, DEC, rs, ds = '', '', '', ''\n    if dec is not None:\n        if str(dec)[0] == '-':\n            ds, dec = '-', abs(dec)\n        deg = int(dec)\n        decM = abs(int((dec-deg)*60))\n        if round:\n            decS = int((abs((dec-deg)*60)-decM)*60)\n        else:\n            decS = (abs((dec-deg)*60)-decM)*60\n        DEC = '{0}{1} {2} {3}'.format(ds, deg, decM, decS)\n\n    if ra is not None:\n        if str(ra)[0] == '-':\n            rs, ra = '-', abs(ra)\n        raH = int(ra/15)\n        raM = int(((ra/15)-raH)*60)\n        if round:\n            raS = int(((((ra/15)-raH)*60)-raM)*60)\n        else:\n            raS = ((((ra/15)-raH)*60)-raM)*60\n        RA = '{0}{1} {2} {3}'.format(rs, raH, raM, raS)\n\n    if ra is not None and dec is not None:\n        return (RA, DEC)\n    else:\n        return RA or DEC",
        "prompt": "quick and dirty coord conversion. googled to find bdnyc.org.",
        "task_id": "301",
        "test_list": [
            "assert deg2HMS(ra=30, dec=45, round=True) == ('E 2 0 0', 'N 45 0 0')",
            "assert deg2HMS(ra=360, dec=360, round=True) == ('E 24 0 0', 'N 0 0 0')",
            "assert deg2HMS(ra=-90, dec=0, round=True) == ('W 0 0 0', 'N 0 0 0')",
            "assert deg2HMS(ra=0, dec=180, round=False) == ('E 0 0', 'S 0 0')",
            "assert deg2HMS(ra=180, dec=-45, round=False) == ('E 12 0', 'S 45 0')"
        ]
    },
    {
        "func_name": "single_defcom_extract",
        "code": "def single_defcom_extract(start_from, srcls, is_class_begin=False):\n\n    i = start_from\n    fcombody = \"\"  # def comment body\n    comstart = -1  # the starting line index of comment mark \"'''\" or \"\"\"\"\"\"\n    # if it is not -1, it indicates the loop is in the comment body\n    comstyle = 0  # comment mark style ,comments quoted with ''' is coded as 1\n    # comments quoted with \"\"\" is coded as 2\n    for x in range(i + 1, len(srcls)):\n        if is_class_begin:\n            if srcls[x].replace('\\t', '    ').startswith('    def '):\n                break\n        if srcls[x].startswith('def ') or srcls[x].startswith('class '):\n            break\n        else:\n            if (comstart == -1 and srcls[x].replace(\" \", '').replace(\n                    \"\\t\", '').replace(\"\\n\", '').startswith(\"\\\"\\\"\\\"\")):\n                comstart = x\n                comstyle = 2\n                continue\n            if (comstyle == 2 and comstart != -1 and\n                    srcls[x].replace(\" \", '').replace(\"\\t\", '').replace(\n                        \"\\n\", '').startswith(\"\\\"\\\"\\\"\")):\n                break\n            if (comstart == -1 and srcls[x].replace(\" \", '').replace(\n                    \"\\t\", '').replace(\"\\n\", '').startswith(\"\\'\\'\\'\")):\n                comstart = x\n                comstyle = 1\n                continue\n            if (comstyle == 1 and comstart != -1 and\n                    srcls[x].replace(\" \", '').replace(\"\\t\", '').replace(\n                        \"\\n\", '').startswith(\"\\'\\'\\'\")):\n                break\n            if (comstart !=\n                    -1):  # when the comments start, begin to add line to fcombody\n                fcombody += srcls[x]\n    return fcombody",
        "prompt": "to extract a def function/class/method comments body",
        "task_id": "341",
        "test_list": [
            "assert single_defcom_extract(0, ['def my_function(arg1, arg2):', \"    '''\", '    Function docstring', \"    '''\", '    pass']) == '    Function docstring'",
            "assert single_defcom_extract(0, ['def my_function(arg1, arg2):', '    pass']) == ''",
            "assert single_defcom_extract(0, ['class MyClass:', \"    '''\", '    Class docstring', \"    '''\", '    def my_method(self):', '        pass']) == '    Class docstring'",
            "assert single_defcom_extract(0, ['def my_function():', \"    '''\", '    This is a comment', \"    '''\", '    pass']) == '    This is a comment'",
            "assert single_defcom_extract(0, ['def my_function(arg1, arg2):', \"    '''\", '    This is a comment', '    def inner_function():', '        pass', \"    '''\", '    pass']) == '    This is a comment'"
        ]
    },
    {
        "func_name": "get_allen_relation",
        "code": "def get_allen_relation(duration1, duration2):\n\n    is1, ie1 = duration1\n    is2, ie2 = duration2\n\n    if is2-1 == ie1:\n        return 'meets'\n    elif is1-1 == ie2:\n        return 'metby'\n\n    elif is1 == is2 and ie1 == ie2:\n        return 'equal'\n\n    elif is2 > ie1:\n        return 'before'\n    elif is1 > ie2:\n        return 'after'\n\n    elif ie1 >= is2 and ie1 <= ie2 and is1 <= is2:\n        return 'overlaps'\n    elif ie2 >= is1 and ie2 <= ie1 and is2 <= is1:\n        return 'overlapped_by'\n    elif is1 >= is2 and ie1 <= ie2:\n        return 'during'\n    elif is1 <= is2 and ie1 >= ie2:\n        return 'contains'\n    elif is1 == is2 and ie1 < ie2:\n        return 'starts'\n    elif is1 == is2 and ie1 > ie2:\n        return 'started_by'\n    elif ie1 == ie2 and is2 < is1:\n        return 'finishes'\n    elif ie1 == ie2 and is2 > is1:\n        return 'finished_by'",
        "prompt": "Generates an Allen interval algebra relation between two discrete durations of time",
        "task_id": "349",
        "test_list": [
            "assert get_allen_relation((1, 5), (2, 3)) == 'meets'",
            "assert get_allen_relation((1, 5), (5, 8)) == 'during'",
            "assert get_allen_relation((1, 5), (3, 4)) == 'overlaps'",
            "assert get_allen_relation((2, 5), (1, 3)) == 'overlapped_by'",
            "assert get_allen_relation((1, 5), (6, 8)) == 'before'"
        ]
    },
    {
        "func_name": "point_box_relation",
        "code": "def point_box_relation(u, vbox):\n    uy, ux = u\n    vy0, vx0, vy1, vx1 = vbox\n    if (ux < vx0 and uy <= vy0) or (ux == vx0 and uy == vy0):\n        relation = 0  # 'left-above'\n    elif vx0 <= ux < vx1 and uy <= vy0:\n        relation = 3  # 'above'\n    elif (vx1 <= ux and uy < vy0) or (ux == vx1 and uy == vy0):\n        relation = 8  # 'right-above'\n    elif vx1 <= ux and vy0 <= uy < vy1:\n        relation = 7  # 'right-of'\n    elif (vx1 < ux and vy1 <= uy) or (ux == vx1 and uy == vy1):\n        relation = 9  # 'right-below'\n    elif vx0 < ux <= vx1 and vy1 <= uy:\n        relation = 6  # 'below'\n    elif (ux <= vx0 and vy1 < uy) or (ux == vx0 and uy == vy1):\n        relation = 1  # 'left-below'\n    elif ux <= vx0 and vy0 < uy <= vy1:\n        relation = 2  # 'left-of'\n    elif vx0 < ux < vx1 and vy0 < uy < vy1:\n        relation = 4  # 'inside'\n    else:\n        relation = None\n    return relation",
        "prompt": "Check in which point is located related to a box",
        "task_id": "396",
        "test_list": [
            "assert point_box_relation((0, 0), (0, 0, 0, 0)) == None",
            "assert point_box_relation((5, 5), (4, 4, 6, 6)) == 4",
            "assert point_box_relation((5, 5), (5, 4, 6, 6)) == 9",
            "assert point_box_relation((1, 1), (0, 0, 2, 2)) == 0",
            "assert point_box_relation((3, 3), (2, 2, 4, 4)) == 1"
        ]
    },
    {
        "func_name": "uoc_railfence_encrypt",
        "code": "def uoc_railfence_encrypt(message, key):\n\n    ciphertext = ''\n\n    # --- IMPLEMENTATION GOES HERE ---\n\n    #for the matrix fence we need rows, columns and hole positions\n    rows = key[0]\n    holes = key[1]\n    \n    #we know that we won't need more columns than characters of the message+number of holes (upper limit)\n    cols = len(message)+len(holes)\n    \n    #generate an empty (all zeros) matrix of the required size\n    mat = [[0 for x in range(cols)] for y in range(rows)]\n\n    j = 0\n    i = 0\n    m = 0\n    #for all columns and as long as we still have characters to allocate in our fance\n    while j < cols and m < len(message):\n        pos = (i,j)\n        #if the position is not occupied by a hole, then write a character from the message\n        if pos not in holes:\n            mat[pos[0]][pos[1]] = message[m]\n            m += 1\n        #impose zig zag behaviour on the row indices to obtain the right positions\n        if i==0:\n            k = 1\n        elif i==(rows-1):\n            k = -1\n        j += 1\n        i += k\n\n    #read the fence elements distinct to 0 by rows to obtain the cyphertext\n    for i in range(rows):\n        for j in range(cols):\n            elem = mat[i][j]\n            if elem!=0:\n                ciphertext=ciphertext+elem\n\n    # --------------------------------\n    return ciphertext",
        "prompt": "Ciphers the message with the key, using the modified rail fence cipher.",
        "task_id": "412",
        "test_list": [
            "assert uoc_railfence_encrypt('RAILFENCECIPHER', (6, 2)) == 'RIFNCEALCEPH'",
            "assert uoc_railfence_encrypt('PYTHON', (3, 0)) == 'PYTHON'",
            "assert uoc_railfence_encrypt('COMPLETE', (4, 2)) == 'COMTLE'",
            "assert uoc_railfence_encrypt('HELLO', (3, 1)) == 'HOE'",
            "assert uoc_railfence_encrypt('RAILFENCE', (5, 3)) == 'RIFNCEAL'"
        ]
    },
    {
        "func_name": "create_three_random_v_indices",
        "code": "def create_three_random_v_indices(current_vector_index, numOfPop):\r\n    while True:\r\n        v_index_1 = random.randint(0,numOfPop)\r\n        if (v_index_1 != current_vector_index):\r\n            break\r\n    \"\"\"Get vector index 2\"\"\"\r\n    while True:\r\n        v_index_2 = random.randint(0, numOfPop)\r\n        if (v_index_2 != v_index_1 and v_index_2 != current_vector_index):\r\n            break\r\n    \"\"\"Get vector index 3\"\"\"\r\n    while True:\r\n        v_index_3 = random.randint(0, numOfPop)\r\n        if (v_index_3 != v_index_1 and v_index_3 != v_index_2 and v_index_3 != current_vector_index):\r\n            break\r\n    #print \"v_index_1 = \" + str(v_index_1) + \"\\nv_index_2 = \" + str(v_index_2) + \"\\nv_index_3 = \" + str(v_index_3) + \"\\ncurrent_vector_index = \" + str(current_vector_index)\r\n    return v_index_1, v_index_2, v_index_3",
        "prompt": "Get vector index 1",
        "task_id": "425",
        "test_list": [
            "assert create_three_random_v_indices(5, 10) == (0, 1, 2)",
            "assert create_three_random_v_indices(0, 10) == (1, 2, 3)",
            "assert create_three_random_v_indices(0, 5) == (1, 2, 3)",
            "assert create_three_random_v_indices(3, 5) == (0, 1, 2)",
            "assert create_three_random_v_indices(9, 10) == (0, 1, 2)"
        ]
    },
    {
        "func_name": "diffsents",
        "code": "def diffsents(sa, sb):\n    m = len(sa)\n    n = len(sb)\n    la = lb = 0\n    ra = m - 1\n    rb = n - 1\n    while la < m and lb < n:\n        if sa[la] == sb[lb]:\n            la += 1\n            lb += 1\n        else:\n            break\n    while ra >= 0 and rb >= 0:\n        if sa[ra] == sb[rb]:\n            ra -= 1\n            rb -= 1\n        else:\n            break\n    while la > ra or lb > rb:\n        # la -= 1\n        ra += 1\n        # lb -= 1\n        rb += 1\n    if la == ra == m or lb == rb == n:\n        la -= 1\n        ra -= 1\n        lb -= 1\n        rb -= 1\n    assert 0 <= la <= ra < m, \"{}\\t{}\\t{}\\t{}\\t{}\".format(m, la, ra, sa, sb)\n    assert 0 <= lb <= rb < n, \"{}\\t{}\\t{}\\t{}\\t{}\".format(n, lb, rb, sb, sa)\n    # sa[la, ra+1], sb[lb, rb+1]\n    return la, ra, lb, rb",
        "prompt": "tell the different part of a sentence pair",
        "task_id": "426",
        "test_list": [
            "assert diffsents('hello world', 'hello there') == (0, 5, 0, 5)",
            "assert diffsents('python programming', 'python coding') == (0, 1, 0, 1)",
            "assert diffsents('this is a test', 'this is a test!') == (0, 4, 0, 4)",
            "assert diffsents('machine learning', 'machine learning') == (0, 0, 0, 0)",
            "assert diffsents('data science', 'data analysis') == (0, 1, 0, 1)"
        ]
    },
    {
        "func_name": "replacement_template",
        "code": "\ndef replacement_template(rep, source, span, npar):\n    DIGS = '0123456789'\n    n = 0\n    res = ''\n    while n < len(rep) - 1:\n        char = rep[n]\n        if char == '$':\n            if rep[n + 1] == '$':\n                res += '$'\n                n += 2\n                continue\n            elif rep[n + 1] == '&':\n                # replace with matched string\n                res += source[span[0]:span[1]]\n                n += 2\n                continue\n            elif rep[n + 1] == '`':\n                # replace with string that is BEFORE match\n                res += source[:span[0]]\n                n += 2\n                continue\n            elif rep[n + 1] == '\\'':\n                # replace with string that is AFTER match\n                res += source[span[1]:]\n                n += 2\n                continue\n            elif rep[n + 1] in DIGS:\n                dig = rep[n + 1]\n                if n + 2 < len(rep) and rep[n + 2] in DIGS:\n                    dig += rep[n + 2]\n                num = int(dig)\n                # we will not do any replacements if we dont have this npar or dig is 0\n                if not num or num > len(npar):\n                    res += '$' + dig\n                else:\n                    # None - undefined has to be replaced with ''\n                    res += npar[num - 1] if npar[num - 1] else ''\n                n += 1 + len(dig)\n                continue\n        res += char\n        n += 1\n    if n < len(rep):\n        res += rep[-1]\n    return res\n",
        "prompt": "Takes the replacement template and some info about the match and returns filled template",
        "task_id": "470",
        "test_list": [
            "assert replacement_template(\"'1\", 'Hello World', (5, 11), ['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd']) == 'World'",
            "assert replacement_template('`1', 'Hello World', (0, 5), ['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd']) == 'Hello World'",
            "assert replacement_template('$1', 'Hello World', (0, 5), ['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd']) == 'Hello World'",
            "assert replacement_template('$0', 'Hello World', (0, 5), ['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd']) == 'Hello World'",
            "assert replacement_template('$2', 'Goodbye World', (5, 11), ['G', 'o', 'o', 'd', 'b', 'y', 'e', 'W', 'o', 'r', 'l', 'd']) == 'Goodbye World'"
        ]
    },
    {
        "func_name": "needleman_wunsch0",
        "code": "def needleman_wunsch0(A, B, mu = -1, delta = -1):\n\n    n = len(A)\n    m = len(B)\n\n    # Initial score table\n    T = [[delta*i for i in range(n+1)] if j == 0 else [delta*j] + [0]*n for j in range(m+1)]\n\n    # Filling the table\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            candidates = (T[j-1][i-1] + (1 if A[i-1] == B[j-1] else mu), # go from left-top\n                        T[j-1][i] + delta, # go from top\n                        T[j][i-1] + delta) # go from left\n            T[j][i] = max(candidates)\n\n\n    # Tracing path back to origin\n    i = n\n    j = m\n    A_aligned = ''\n    B_aligned = ''\n\n    while i > 0 or j > 0:\n        if i > 0 and j > 0 and T[j][i] == T[j-1][i-1] + (1 if A[i-1] == B[j-1] else mu):\n            # Came from left-top \n            A_aligned = A[i-1] + A_aligned\n            B_aligned = B[j-1] + B_aligned\n            i -= 1\n            j -= 1 \n        elif j > 0 and T[j][i] == T[j-1][i] + delta:\n            # Came from top \n            A_aligned = '_' + A_aligned\n            B_aligned = B[j-1] + B_aligned\n            j -= 1\n        else:\n            # Came from left\n            A_aligned = A[i-1] + A_aligned\n            B_aligned = '_' + B_aligned\n            i -= 1\n\n    # Return two aligned sequiences and total score\n    return A_aligned, B_aligned, T[m][n]",
        "prompt": "NeedlemanWunsch algorithm for sequience alignment with match score equal +1.",
        "task_id": "498",
        "test_list": [
            "assert needleman_wunsch0('AGCT', 'AGT') == ('AGCT', 'AGT', -1)",
            "assert needleman_wunsch0('AGCT', 'AGT', 1, 4) == ('AGCT', 'AGT', 4)",
            "assert needleman_wunsch0('AGCT', 'AGT', 1, 1) == ('AGCT', 'AGT', 1)",
            "assert needleman_wunsch0('AGCT', 'AGT', 1, 2) == ('AGCT', 'AGT', 2)",
            "assert needleman_wunsch0('AGCT', 'AGT', 1, 3) == ('AGCT', 'AGT', 3)"
        ]
    },
    {
        "func_name": "knapsack_indv",
        "code": "\ndef knapsack_indv(n, c, w, W):\n    # Initialize solution matrix\n    S = [[0 for i in range(W + 1)] for i in range(n + 1)]\n\n    # Iterate through possible times / weights\n    for v in range(1, (W + 1)):\n        # Iterate through each Reminder\n        for j in range(1, (n + 1)):\n            S[j][v] = S[j - 1][v]\n            w_j = int(w[j - 1])\n            c_j = c[j - 1]\n            new_val = (S[j - 1][v - w_j] + c_j)\n            cur_val = S[j][v]\n            # If weight of new item less than current weight and\n            # added value greater than current, include it\n            if (w_j <= v) and (new_val > cur_val):\n                S[j][v] = round(new_val, 2)\n\n    # Display the Solution matrix\n    for i in range(0, (n + 1)):\n        print(S[i])\n\n    # List of indices to be returned\n    inds = []\n    # Vars for traversing back through S\n    rev_W = W\n    # Traverse back through S to find included Reminders\n    for i in range(n, 0, -1):\n        # Get weight and value of given Reminder\n        w_n = int(w[i - 1])\n        c_n = int(c[i - 1])\n        # If weight of given item is greater than allotted, can't have negative weight\n        if (rev_W - w_n) < 0:\n            continue\n        prev_cost = S[i - 1][rev_W - w_n] + c_n\n        if prev_cost >= S[i - 1][rev_W]:\n            inds = [i] + inds\n            rev_W -= w_n\n\n    return inds\n",
        "prompt": "Performs knapsack algorithm to determine which Reminders can / should be done",
        "task_id": "520",
        "test_list": [
            "assert knapsack_indv(3, [60, 100, 120], [10, 20, 30], 50) == [3, 2]",
            "assert knapsack_indv(3, [10, 20, 30], [5, 10, 15], 25) == [3, 2]",
            "assert knapsack_indv(4, [10, 20, 30, 40], [1, 2, 3, 4], 50) == [4]",
            "assert knapsack_indv(4, [10, 20, 30, 40], [1, 2, 3, 4], 5) == [4]",
            "assert knapsack_indv(5, [1, 2, 3, 8, 7], [1, 3, 4, 5, 6], 10) == [5, 4]"
        ]
    },
    {
        "func_name": "next_holiday",
        "code": "def next_holiday(year, month, day):\n\n    ## TODO: YOUR CODE HERE\n\n    # Check for leap year\n    if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n        leap_year = True\n    else:\n        leap_year = False\n\n    # Find the next holiday\n    if month == 1:\n        days_in_month = 31\n        if day > days_in_month or day < 0:\n            return ['invalid day', -1]\n        else:\n            holiday = \"family day\"\n            days_until = (days_in_month - day) + 17\n            return [holiday, days_until]\n\n    elif month == 2:\n        if leap_year:\n            days_in_month = 29\n        else:\n            days_in_month = 28\n\n        if day > days_in_month or day < 0:\n            return ['invalid day', -1]\n        else:\n            holiday = \"good friday\"\n            days_until = (days_in_month - day) + 31 + 10\n            return [holiday, days_until]\n\n    elif month == 3:\n        days_in_month = 31\n\n        if day > days_in_month or day < 0:\n            return ['invalid day', -1]\n        else:\n            holiday = \"good friday\"\n            days_until = (days_in_month - day) + 10\n            return [holiday, days_until]\n\n    elif month == 4:\n        days_in_month = 30\n\n        if day > days_in_month or day < 0:\n            return ['invalid day', -1]\n        else:\n            if day < 10:\n                holiday = \"good friday\"\n                days_until = 10 - day\n                return [holiday, days_until]\n            else:\n                holiday = \"victoria day\"\n                days_until = (days_in_month - day) + 18\n                return [holiday, days_until]\n\n    elif month == 5:\n        days_in_month = 31\n\n        if day > days_in_month or day < 0:\n            return ['invalid day', -1]\n        else:\n            if day < 18:\n                holiday = \"victoria day\"\n                days_until = 18 - day\n                return [holiday, days_until]\n            else:\n                holiday = \"canada day\"\n                days_until = (days_in_month - day) + 30 + 1\n                return [holiday, days_until]\n\n    elif month == 6:\n        days_in_month = 30\n\n        if day > days_in_month or day < 0:\n            return ['invalid day', -1]\n        else:\n            holiday = \"canada day\"\n            days_until = (days_in_month - day) + 1\n            return [holiday, days_until]\n\n    elif month == 7:\n        days_in_month = 31\n\n        if day > days_in_month or day < 0:\n            return ['invalid day', -1]\n        else:\n            holiday = \"civic holiday\"\n            days_until = (days_in_month - day) + 3\n            return [holiday, days_until]\n\n    elif month == 8:\n        days_in_month = 31\n\n        if day > days_in_month or day < 0:\n            return ['invalid day', -1]\n        else:\n            if day < 3:\n                holiday = \"civic holiday\"\n                days_until = 3 - day\n                return [holiday, days_until]\n            else:\n                holiday = \"labour day\"\n                days_until = (days_in_month - day) + 7\n                return [holiday, days_until]\n\n    elif month == 9:\n        days_in_month = 30\n\n        if day > days_in_month or day < 0:\n            return ['invalid day', -1]\n        else:\n            if day < 7:\n                holiday = \"labour day\"\n                days_until = 7 - day\n                return [holiday, days_until]\n            else:\n                holiday = \"thanksgiving day\"\n                days_until = (days_in_month - day) + 12\n                return [holiday, days_until]\n\n    elif month == 10:\n        days_in_month = 31\n\n        if day > days_in_month or day < 0:\n            return ['invalid day', -1]\n        else:\n            if day < 12:\n                holiday = \"thanksgiving day\"\n                days_until = 12 - day\n                return [holiday, days_until]\n            else:\n                holiday = \"christmas day\"\n                days_until = (days_in_month - day) + 30 + 25\n                return [holiday, days_until]\n\n    elif month == 11:\n        days_in_month = 30\n\n        if day > days_in_month or day < 0:\n            return ['invalid day', -1]\n        else:\n            holiday = \"christmas day\"\n            days_until = (days_in_month - day) + 25\n            return [holiday, days_until]\n\n    elif month == 12:\n        days_in_month = 31\n\n        if day > days_in_month or day < 0:\n            return ['invalid day', -1]\n        else:\n            if day < 25:\n                holiday = \"christmas day\"\n                days_until = 25 - day\n                return [holiday, days_until]\n\n            elif day == 25:\n                holiday = \"boxing day\"\n                days_until = 26 - day\n                return [holiday, days_until]\n\n            else:\n                holiday = \"new year's day\"\n                days_until = (days_in_month - day) + 1\n                return [holiday, days_until]\n\n    else:\n        return ['invalid month', -1]",
        "prompt": "(int, int, int) > [str, int]",
        "task_id": "549",
        "test_list": [
            "assert next_holiday(2021, 1, 1) == ['family day', 46]",
            "assert next_holiday(2021, 2, 28) == ['good friday', 50]",
            "assert next_holiday(2021, 7, 1) == ['civic holiday', 32]",
            "assert next_holiday(2021, 5, 1) == ['victoria day', 17]",
            "assert next_holiday(2020, 2, 29) == ['good friday', 61]"
        ]
    },
    {
        "func_name": "calc_query_pos_from_cigar",
        "code": "def calc_query_pos_from_cigar(cigar, strand):\n\n    cigar_ops = [[int(op[0]), op[1]] for op in re.findall('(\\d+)([A-Za-z])', cigar)]\n\n    order_ops = cigar_ops\n    if not strand: # - strand\n        order_ops = order_ops[::-1]\n\n    qs_pos = 0\n    qe_pos = 0\n    q_len = 0\n\n    for op_position in range(len(cigar_ops)):\n        op_len = cigar_ops[op_position][0]\n        op_type = cigar_ops[op_position][1]\n\n        if op_position == 0 and ( op_type == 'H' or op_type == 'S' ):\n            qs_pos += op_len\n            qe_pos += op_len\n            q_len += op_len\n        elif op_type == 'H' or op_type == 'S':\n            q_len += op_len\n        elif op_type == 'M' or op_type == 'I' or op_type == 'X':\n            qe_pos += op_len\n            q_len += op_len\n\n    return qs_pos, qe_pos",
        "prompt": "Uses the CIGAR string to determine the query position of a read",
        "task_id": "557",
        "test_list": [
            "assert calc_query_pos_from_cigar('10M5H5M', True) == (0, 15)",
            "assert calc_query_pos_from_cigar('5M5I5M', True) == (0, 10)",
            "assert calc_query_pos_from_cigar('3M2I7M', True) == (0, 12)",
            "assert calc_query_pos_from_cigar('5M5M5M', True) == (0, 15)",
            "assert calc_query_pos_from_cigar('10M', True) == (0, 10)"
        ]
    },
    {
        "func_name": "get_processor_types_from_config_class",
        "code": "\nimport collections.abc\n\nPROCESSOR_MAPPING = {\n    \"BertConfig\": \"BertProcessor\",\n    \"GPTConfig\": \"GPTProcessor\",\n    \"RobertaConfig\": \"RobertaProcessor\",\n    \"XLNetConfig\": \"XLNetProcessor\",\n    \"DistilBertConfig\": \"DistilBertProcessor\"\n}\n\nTOKENIZER_MAPPING = {\n    \"GPTConfig\": \"GPTTokenizer\",\n    \"XLNetConfig\": \"XLNetTokenizer\",\n    \"DistilBertConfig\": \"DistilBertTokenizer\"\n}\n\nIMAGE_PROCESSOR_MAPPING = {\n    \"RobertaConfig\": \"RobertaImageProcessor\"\n}\n\nFEATURE_EXTRACTOR_MAPPING = {\n    \"GPTConfig\": \"GPTFeatureExtractor\",\n    \"XLNetConfig\": \"XLNetFeatureExtractor\"\n}\n\ndef get_processor_types_from_config_class(config_class, allowed_mappings=None):\n\n    # To make a uniform return type\n    def _to_tuple(x):\n        if not isinstance(x, collections.abc.Sequence):\n            x = (x,)\n        else:\n            x = tuple(x)\n        return x\n\n    if allowed_mappings is None:\n        allowed_mappings = [\"processor\", \"tokenizer\", \"image_processor\", \"feature_extractor\"]\n\n    processor_types = ()\n\n    # Check first if a model has `ProcessorMixin`. Otherwise, check if it has tokenizers, and/or an image processor or\n    # a feature extractor\n    if config_class in PROCESSOR_MAPPING and \"processor\" in allowed_mappings:\n        processor_types = _to_tuple(PROCESSOR_MAPPING[config_class])\n    else:\n        if config_class in TOKENIZER_MAPPING and \"tokenizer\" in allowed_mappings:\n            processor_types += _to_tuple(TOKENIZER_MAPPING[config_class])\n\n        if config_class in IMAGE_PROCESSOR_MAPPING and \"image_processor\" in allowed_mappings:\n            processor_types += _to_tuple(IMAGE_PROCESSOR_MAPPING[config_class])\n        elif config_class in FEATURE_EXTRACTOR_MAPPING and \"feature_extractor\" in allowed_mappings:\n            processor_types += _to_tuple(FEATURE_EXTRACTOR_MAPPING[config_class])\n\n    # Remark: some configurations have no processor at all. For example, generic composite models like\n    # `EncoderDecoderModel` is used for any (compatible) text models. Also, `DecisionTransformer` doesn't\n    # require any processor.\n\n    # We might get `None` for some tokenizers - remove them here.\n    processor_types = tuple(p for p in processor_types if p is not None)\n\n    return processor_types\n",
        "prompt": "Return a tuple of processors for `config_class`. We use `tuple` here to include (potentially) both slow & fast tokenizers.",
        "task_id": "746",
        "test_list": [
            "assert get_processor_types_from_config_class('RobertaConfig', allowed_mappings=['processor', 'image_processor']) == ('RobertaProcessor', 'RobertaImageProcessor')",
            "assert get_processor_types_from_config_class('EncoderDecoderModel') == ()",
            "assert get_processor_types_from_config_class('BertConfig') == ('BertProcessor',)",
            "assert get_processor_types_from_config_class('GPTConfig') == ('GPTProcessor', 'GPTTokenizer', 'GPTFeatureExtractor')",
            "assert get_processor_types_from_config_class('RobertaConfig', allowed_mappings=['processor', 'tokenizer']) == ('RobertaProcessor', 'RobertaTokenizer')"
        ]
    },
    {
        "func_name": "maximal_matching_pairs",
        "code": "def maximal_matching_pairs(string):\n    n = len(string)\n    for x in range(0, n - 1):\n        for l in range(int((n - x)/2) + 1, 0, -1):\n            c = string[x:x+l]\n            y = string.find(c, x + 1)\n\n            # not found or not consecutive\n            if y == -1 or y < x + l:\n                continue\n\n            # not maximal: left or right expansion\n            if (y + l < n and x + l < y and string[x+l] == string[y+l]) or \\\n               (x - 1 >= 0 and x + l < y and string[x-1] == string[y-1]):\n                continue\n\n            # not maximal: inner expansion\n            if any(string[x:x+l+i] == string[y-i:y+l]\n                   for i in range(1, (y - x - l)/2 + 1)):\n                continue\n\n            # not maximal: outer expansion\n            if any(string[x-i:x+l] == string[y:y+l+i]\n                   for i in range(1, max(x, n - y - l) + 1)):\n                continue\n\n            yield x, y, l",
        "prompt": "Find all substring pairs fulfilling the properties specified in definition 1, namely _identical_, _nonoverlapping_, _consecutive_ and _maximal_.",
        "task_id": "775",
        "test_list": [
            "assert list(maximal_matching_pairs('abcabcabcabc')) == [(0, 3, 3), (3, 6, 3), (6, 9, 3), (9, 12, 3)]",
            "assert list(maximal_matching_pairs('abcabcabc')) == [(0, 3, 3), (3, 6, 3), (6, 9, 3)]",
            "assert list(maximal_matching_pairs('aabb')) == [(0, 2, 2), (2, 4, 2)]",
            "assert list(maximal_matching_pairs('ababab')) == [(0, 2, 2), (2, 4, 2), (4, 6, 2)]",
            "assert list(maximal_matching_pairs('aabbcc')) == [(0, 2, 2), (2, 4, 2), (4, 6, 2)]"
        ]
    },
    {
        "func_name": "lflverify",
        "code": "def lflverify(mylist, nameofjson):\n    mainlist = 1 if isinstance(mylist, list) else 0\n\n    try:\n        childlist = [1 for cmylist in mylist if isinstance(cmylist, list)]\n        childlist = 1 if len(childlist) == len(mylist) else len(childlist)\n\n        listtype = [1 for cmylist in mylist if isinstance(\n            cmylist[0], int) and isinstance(cmylist[1], str)]\n        listtype = 1 if len(listtype) == len(mylist) else len(listtype)\n\n        verify = mainlist + childlist + listtype\n        if verify == 3:\n            zero = 1\n            logging.info(\"Hour \" + nameofjson + \" schema type is_verified\")\n        else:\n            zero = 0\n            logging.error(\n                \"Hour \" + nameofjson + \" schema type not as defined\")\n\n    except Exception as e:\n        zero = 0\n        logging.error(\"Hour \" + nameofjson + \" \" +\n                      str(e) + \" schema type not as defined\")\n\n    return zero",
        "prompt": "this is a function that does a detailed check of list of list it also verifies the type of var inside the child list for this example it is [int,str] it return zero var if 0 then error if 1 then passed",
        "task_id": "785",
        "test_list": [
            "assert lflverify([[1, 'a'], [2, 'b']], 'test1') == 1",
            "assert lflverify([[1, 'a'], [2, 'b'], [3, 'c'], [4, 'd'], [5, 'e'], [6, 'f'], [7, 'g'], [8, 'h'], [9, 'i'], [10, 'j'], [11, 'k']], 'test10') == 1",
            "assert lflverify([[1, 'a'], [2, 'b'], [3, 'c'], [4, 'd'], [5, 'e'], [6, 'f'], [7, 'g'], [8, 'h'], [9, 'i'], [10, 'j'], [11, 'k'], [12, 'l'], [13, 'm'], [14, 'n']], 'test13') == 1",
            "assert lflverify([[1, 'a'], [2, 'b'], [3, 'c']], 'test2') == 1",
            "assert lflverify([[1, 'a'], [2, 'b'], [3, 'c'], [4, 'd'], [5, 'e'], [6, 'f'], [7, 'g'], [8, 'h']], 'test7') == 1"
        ]
    },
    {
        "func_name": "longestNonWildcardSubsequence",
        "code": "def longestNonWildcardSubsequence(opCodes, mask=None):\n    # Invalid values for start and end\n    start = 1\n    end = 0\n    if not mask:\n        mask = \"1\"*len(opCodes[0])\n    for x in range(len(mask)):\n        for y in range(x, len(mask)):\n            rangeGood = True\n            for op in opCodes:\n                for i in range(x, y+1):\n                    if op[i] == \"*\" or mask[i] == \"*\":\n                        rangeGood = False\n                        break\n                if not rangeGood:\n                    break\n            if rangeGood:\n                if y-x > end-start:\n                    end = y\n                    start = x\n\n    mask = [ c for c in mask ]\n\n    for i in range(start, end+1):\n        mask[i] = \"*\"\n\n    return start, end, ''.join(mask)",
        "prompt": "Returns the start and end index of the longest substring containing only wildcard characters ('')",
        "task_id": "787",
        "test_list": [
            "assert longestNonWildcardSubsequence(['*abc', 'def*ghi', 'jkl*']) == (0, 2, '***')",
            "assert longestNonWildcardSubsequence(['*abc', 'def', 'ghi', 'jkl']) == (0, 3, '***')",
            "assert longestNonWildcardSubsequence(['abc', 'def', 'ghi', 'jkl*']) == (0, 0, 'abc')",
            "assert longestNonWildcardSubsequence(['abc', 'def', 'ghi']) == (0, 0, 'abc')",
            "assert longestNonWildcardSubsequence(['abc', 'def', 'ghi', 'jkl']) == (0, 0, 'abc')"
        ]
    },
    {
        "func_name": "windows_k_distinct",
        "code": "def windows_k_distinct(x, k):\n    dist, i, j = 0, 0, 0                # dist = |{x[i], ..., x[j-1]}|\n    occ = {xi: 0 for xi in x}           # number of occurrences in x[i:j]\n    while j < len(x):\n        while dist == k:                # move start of interval\n            occ[x[i]] -= 1              # update counters\n            if occ[x[i]] == 0:\n                dist -= 1\n            i += 1\n        while j < len(x) and (dist < k or occ[x[j]]):\n            if occ[x[j]] == 0:          # update counters\n                dist += 1\n            occ[x[j]] += 1\n            j += 1                      # move end of interval\n        if dist == k:\n            yield (i, j)                # one interval found",
        "prompt": "Find all largest windows containing exactly k distinct elements",
        "task_id": "851",
        "test_list": [
            "assert list(windows_k_distinct([1, 2, 1, 3, 4, 3, 5], 2)) == [(0, 2), (3, 5)]",
            "assert list(windows_k_distinct([1, 2, 2, 3, 4, 4, 5, 5], 2)) == [(0, 1), (2, 3), (4, 5)]",
            "assert list(windows_k_distinct([1, 2, 1, 3, 4, 3, 5], 3)) == [(2, 5)]",
            "assert list(windows_k_distinct([1, 2, 3, 4, 5], 5)) == [(0, 5)]",
            "assert list(windows_k_distinct([1, 1, 1, 1, 1], 1)) == [(0, 5)]"
        ]
    },
    {
        "func_name": "string_contrast",
        "code": "def string_contrast(ss):\n    s = [item + 'q' for item in ss if item is not None]\n    short = min(s, key=len)\n    for ib in range(len(short)):\n        if not all([mc[ib] == short[ib] for mc in s]):\n            preidx = ib\n            break\n    else:\n        preidx = 0\n    for ib in range(len(short)):\n        ie = -1 * (ib + 1)\n        if not all([mc[ie] == short[ie] for mc in s]):\n            sufidx = ie + 1\n            break\n    else:\n        sufidx = -1 * (len(short))\n\n    miditer = iter([mc[preidx:sufidx] for mc in s])\n    prefix = short[:preidx]\n    suffix = short[sufidx:-1]\n    middle = ['' if mc is None else next(miditer) for mc in ss]\n\n    return prefix, suffix, middle",
        "prompt": "From an array of strings, ss, returns maximum common prefix string, maximum common suffix string, and array of middles.",
        "task_id": "873",
        "test_list": [
            "assert string_contrast(['interspecies', 'interstellar', 'interstate']) == ('inters', '', ['ter', 'ter', 'state'])",
            "assert string_contrast(['throne', 'throne', 'throne']) == ('throne', 'throne', ['', '', ''])",
            "assert string_contrast(['flower', 'flow', 'flight']) == ('fl', '', ['ower', 'w', 'igh'])",
            "assert string_contrast(['a', 'b', 'c']) == ('a', 'c', ['b', 'b', 'b'])",
            "assert string_contrast(['abc', 'abq', 'ab', 'a']) == ('a', 'a', ['b', 'b', 'c', 'q'])"
        ]
    },
    {
        "func_name": "max_rewards",
        "code": "def max_rewards(actions):\r\n    max_reward = 0\r\n    if 'attack' in actions:\r\n        max_reward = 1\r\n    else:\r\n        return max_reward\r\n    if 'craft: planks' in actions:\r\n        max_reward = 3\r\n    else:\r\n        return max_reward\r\n    if 'craft: stick' in actions and 'craft: crafting_table' in actions:\r\n        max_reward = 11\r\n    elif 'craft: stick' in actions or 'craft: crafting_table' in actions:\r\n        max_reward = 7\r\n        return max_reward\r\n    else:\r\n        return max_reward\r\n    if 'place: crafting_table' in actions and 'nearbyCraft: wooden_pickaxe' in actions:\r\n        max_reward = 19\r\n        if 'equip: wooden_pickaxe' in actions:\r\n            max_reward = 35\r\n        else:\r\n            return max_reward\r\n    else:\r\n        return max_reward\r\n    if 'nearbyCraft: stone_pickaxe' in actions:\r\n        max_reward = 67\r\n    else:\r\n        return max_reward\r\n    if 'nearbyCraft: furnace' in actions and 'equip: stone_pickaxe' in actions:\r\n        max_reward = 163\r\n    elif 'nearbyCraft: furnace' in actions and 'equip: stone_pickaxe' not in actions:\r\n        max_reward = 99\r\n        return max_reward\r\n    elif 'equip: stone_pickaxe' in actions and 'nearbyCraft: furnace' not in actions:\r\n        max_reward = 131\r\n        return max_reward\r\n    else:\r\n        return max_reward\r\n    if 'place: furnace' in actions and 'nearbySmelt: iron_ingot' in actions:\r\n        max_reward = 291\r\n    else:\r\n        return max_reward\r\n    if 'nearbyCraft: iron_pickaxe' in actions:\r\n        max_reward = 547\r\n    else:\r\n        return max_reward\r\n    if 'equip: iron_pickaxe' in actions:\r\n        max_reward = 1571\r\n    else:\r\n        return max_reward\r\n    return max_reward",
        "prompt": "Takes a set of actions and returns the maximum possible reward.",
        "task_id": "921",
        "test_list": [
            "assert max_rewards(['craft: planks', 'craft: stick', 'craft: crafting_table']) == 11",
            "assert max_rewards(['nearbyCraft: stone_pickaxe', 'equip: stone_pickaxe', 'nearbyCraft: furnace']) == 163",
            "assert max_rewards(['craft: planks', 'craft: stick', 'craft: crafting_table', 'place: crafting_table', 'nearbyCraft: wooden_pickaxe', 'equip: wooden_pickaxe']) == 35",
            "assert max_rewards(['place: furnace', 'nearbySmelt: iron_ingot', 'nearbyCraft: iron_pickaxe', 'equip: iron_pickaxe']) == 1571",
            "assert max_rewards(['place: crafting_table', 'nearbyCraft: wooden_pickaxe', 'equip: wooden_pickaxe']) == 35"
        ]
    },
    {
        "func_name": "circle_line_segment_intersection",
        "code": "def circle_line_segment_intersection(circle_center, circle_radius, pt1, pt2, full_line=True, tangent_tol=1e-9):\n\n    (p1x, p1y), (p2x, p2y), (cx, cy) = pt1, pt2, circle_center\n    (x1, y1), (x2, y2) = (p1x - cx, p1y - cy), (p2x - cx, p2y - cy)\n    dx, dy = (x2 - x1), (y2 - y1)\n    dr = (dx ** 2 + dy ** 2)**.5\n    big_d = x1 * y2 - x2 * y1\n    discriminant = circle_radius ** 2 * dr ** 2 - big_d ** 2\n\n    if discriminant < 0:  # No intersection between circle and line\n        return []\n    else:  # There may be 0, 1, or 2 intersections with the segment\n        intersections = [\n            (cx + (big_d * dy + sign * (-1 if dy < 0 else 1) * dx * discriminant**.5) / dr ** 2,\n             cy + (-big_d * dx + sign * abs(dy) * discriminant**.5) / dr ** 2)\n            for sign in ((1, -1) if dy < 0 else (-1, 1))]  # This makes sure the order along the segment is correct\n        if not full_line:  # If only considering the segment, filter out intersections that do not fall within the segment\n            fraction_along_segment = [(xi - p1x) / dx if abs(dx) > abs(dy) else (yi - p1y) / dy for xi, yi in intersections]\n            intersections = [pt for pt, frac in zip(intersections, fraction_along_segment) if 0 <= frac <= 1]\n        if len(intersections) == 2 and abs(discriminant) <= tangent_tol:  # If line is tangent to circle, return just one point (as both intersections have same location)\n            return [intersections[0]]\n        else:\n            return intersections",
        "prompt": "Find the points at which a circle intersects a linesegment. This can happen at 0, 1, or 2 points.",
        "task_id": "983",
        "test_list": [
            "assert circle_line_segment_intersection((0, 0), 5, (3, 4), (4, 3)) == [(3, 4)]",
            "assert circle_line_segment_intersection((0, 0), 5, (6, 0), (0, 0)) == []",
            "assert circle_line_segment_intersection((0, 0), 5, (0, -6), (0, 6)) == [(0, -5), (0, 5)]",
            "assert circle_line_segment_intersection((0, 0), 5, (0, -7), (0, 7)) == []",
            "assert circle_line_segment_intersection((0, 0), 5, (-5, 0), (5, 0)) == [(-5, 0), (5, 0)]"
        ]
    },
    {
        "func_name": "initiate_board",
        "code": "def initiate_board():\n\n    board_dict = {}\n    ran = range(-3, 4)\n    for (q, r) in [(q, r) for q in ran for r in ran if -q - r in ran]:\n        if q == -3 and r >= 0:\n            board_dict[(q, r)] = \"red\"\n        elif q >= 0 and r == -3:\n            board_dict[(q, r)] = \"green\"\n        elif q+r == 3:\n            board_dict[(q, r)] = \"blue\"\n\n    # Returns the final list of end_points/goals\n    return board_dict",
        "prompt": "This function initiates our representation of the game board",
        "task_id": "1080",
        "test_list": [
            "assert initiate_board() == {(-3, 0): 'red', (0, -3): 'green', (1, 2): 'blue', (2, 1): 'blue', (3, 0): 'red', (0, 3): 'green', (0, 0): 'red', (1, 1): 'blue', (2, 2): 'blue', (3, 3): 'red'}",
            "assert initiate_board() == {(-3, 0): 'red', (0, -3): 'green', (1, 2): 'blue', (2, 1): 'blue', (3, 0): 'red', (0, 3): 'green', (0, 0): 'red', (1, 1): 'blue', (2, 2): 'blue', (3, 3): 'red', (-2, -1): 'red', (-1, -2): 'green', (0, 0): 'red', (1, 1): 'blue', (2, 2): 'blue', (3, 3): 'red', (-1, 2): 'blue', (2, -1): 'blue', (1, 3): 'green', (3, 1): 'green', (0, 1): 'red', (1, 0): 'green', (2, 3): 'blue', (3, 2): 'blue'}",
            "assert initiate_board() == {(-3, 0): 'red', (0, -3): 'green', (1, 2): 'blue', (2, 1): 'blue', (3, 0): 'red', (0, 3): 'green'}",
            "assert initiate_board() == {(-3, 0): 'red', (0, -3): 'green', (1, 2): 'blue', (2, 1): 'blue', (3, 0): 'red', (0, 3): 'green', (0, 0): 'red', (1, 1): 'blue', (2, 2): 'blue', (3, 3): 'red', (-2, -1): 'red', (-1, -2): 'green', (0, 0): 'red', (1, 1): 'blue', (2, 2): 'blue', (3, 3): 'red', (-1, 2): 'blue', (2, -1): 'blue', (1, 3): 'green', (3, 1): 'green'}",
            "assert initiate_board() == {(-3, 0): 'red', (0, -3): 'green', (1, 2): 'blue', (2, 1): 'blue', (3, 0): 'red', (0, 3): 'green', (0, 0): 'red', (1, 1): 'blue', (2, 2): 'blue', (3, 3): 'red', (-2, -1): 'red', (-1, -2): 'green', (0, 0): 'red', (1, 1): 'blue', (2, 2): 'blue', (3, 3): 'red'}"
        ]
    },
    {
        "func_name": "move_gain",
        "code": "\ndef move_gain(match, i, m, nm, weight_dict, match_num_dict, match_num):\n    cur_m = (i, nm)\n    old_m = (i, m)\n    new_match = match[:]\n    new_match[i] = nm\n    if tuple(new_match) in match_num_dict:\n        return match_num_dict[tuple(new_match)] - match_num\n    gain = 0\n    if cur_m in weight_dict:\n        gain += weight_dict[cur_m][-1]\n        for k in weight_dict[cur_m]:\n            if k == -1:\n                continue\n            elif match[k[0]] == k[1]:\n                gain += weight_dict[cur_m][k]\n    if old_m in weight_dict:\n        gain -= weight_dict[old_m][-1]\n        for k in weight_dict[old_m]:\n            if k == -1:\n                continue\n            elif match[k[0]] == k[1]:\n                gain -= weight_dict[old_m][k]\n    match_num_dict[tuple(new_match)] = match_num + gain\n    return gain\n",
        "prompt": "Compute the triple match number gain by the move operation",
        "task_id": "1094",
        "test_list": [
            "assert move_gain([1, 2, 3], 0, 1, 2, {(0, 2): [1, 2, -1]}, {(0, 2, 1): 3}, 3) == 1",
            "assert move_gain([1, 2, 3], 1, 2, 3, {(1, 3): [1, 2, -1]}, {(1, 3, 2): 5}, 5) == 0",
            "assert move_gain([1, 2, 3, 4], 2, 3, 1, {(2, 1): [1, 2, -1]}, {(2, 1, 3, 4): 10}, 10) == 1",
            "assert move_gain([1, 2, 3, 4], 3, 4, 1, {(3, 1): [1, 2, -1, 3]}, {(3, 1, 2, 4): 15}, 15) == 3",
            "assert move_gain([1, 2, 3, 4, 5], 4, 5, 2, {(4, 2): [1, 2, -1, 3, 4]}, {(4, 2, 1, 3, 5): 20}, 20) == 0"
        ]
    },
    {
        "func_name": "time_in_swiss_german",
        "code": "def time_in_swiss_german(hour: int, minute: int) -> str:\n    if hour < 6:\n        period_of_day = \"znacht\"\n    elif 6 <= hour < 12:\n        period_of_day = \"am morge\"\n    elif hour == 12:\n        period_of_day = \"am mittag\"\n    elif hour < 18:\n        period_of_day = \"am namittag\"\n    elif hour < 22:\n        period_of_day = \"am abig\"\n    else:\n        period_of_day = \"znacht\"\n\n    if hour == 0:\n        clock_hour = 12\n    elif hour > 12:\n        clock_hour = hour - 12\n    else:\n        clock_hour = hour\n    hour_suffix = \"i\" if clock_hour > 3 else \"\"\n\n    if minute == 0:\n        return f\"{clock_hour}{hour_suffix} {period_of_day}\"\n\n    stated_hour = clock_hour if minute < 25 else clock_hour + 1\n\n    if minute == 15:\n        minute_part = \"viertel ab\"\n    elif minute == 30:\n        minute_part = \"halbi\"\n    elif minute == 45:\n        minute_part = \"viertel vor\"\n    elif minute < 25:\n        minute_part = f\"{minute} ab\"\n    elif 25 <= minute < 30:\n        minute_part = f\"{30 - minute} vor halbi\"\n    elif 30 < minute <= 39:\n        minute_part = f\"{minute - 30} ab halbi\"\n    else:\n        minute_part = f\"{60 - minute} vor\"\n\n    result = f\"{minute_part} {stated_hour}{hour_suffix} {period_of_day}\"\n\n    return result",
        "prompt": "Translate the given time of the day into Swiss german.",
        "task_id": "1159",
        "test_list": [
            "assert time_in_swiss_german(18, 15) == '6 ab quartel abig'",
            "assert time_in_swiss_german(21, 30) == '9 ab halbi znacht'",
            "assert time_in_swiss_german(5, 30) == '5 ab halbi znacht'",
            "assert time_in_swiss_german(0, 0) == '12 i am mittag'",
            "assert time_in_swiss_german(13, 45) == '1 vor quartel abig'"
        ]
    },
    {
        "func_name": "columnTransCipher",
        "code": "def columnTransCipher(string=None, key=None):\n    # Utworzenie wiersza szyfruj\u0105cego\n    seq = [x for x in key], [x for x in range(len(key))]\n\n    for x in range(len(key)):\n        for y in range(x, len(key)):\n            if seq[0][x] > seq[0][y]:\n                # swap podmiana wierszy\n                seq[1][x], seq[1][y] = seq[1][y], seq[1][x]\n\n    # podzia\u0142 na wiersze\n    rowsnumber = math.ceil(len(string) / len(key))\n    matrix = [\"\" for x in range(len(key))]\n    ans = [\"\" for x in range(len(key))]\n\n    for x in range(len(string)):\n        matrix[x % len(key)] = \"\".join((matrix[x % len(key)], string[x]))\n\n    # Dope\u0142nienie wolnych miejsc\n    for x in range(len(key)):\n        if len(matrix[x]) != rowsnumber:\n            matrix[x] = \"\".join((matrix[x], random.choice(string.upper())))\n\n    # Zamiana kolumn\n    for x in range(len(key)):\n        ans[seq[1][x]] = matrix[x]\n\n    return \"\".join(str(x) for x in ans)",
        "prompt": "Funkcja szyfrujaca podany ciag znakow za pomoca transpozycji kolumnowej.",
        "task_id": "1193",
        "test_list": [
            "assert columnTransCipher('12345', '54321') == '54321'",
            "assert columnTransCipher('Data Science is fun', 'abcdefghijklmnopqrstuvwxyz') == 'daatcceeeffgnnssii'",
            "assert columnTransCipher('A quick brown fox jumps over the lazy dog', 'QWERTYUIOPASDFGHJKLZXCVBNM') == 'Auiqckbrwnfxjmpsovheylazydog'",
            "assert columnTransCipher('hello world', 'hlo') == 'hllowrdelo'",
            "assert columnTransCipher('abcde', '12345') == 'edcba'"
        ]
    },
    {
        "func_name": "compute_convolution_output_dimensions",
        "code": "def compute_convolution_output_dimensions(i, k, s=None, p=None, transposed=False):\n    def regular_conv(_i, _k, _s, _p):\n        return math.floor((_i + 2 * _p - _k) / _s) + 1\n    \n    def transposed_conv(_i, _k, _s, _p):\n        \"\"\"\n        A convolution described by k, s and p and whose input size i is such that i+2p\u2212k is a multiple of s has an\n        associated transposed convolution described by \u00ee , k' = k, s' = 1 and p' = k \u2212 p \u2212 1, where \u00ee  is the\n        size of the stretched input obtained by adding s \u2212 1 zeros between each input unit, and its output size is\n        \"\"\"\n        return _s * (_i - 1) + _k - 2 * _p\n    \n    i = (i,) if isinstance(i, int) else i\n    k = (k,) * len(i) if isinstance(k, int) else k\n\n    s = s if s is not None else [1] * len(i)\n    s = (s,) * len(i) if isinstance(s, int) else s\n    p = p if p is not None else [0] * len(i)\n    p = (p,) * len(i) if isinstance(p, int) else p\n    \n    if not transposed:\n        return [regular_conv(_i, _k, _s, _p) for _i, _k, _s, _p in zip(i, k, s, p)]\n    return [transposed_conv(_i, _k, _s, _p) for _i, _k, _s, _p in zip(i, k, s, p)]",
        "prompt": "Compute the output dimensions for a convolution.",
        "task_id": "1217",
        "test_list": [
            "assert compute_convolution_output_dimensions(32, 3, 1, 1, transposed=True) == [30]",
            "assert compute_convolution_output_dimensions(32, 3, 1, 1) == [30]",
            "assert compute_convolution_output_dimensions(32, 5, 2, 1, transposed=True) == [30]",
            "assert compute_convolution_output_dimensions((32, 32), (3, 3), (1, 1), (1, 1)) == [30, 30]",
            "assert compute_convolution_output_dimensions((32, 32), (5, 5), (2, 2), (1, 1), transposed=True) == [30, 30]"
        ]
    },
    {
        "func_name": "get_trackletpair_t_range",
        "code": "def get_trackletpair_t_range(t_min_1, t_max_1, t_min_2, t_max_2, window_len):\n    assert t_min_1 <= t_max_1 <= t_min_2 <= t_max_2\n    if t_max_1 == t_min_2:\n        if t_max_1 - t_min_1 > t_max_2 - t_min_2 and t_max_1 > t_min_1:\n            t_max_1 -= 1\n        elif t_max_1 - t_min_1 <= t_max_2 - t_min_2:\n            assert t_max_2 > t_min_2\n            t_min_2 += 1\n    if t_max_2 - t_min_1 + 1 <= window_len:\n        # window covers both of the tracklets\n        return t_min_1, t_max_1, t_min_2, t_max_2\n    # window can't cover both of the tracklets\n    mid_gap_t = int((t_max_1 + t_min_2) / 2) # the mid t point of the gap between two tracklets\n    if mid_gap_t - t_min_1 + 1 >= 0.5 * window_len and t_max_2 - mid_gap_t + 1 <= 0.5 * window_len:\n        # crop tracklet_1\n        return t_max_2-window_len+1, t_max_1, t_min_2, t_max_2\n    elif mid_gap_t - t_min_1 + 1 <= 0.5 * window_len and t_max_2 - mid_gap_t + 1 >= 0.5 * window_len:\n        # crop tracklet_2\n        return t_min_1, t_max_1, t_min_2, t_min_1+window_len-1\n    else:\n        # crop both tracklet_1 and tracklet_2\n        t_start_1 = mid_gap_t - int(0.5 * window_len) + 1\n        return t_start_1, t_max_1, t_min_2, t_start_1+window_len-1",
        "prompt": "get tracklet pair time range within a window_len.",
        "task_id": "1300",
        "test_list": [
            "assert get_trackletpair_t_range(0, 2, 3, 5, 4) == (3, 2, 3, 5)",
            "assert get_trackletpair_t_range(1, 5, 6, 10, 5) == (6, 5, 6, 10)",
            "assert get_trackletpair_t_range(1, 3, 4, 6, 5) == (4, 3, 4, 6)",
            "assert get_trackletpair_t_range(1, 2, 3, 4, 1) == (1, 2, 3, 3)",
            "assert get_trackletpair_t_range(2, 4, 5, 7, 3) == (5, 4, 5, 7)"
        ]
    },
    {
        "func_name": "get_bw_weight",
        "code": "\nclass Flag:\n    GUARD = 'guard'\n    EXIT = 'exit'\n    STABLE = 'stable'\n    HSDIR = 'hsdir'\n    HSDIR3 = 'hsdir3'\n\ndef get_bw_weight(flags, position, bw_weights):\n\n    if (position == 'g'):\n        if (Flag.GUARD in flags) and (Flag.EXIT in flags):\n            return bw_weights['Wgd']\n        elif (Flag.GUARD in flags):\n            return bw_weights['Wgg']\n        elif (Flag.EXIT not in flags):\n            return bw_weights['Wgm']\n        else:\n            # exit-flagged nodes without guard flag never serve in guard position\n            #raise ValueError('Wge weight does not exist.')\n            return 0\n    elif (position == 'm' or position == 'i'):\n        # intro points must have the Stable flag\n        if (position == 'i' and not Flag.STABLE in flags):\n            return 0.0\n        elif (Flag.GUARD in flags) and (Flag.EXIT in flags):\n            return bw_weights['Wmd']\n        elif (Flag.GUARD in flags):\n            return bw_weights['Wmg']\n        elif (Flag.EXIT in flags):\n            return bw_weights['Wme']\n        else:\n            return bw_weights['Wmm']\n    elif (position == 'e'):\n        if (Flag.GUARD in flags) and (Flag.EXIT in flags):\n            return bw_weights['Wed']\n        elif (Flag.GUARD in flags):\n            return bw_weights['Weg']\n        elif (Flag.EXIT in flags):\n            return bw_weights['Wee']\n        else:\n            return bw_weights['Wem']\n    elif (position == 'h2'):\n        if (Flag.HSDIR in flags):\n            return 1.0\n        else:\n            return 0.0\n    elif (position == 'h3'):\n        # stem doesn't define Flag.HSDIR3 yet\n        # https://gitweb.torproject.org/torspec.git/tree/proposals/224-rend-spec-ng.txt#n635\n        if (Flag.HSDIR3 in flags):\n            return 1.0\n        else:\n            return 0.0\n    else:\n        raise ValueError('get_weight does not support position {0}.'.format(\n            position))\n",
        "prompt": "Returns weight to apply to relay's bandwidth for given position, or for HSDirs, returns 1.0 when a relay has the flag, and 0.0 when it does not",
        "task_id": "1337",
        "test_list": [
            "assert get_bw_weight(['guard', 'hsdir', 'stable', 'hsdir3'], 'g', {'Wgd': 1, 'Wgg': 2, 'Wgm': 3, 'Wme': 4, 'Wmm': 5, 'Wmd': 6, 'Wmg': 7, 'Wme': 8, 'Wed': 9, 'Weg': 10, 'Wee': 11, 'Wem': 12}) == 1",
            "assert get_bw_weight(['guard', 'hsdir', 'exit'], 'g', {'Wgd': 1, 'Wgg': 2, 'Wgm': 3, 'Wme': 4, 'Wmm': 5, 'Wmd': 6, 'Wmg': 7, 'Wme': 8, 'Wed': 9, 'Weg': 10, 'Wee': 11, 'Wem': 12}) == 0",
            "assert get_bw_weight(['guard', 'hsdir', 'stable', 'hsdir3'], 'm', {'Wgd': 1, 'Wgg': 2, 'Wgm': 3, 'Wme': 4, 'Wmm': 5, 'Wmd': 6, 'Wmg': 7, 'Wme': 8, 'Wed': 9, 'Weg': 10, 'Wee': 11, 'Wem': 12}) == 0",
            "assert get_bw_weight(['guard', 'hsdir', 'stable', 'hsdir3'], 'e', {'Wgd': 1, 'Wgg': 2, 'Wgm': 3, 'Wme': 4, 'Wmm': 5, 'Wmd': 6, 'Wmg': 7, 'Wme': 8, 'Wed': 9, 'Weg': 10, 'Wee': 11, 'Wem': 12}) == 10",
            "assert get_bw_weight(['guard', 'hsdir'], 'g', {'Wgd': 1, 'Wgg': 2, 'Wgm': 3, 'Wme': 4, 'Wmm': 5, 'Wmd': 6, 'Wmg': 7, 'Wme': 8, 'Wed': 9, 'Weg': 10, 'Wee': 11, 'Wem': 12}) == 1"
        ]
    },
    {
        "func_name": "coordinate_sorter",
        "code": "def coordinate_sorter(start, stop, ascending_list):\n\tif len(ascending_list) == 0:\n\t\t#print('1st IF')\n\t\treturn 0\n\telse:\n\t\tfor current_index in range(0, len(ascending_list)):\n\n\t\t\tif start == stop and start in range(int(ascending_list[current_index]['coordinates']['start']), int(ascending_list[current_index]['coordinates']['stop'])+1):\n\t\t\t\t#print('2nd IF')\n\t\t\t\treturn current_index\n\n\t\t\telif start == stop and stop >= int(ascending_list[current_index]['coordinates']['stop']) and current_index+1 == len(ascending_list):\n\t\t\t\t#print('3rd IF')\n\t\t\t\treturn current_index+1\n\n\t\t\telif stop >= int(ascending_list[current_index]['coordinates']['stop']) and current_index+1 == len(ascending_list):\n\t\t\t\t#print('4th IF')\n\t\t\t\treturn current_index+1",
        "prompt": "Maintains an ascending list by properly placing the next object in order when given the start and stop coordinates of the current object and list desired to be maintained.",
        "task_id": "1365",
        "test_list": [
            "assert coordinate_sorter(0, 2, [{'coordinates': {'start': 0, 'stop': 1}}, {'coordinates': {'start': 2, 'stop': 3}}]) == 0",
            "assert coordinate_sorter(0, 0, [{'coordinates': {'start': 0, 'stop': 1}}, {'coordinates': {'start': 2, 'stop': 3}}]) == 0",
            "assert coordinate_sorter(0, 1, [{'coordinates': {'start': 0, 'stop': 1}}, {'coordinates': {'start': 2, 'stop': 3}}]) == 0",
            "assert coordinate_sorter(0, 1, [{'coordinates': {'start': 0, 'stop': 1}}, {'coordinates': {'start': 1, 'stop': 2}}]) == 0",
            "assert coordinate_sorter(1, 5, [{'coordinates': {'start': 1, 'stop': 3}}, {'coordinates': {'start': 4, 'stop': 6}}]) == 0"
        ]
    },
    {
        "func_name": "get_past_goal_indices",
        "code": "\ndef get_past_goal_indices(current_robot_time_index, goal_indices, filename='', verbose=0):\n    image_indices = [0]\n    total_goal_indices = len(goal_indices)\n    if verbose:\n        print('total images: ' + str(total_goal_indices))\n    image_index = 1\n    while image_index < current_robot_time_index and image_index < total_goal_indices:\n        if verbose > 0:\n            print('image_index: ' + str(image_index))\n        goal_image_index = goal_indices[image_index]\n        if goal_image_index < current_robot_time_index and goal_image_index < total_goal_indices:\n            if verbose > 0:\n                print('goal_indices[goal_image_index]: ' + str(goal_indices[goal_image_index]))\n            image_indices += [goal_image_index]\n            if goal_image_index <= goal_indices[image_index]:\n                image_index += 1\n        # TODO(ahundt) understand the cause of the warning below, modify the preprocessing script to correct it\n        elif goal_image_index >= total_goal_indices and verbose > 0:\n            print('block_stacking_reader.py::get_past_goal_indices(): warning, goal index equals '\n                  'or exceeds total_goal_indices. filename: ' + str(filename) +\n                  ' goal_image_index: ' + str(goal_image_index) +\n                  ' total_goal_indices: ' + str(total_goal_indices))\n        image_index += 1\n    return image_indices\n",
        "prompt": "get past goal image indices, including the initial image Arguments",
        "task_id": "1386",
        "test_list": [
            "assert get_past_goal_indices(0, [0, 1, 2, 3, 4, 5], verbose=1) == [0]",
            "assert get_past_goal_indices(5, [0, 2, 4, 6, 8], verbose=1) == [0, 2, 4]",
            "assert get_past_goal_indices(10, [0, 3, 6, 9], verbose=1) == [0, 3, 6, 9]",
            "assert get_past_goal_indices(7, [0, 2, 4, 6, 8, 10], verbose=1) == [0, 2, 4, 6]",
            "assert get_past_goal_indices(3, [0, 1, 2, 3, 4, 5], verbose=1) == [0, 1, 2]"
        ]
    },
    {
        "func_name": "_normalized_vcf",
        "code": "def _normalized_vcf(chr, pos, ref, alt):\n    for i in range(max(len(ref), len(alt))):\n        _ref = ref[i] if i < len(ref) else None\n        _alt = alt[i] if i < len(alt) else None\n        if _ref is None or _alt is None or _ref != _alt:\n            break\n\n    # _ref/_alt cannot be both None, if so, ref and alt are exactly the same, something is wrong with this VCF record\n    # assert not (_ref is None and _alt is None)\n    if _ref is None and _alt is None:\n        raise ValueError('\"ref\" and \"alt\" cannot be the same: {}'.format(\n            (chr, pos, ref, alt)\n        ))\n\n    _pos = int(pos)\n    if _ref is None or _alt is None:\n        # if either is None, del or ins types\n        _pos = _pos + i - 1\n        _ref = ref[i - 1:]\n        _alt = alt[i - 1:]\n    else:\n        # both _ref/_alt are not None\n        _pos = _pos + i\n        _ref = ref[i:]\n        _alt = alt[i:]\n\n    return chr, _pos, _ref, _alt",
        "prompt": "If both ref/alt are > 1 base, and there are overlapping from the left, we need to trim off the overlapping bases.",
        "task_id": "1475",
        "test_list": [
            "assert _normalized_vcf('chr5', '500', 'A', 'ATG') == ('chr5', 501, 'A', 'ATG')",
            "assert _normalized_vcf('chr4', '400', 'TT', 'T') == ('chr4', 401, 'T', 'T')",
            "assert _normalized_vcf('chr2', '200', 'ACGT', 'ACGTAC') == ('chr2', 202, 'ACGT', 'ACGT')",
            "assert _normalized_vcf('chr1', '100', 'A', 'AG') == ('chr1', 101, 'A', 'G')",
            "assert _normalized_vcf('chr3', '300', 'G', 'GTA') == ('chr3', 301, 'G', 'GTA')"
        ]
    },
    {
        "func_name": "categorizeSentimentcomplex",
        "code": "def categorizeSentimentcomplex(v, a):\n    sentiment = \"\"\n    angle = math.atan2(v, a)\n    pi = math.pi\n    if(0 <= angle < pi / 8):\n        sentiment = \"pleased\"\n    if(pi / 8 <= angle < pi / 4):\n        sentiment = \"happy\"\n    if(pi / 4 <= angle < pi / 3):\n        sentiment = \"delighted\"\n    if(pi / 3 <= angle < pi / 2):\n        sentiment = \"excited\"\n    if(angle == pi / 2):\n        sentiment = \"astonished\"\n    if(pi / 2 < angle < 2 * pi / 3):\n        sentiment = \"alarmed\"\n    if(2 * pi / 3 <= angle < 3 * pi / 4):\n        sentiment = \"mad\"\n    if(3 * pi / 4 <= angle < 5 * pi / 6):\n        sentiment = \"angry\"\n    if(5 * pi / 6 <= angle < pi):\n        sentiment = \"annoyed\"\n    if(pi <= angle < 7 * pi / 6):\n        sentiment = \"miserable\"\n    if(7 * pi / 6 <= angle < 5 * pi / 4):\n        sentiment = \"depressed\"\n    if(5 * pi / 4 <= angle > 4 * pi / 3):\n        sentiment = \"bored\"\n    if(4 * pi / 3 <= angle < 3 * pi / 2):\n        sentiment = \"tired\"\n    if(3 * pi / 2 <= angle < 5 * pi / 3):\n        sentiment = \"sleepy\"\n    if(5 * pi / 3 <= angle < 7 * pi / 4):\n        sentiment = \"relaxed\"\n    if(7 * pi / 4 <= angle < 11 * pi / 6):\n        sentiment = \"calm\"\n    if 11 * pi / 6 <= angle < 0:\n        sentiment = \"content\"\n    # machine learning is just if statements\n    return sentiment",
        "prompt": "Categorizes sentiment into more than the four most basic categories.",
        "task_id": "1504",
        "test_list": [
            "assert categorizeSentimentcomplex(1, 0) == 'happy'",
            "assert categorizeSentimentcomplex(1, 1) == 'pleased'",
            "assert categorizeSentimentcomplex(0, 0) == 'undefined'",
            "assert categorizeSentimentcomplex(0, -1) == 'content'",
            "assert categorizeSentimentcomplex(0, 1) == 'astonished'"
        ]
    },
    {
        "func_name": "uniformate2",
        "code": "\ndef uniformate2(word):\n    HARAKAT = ('FATHA', 'DAMMA', 'KASRA', 'SUKUN')\n    shakl = \"\"\n    word_nm = \"\"\n    i = 0\n    while i < len(word):\n        if word[i] not in HARAKAT:\n            word_nm += word[i]\n            if i + 1 < len(word) and word[i + 1] in HARAKAT:\n                if word[i + 1] == 'FATHA':\n                    if i + 2 < len(word) and word[i + 2] == 'ALEF' and i + 3 < len(word):\n                        shakl += 'ALEF_HARAKA'\n                        i += 3\n                    elif i + 2 < len(word) and word[i + 2] == 'ALEF_MAKSURA':\n                        shakl += 'FATHA_FATHA'\n                        word_nm += 'YEH'\n                        i += 3\n                    elif i + 2 < len(word) and word[i + 2] == 'ALEF' and i + 3 >= len(word):\n                        shakl += 'FATHA_FATHA'\n                        word_nm += 'WAW'\n                        i += 3\n                    else:\n                        shakl += 'FATHA'\n                        i += 2\n                elif word[i + 1] == 'DAMMA' and i + 2 < len(word) and word[i + 2] == 'WAW':\n                    if i + 3 >= len(word) or word[i + 3] not in HARAKAT:\n                        shakl += 'WAW_HARAKA'\n                        i += 3\n                    else:\n                        shakl += 'DAMMA'\n                        i += 2\n                elif word[i + 1] == 'KASRA' and i + 2 < len(word) and word[i + 2] == 'YEH':\n                    shakl += 'YEH_HARAKA'\n                    i += 3\n                else:\n                    shakl += word[i + 1]\n                    i += 2\n            elif i + 1 < len(word) and word[i + 1] == 'SHADDA':\n                shakl += 'SUKUN'\n                word_nm += word[i]\n                if i + 2 < len(word) and word[i + 2] in HARAKAT:\n                    if i + 3 < len(word) and word[i + 2] == 'FATHA' and word[i + 3] == 'ALEF':\n                        shakl += 'ALEF_HARAKA'\n                        i += 4\n                    elif i + 3 < len(word) and word[i + 2] == 'DAMMA' and word[i + 3] == 'WAW':\n                        shakl += 'WAW_HARAKA'\n                        i += 4\n                    elif i + 3 < len(word) and word[i + 2] == 'KASRA' and word[i + 3] == 'YEH':\n                        shakl += 'YEH_HARAKA'\n                        i += 4\n                    else:\n                        shakl += word[i + 2]\n                        i += 3\n                else:\n                    shakl += 'NOT_DEF_HARAKA'\n                    i += 2\n            elif i + 1 < len(word) and word[i + 1] in HARAKAT:\n                shakl += word[i + 1]\n            else:\n                shakl += 'NOT_DEF_HARAKA'\n                i += 1\n        else:\n            i += 1\n    if len(word_nm) == len(shakl):\n        return (word_nm, shakl)\n    else:\n        return (\"\", \"\")\n",
        "prompt": "separate the harakat and the letters of the given word, it return two strings ( the word without harakat and the harakat). If the weaked letters are reprsented as long harakat and striped from the word.",
        "task_id": "1627",
        "test_list": [
            "assert uniformate2('FATHAALIF') == ('ALIF', 'FATHA_FATHA')",
            "assert uniformate2('FATHAYEH') == ('YEH', 'FATHA')",
            "assert uniformate2('DAMMAWAW') == ('WAW', 'DAMMA')",
            "assert uniformate2('SHADDAALIF') == ('ALIF', 'SUKUN')",
            "assert uniformate2('KASRAYEH') == ('YEH', 'YEH_HARAKA')"
        ]
    },
    {
        "func_name": "wordparamcheck",
        "code": "def wordparamcheck(givenparams, expectedparams):\n\n    matchingindex = -1 # set default value to null (= -1)\n    matchedparam = \"NULL\"\n\n    for index in range(0, len(expectedparams)):\n        if (len(givenparams) == 1):\n            break\n        elif (expectedparams[index][0] == givenparams[1]):\n            matchingindex = index\n            matchedparam = givenparams[1]\n            break\n\n    numofparams = len(givenparams) - 2\n    params = []\n\n    matchfound = True\n    correctvalues = False\n\n    if (matchingindex == -1):\n        matchfound = False\n        correctvalues = False\n    else:\n\n        if (expectedparams[matchingindex][1] == \"more\"):\n            if (numofparams > 0):\n                correctvalues = True\n                params = givenparams\n                del params[0]\n                del params[0]\n        elif (expectedparams[matchingindex][1] == \"none\"):\n            if (numofparams == 0):\n                correctvalues = True\n                params = [\"NULL\"]\n        elif (expectedparams[matchingindex][1] == \"optional\"):\n            if (numofparams >= 0):\n                correctvalues = True\n                params = givenparams\n                del params[0]\n                del params[0]\n        elif (expectedparams[matchingindex][1] == \"skip\"):\n            params = [\"NULL\"]\n            correctvalues = True\n        else:\n            matchfound = False\n            correctvalues = False\n            params = [\"NULL\"]\n            matchedparam = \"INVALID\"\n\n    output = [matchfound, matchingindex, matchedparam, correctvalues, numofparams, params]\n    return output",
        "prompt": "New version of the word and parameter check Returned values will be given in a list form OUTPUT = [if it matched, matched index, matched value,\\ if the correct num of params given,\\ num of params, list of params]",
        "task_id": "1660",
        "test_list": [
            "assert wordparamcheck(['param1', 'value1', 'param2'], [['param1', 'exact'], ['param2', 'skip']]) == [True, 0, 'param1', True, 1, ['value1']]",
            "assert wordparamcheck(['param1', 'value1', 'param2'], [['param1', 'exact'], ['param2', 'none']]) == [True, 0, 'param1', False, 1, ['value1', 'param2']]",
            "assert wordparamcheck(['param1', 'value1', 'param2'], [['param1', 'exact'], ['param2', 'exact']]) == [True, 0, 'param1', True, 1, ['value1']]",
            "assert wordparamcheck(['param1', 'value1', 'param2'], [['param1', 'exact'], ['param2', 'exact']]) == [True, 0, 'param1', True, 1, ['value1', 'param2']]",
            "assert wordparamcheck(['param1', 'value1', 'param2'], [['param1', 'exact'], ['param2', 'optional']]) == [True, 0, 'param1', True, 1, ['value1', 'param2']]"
        ]
    },
    {
        "func_name": "splitIA2Attribs",
        "code": "def splitIA2Attribs(attribsString):\r\n\tattribsDict = {}\r\n\ttmp = \"\"\r\n\tkey = \"\"\r\n\tsubkey = \"\"\r\n\tsubattr = {}\r\n\tinEscape = False\r\n\tfor char in attribsString:\r\n\t\tif inEscape:\r\n\t\t\ttmp += char\r\n\t\t\tinEscape = False\r\n\t\telif char == \"\\\\\":\r\n\t\t\tinEscape = True\r\n\t\telif char == \":\":\r\n\t\t\t# We're about to move on to the value, so save the key and clear tmp.\r\n\t\t\tkey = tmp\r\n\t\t\ttmp = \"\"\r\n\t\telif char == \"=\":\r\n\t\t\t# This is a subattribute.\r\n\t\t\t# Save the subattribute key and clear tmp, ready for the value.\r\n\t\t\tsubkey = tmp\r\n\t\t\ttmp = \"\"\r\n\t\telif char == \",\":\r\n\t\t\t# We're about to move on to a new subattribute.\r\n\t\t\t# Add this subattribute key/value pair to the dict.\r\n\t\t\tif subkey:\r\n\t\t\t\tsubattr[subkey] = tmp\r\n\t\t\t\tsubkey = \"\"\r\n\t\t\t\ttmp = \"\"\r\n\t\telif char == \";\":\r\n\t\t\t# We're about to move on to a new attribute.\r\n\t\t\tif subkey:\r\n\t\t\t\t# Add the last subattribute key/value pair to the dict.\r\n\t\t\t\tsubattr[subkey] = tmp\r\n\t\t\t\tsubkey = \"\"\r\n\t\t\tif subattr:\r\n\t\t\t\t# This attribute had subattributes.\r\n\t\t\t\t# Add the key/subattribute pair to the dict.\r\n\t\t\t\tattribsDict[key] = subattr\r\n\t\t\t\tsubattr = {}\r\n\t\t\telif key:\r\n\t\t\t\t# Add this key/value pair to the dict.\r\n\t\t\t\tattribsDict[key] = tmp\r\n\t\t\tkey = \"\"\r\n\t\t\ttmp = \"\"\r\n\t\telse:\r\n\t\t\ttmp += char\r\n\t# If there was no trailing semi-colon, we need to handle the last attribute.\r\n\tif subkey:\r\n\t\t# Add the last subattribute key/value pair to the dict.\r\n\t\tsubattr[subkey] = tmp\r\n\tif subattr:\r\n\t\t# This attribute had subattributes.\r\n\t\t# Add the key/subattribute pair to the dict.\r\n\t\tattribsDict[key] = subattr\r\n\telif key:\r\n\t\t# Add this key/value pair to the dict.\r\n\t\tattribsDict[key] = tmp\r\n\treturn attribsDict",
        "prompt": "Split an IAccessible2 attributes string into a dict of attribute keys and values. An invalid attributes string does not cause an error, but strange results may be returned. Subattributes are handled. Subattribute keys and values are placed into a dict which becomes the value of the attribute.",
        "task_id": "1720",
        "test_list": [
            "assert splitIA2Attribs('background:lightgray, foreground:black;') == {'background': {'lightgray': None}, 'foreground': {'black': None}}",
            "assert splitIA2Attribs('width:100%; height:200px;') == {'width': {'100%': None}, 'height': '200px'}",
            "assert splitIA2Attribs('border:1px solid black, padding:5px;') == {'border': {'1px solid black': None}, 'padding': '5px'}",
            "assert splitIA2Attribs('color:blue, font:12pt;size:10;') == {'color': {'blue': None}, 'font': {'12pt': None}, 'size': '10'}",
            "assert splitIA2Attribs('margin:10px 20px;') == {'margin': {'10px 20px': None}}"
        ]
    },
    {
        "func_name": "decode_address_entry",
        "code": "def decode_address_entry(string, sort=False):\n\n    sections = string.split(\":\")\n    sec_len = len(sections)\n\n    if sec_len > 3:\n        print(\"Error in string \", string)\n        return []\n\n    # do everything backwards\n    # asics\n    asics = []\n    if sec_len == 3 and len(sections[2]) > 0:\n        _asics = sections[2].split(\",\")\n        asics = [int(a)-1 for a in _asics if int(a) in range(1, 3)]\n    else:\n        asics = [0, 1]\n\n    # asics\n    cables = []\n    if sec_len >= 2 and len(sections[1]) > 0:\n        _cables = sections[1].split(\",\")\n        cables = [int(c)-1 for c in _cables if int(c) in range(1, 4)]\n    else:\n        cables = [0, 1, 2]\n\n    # check address\n    address = sections[0]\n    if len(address) == 6:\n        if address[0:2] != \"0x\":\n            print(\"Incorrect address in string: \", string)\n            return []\n    elif len(address) == 4:\n        address = \"0x\" + address\n    else:\n        print(\"Incorrect address in string: \", string)\n        return []\n\n    if sort:\n        tup = [[x] + [y] + [z] for x in [address, ] for y in cables for z in asics]\n    else:\n        tup = [[x] + [y] + [z] for x in [address, ] for z in asics for y in cables]\n\n    return tup",
        "prompt": "Converts address into [ trbnet, cable, cable, asic ] tuples",
        "task_id": "1810",
        "test_list": [
            "assert decode_address_entry('0x123456:1,2:1:2:3', sort=True) == [['0x123456', 0, 1, 2, 3, 1, 2, 1, 2]]",
            "assert decode_address_entry('0x123456:1,2:1:2') == [['0x123456', 0, 1, 2, 1, 2]]",
            "assert decode_address_entry('0x123456:1,2:1') == [['0x123456', 0, 1, 1]]",
            "assert decode_address_entry('0x123456:1,2:1:2:3:4:5', sort=True) == [['0x123456', 0, 1, 2, 3, 4, 5, 1, 2, 1, 2]]",
            "assert decode_address_entry('0x123456:1,2:1:2:3:4', sort=False) == [['0x123456', 0, 1, 2, 3, 4, 1, 2, 1, 2]]"
        ]
    },
    {
        "func_name": "make_similar",
        "code": "def make_similar(nums, target):\n    odd_nums = sorted([n for n in nums if n & 1])\n    even_nums = sorted([n for n in nums if not n & 1])\n    odd_target = sorted([t for t in target if t & 1])\n    even_target = sorted([t for t in target if not t & 1])\n    odd_diff = sum(abs(a - b) for a, b in zip(odd_nums, odd_target))\n    even_diff = sum(abs(a - b) for a, b in zip(even_nums, even_target))\n    return (odd_diff + even_diff) // 4",
        "prompt": "Operations can add or subtract 2 to elements, so we have to process odd and even numbers separately (an odd number will not be equal to an even number, and vice versa). We sort odd and even numbers separately, and find the difference between the sorted arrays of nums and target. We finally divide by 4 because each operation can add (or subtract) 2 to 2 numbers.",
        "task_id": "1847",
        "test_list": [
            "assert make_similar([10, 12, 14, 16], [10, 12, 14, 16]) == 0",
            "assert make_similar([1, 3, 5, 7], [2, 4, 6, 8]) == 4",
            "assert make_similar([1, 2, 3, 4], [2, 3, 4, 5]) == 1",
            "assert make_similar([10, 20, 30, 40], [15, 25, 35, 45]) == 10",
            "assert make_similar([5, 7, 9, 11], [6, 8, 10, 12]) == 4"
        ]
    },
    {
        "func_name": "generateResultTree",
        "code": "\ndef generateResultTree(cards):\n    results = [0]*16\n    perms = [[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1,1,1],[1,0,0,0],[1,0,0,1],[1,0,1,0],[1,0,1,1],[1,1,0,0],[1,1,0,1],[1,1,1,0],[1,1,1,1]]\n    for i in range(len(perms)):\n        p = perms[i]\n        lead = 0\n        topCard = [lead, cards[lead][p[lead]]]\n        illegalPlay = False\n        for j in range(3):\n            lead += 1\n            if lead >= len(cards):\n                lead = 0\n            if cards[lead][p[lead]][0] == topCard[1][0]:\n                if cards[lead][p[lead]][1] > topCard[1][1]:\n                    topCard = [lead, cards[lead][p[lead]]]\n            else:\n                illegalPlay = illegalPlay or (cards[lead][1 - p[lead]][0] == topCard[1][0])\n        if not illegalPlay:\n            results[i] += 1 - topCard[0]%2\n            lead = topCard[0]\n            topCard = [lead, cards[lead][1 - p[lead]]]\n            for j in range(3):\n                lead += 1\n                if lead >= len(cards):\n                    lead = 0\n                if cards[lead][1 - p[lead]][0] == topCard[1][0]:\n                    if cards[lead][1 - p[lead]][1] > topCard[1][1]:\n                        topCard = [lead, cards[lead][1 - p[lead]]]\n            results[i] += 1 - topCard[0]%2\n        else:\n            results[i] = -1\n    return results\n",
        "prompt": "Returns a 16 long array for the results of the tree based on the cards. [0000, 0001, ..., 1111]",
        "task_id": "1850",
        "test_list": [
            "assert generateResultTree([[1, 1], [1, 1], [1, 1]]) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
            "assert generateResultTree([[1, 1], [1, 0], [0, 1]]) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
            "assert generateResultTree([[0, 0], [0, 1], [1, 0]]) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
            "assert generateResultTree([[1, 0], [0, 1], [1, 1]]) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
            "assert generateResultTree([[0, 1], [1, 0], [1, 1]]) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
        ]
    },
    {
        "func_name": "identify_distance_type",
        "code": "def identify_distance_type(candidate, word):\n    edit = [False] * 4\n    correct = \"\"\n    error = \"\"\n    x = ''\n    w = ''\n    for i in range(min([len(word), len(candidate)]) - 1):\n        if candidate[0:i + 1] != word[0:i + 1]:\n            if candidate[i:] == word[i - 1:]:\n                edit[1] = True\n                correct = candidate[i - 1]\n                error = ''\n                x = candidate[i - 2]\n                w = candidate[i - 2] + candidate[i - 1]\n                break\n            elif candidate[i:] == word[i + 1:]:\n\n                correct = ''\n                error = word[i]\n                if i == 0:\n                    w = '#'\n                    x = '#' + error\n                else:\n                    w = word[i - 1]\n                    x = word[i - 1] + error\n                edit[0] = True\n                break\n            if candidate[i + 1:] == word[i + 1:]:\n                edit[2] = True\n                correct = candidate[i]\n                error = word[i]\n                x = error\n                w = correct\n                break\n            if candidate[i] == word[i + 1] and candidate[i + 2:] == word[i + 2:]:\n                edit[3] = True\n                correct = candidate[i] + candidate[i + 1]\n                error = word[i] + word[i + 1]\n                x = error\n                w = correct\n                break\n    candidate = candidate[::-1]\n    word = word[::-1]\n    for i in range(min([len(word), len(candidate)]) - 1):\n        if candidate[0:i + 1] != word[0:i + 1]:\n            if candidate[i:] == word[i - 1:]:\n                edit[1] = True\n                correct = candidate[i - 1]\n                error = ''\n                x = candidate[i - 2]\n                w = candidate[i - 2] + candidate[i - 1]\n                break\n            elif candidate[i:] == word[i + 1:]:\n\n                correct = ''\n                error = word[i]\n                if i == 0:\n                    w = '#'\n                    x = '#' + error\n                else:\n                    w = word[i - 1]\n                    x = word[i - 1] + error\n                edit[0] = True\n                break\n            if candidate[i + 1:] == word[i + 1:]:\n                edit[2] = True\n                correct = candidate[i]\n                error = word[i]\n                x = error\n                w = correct\n                break\n            if candidate[i] == word[i + 1] and candidate[i + 2:] == word[i + 2:]:\n                edit[3] = True\n                correct = candidate[i] + candidate[i + 1]\n                error = word[i] + word[i + 1]\n                x = error\n                w = correct\n                break\n    if word == candidate:\n        return \"None\", '', '', '', ''\n    if edit[1]:\n        return \"del\", correct, error, x, w\n    elif edit[0]:\n        return \"ins\", correct, error, x, w\n    elif edit[2]:\n        return \"sub\", correct, error, x, w\n    elif edit[3]:\n        return \"trans\", correct, error, x, w",
        "prompt": "This function identify the distance type between candidate word and real word",
        "task_id": "1866",
        "test_list": [
            "assert identify_distance_type('test', 'tset') == ('trans', 'e', 't', 'et', 'et')",
            "assert identify_distance_type('python', 'java') == ('trans', 'y', 't', 'yt', 'yt')",
            "assert identify_distance_type('hello', 'hallo') == ('trans', 'e', 'l', 'el', 'el')",
            "assert identify_distance_type('cat', 'bat') == ('ins', 'a', 't', 't', 'at')",
            "assert identify_distance_type('dog', 'fog') == ('ins', 'd', 'g', 'g', 'dg')"
        ]
    },
    {
        "func_name": "score_calculation_base",
        "code": "def score_calculation_base(han, fu, is_dealer, is_zimo):\n        if han == 0:\n            return 0, ''\n        elif han < 5:  # when han < 5, the fu has influence on the final point\n            if (fu >= 40 and han >= 4) or (fu >= 70 and han >= 3):\n                if is_dealer:\n                    return 12000, \"\u6e80\u8cab4000\u70b9\u2200\" if is_zimo else \"\u6e80\u8cab12000\u70b9\"\n                else:\n                    return 8000, \"\u6e80\u8cab2000-4000\u70b9\" if is_zimo else \"\u6e80\u8cab8000\u70b9\"\n            base_score = fu * (2 ** (han + 2))\n            if is_zimo:\n                if is_dealer:\n                    each = ((base_score * 2 - 1) // 100 + 1) * 100\n                    return each * 3, \"{}\u7b26{}Han{}\u70b9\u2200\".format(fu, han, each)\n                else:\n                    dscore = ((base_score * 2 - 1) // 100 + 1) * 100\n                    xscore = ((base_score - 1) // 100 + 1) * 100\n                    return dscore + 2 * xscore, \"{}\u7b26{}Han{}-{}\u70b9\".format(fu, han, xscore, dscore)\n            else:\n                score = ((base_score * 6 - 1) // 100 + 1) * 100 if is_dealer else ((base_score * 4 - 1) // 100 + 1) * 100\n                return score, \"{}\u7b26{}Han{}\u70b9\".format(fu, han, score)\n        elif han == 5: # when han >= 5, the fu does not make any difference to final score\n            if is_dealer:\n                return 12000, \"\u6e80\u8cab4000\u70b9\u2200\" if is_zimo else \"\u6e80\u8cab12000\u70b9\"\n            else:\n                return 8000, \"\u6e80\u8cab2000-4000\u70b9\" if is_zimo else \"\u6e80\u8cab8000\u70b9\"\n        elif 6 <= han <= 7:\n            if is_dealer:\n                return 18000, \"\u8df3\u6ee16000\u70b9\u2200\" if is_zimo else \"\u8df3\u6ee118000\u70b9\"\n            else:\n                return 12000, \"\u8df3\u6ee13000-6000\u70b9\" if is_zimo else \"\u8df3\u6ee112000\u70b9\"\n        elif 8 <= han <= 10:\n            if is_dealer:\n                return 24000, \"\u500d\u6ee18000\u70b9\u2200\" if is_zimo else \"\u500d\u6ee124000\u70b9\"\n            else:\n                return 16000, \"\u500d\u6ee14000-8000\u70b9\" if is_zimo else \"\u500d\u6ee116000\u70b9\"\n        elif 11 <= han <= 12:\n            if is_dealer:\n                return 36000, \"\u4e09\u500d\u6ee112000\u70b9\u2200\" if is_zimo else \"\u4e09\u500d\u6ee136000\u70b9\"\n            else:\n                return 24000, \"\u4e09\u500d\u6ee16000-12000\u70b9\" if is_zimo else \"\u4e09\u500d\u6ee124000\u70b9\"\n        else:\n            if is_dealer:\n                return 48000, \"\u5f79\u6ee116000\u70b9\u2200\" if is_zimo else \"\u5f79\u6ee148000\u70b9\"\n            else:\n                return 32000, \"\u5f79\u6ee18000-16000\u70b9\" if is_zimo else \"\u5f79\u6ee132000\u70b9\"",
        "prompt": "Calculate the base score knowing the han and fu value. Fu is a value which stands for a base point, and han is the exponential factor of final scores. The very basic score calculation is as follows, while it involves more other details. | base_score = fu (2 (han + 2)) |",
        "task_id": "1941",
        "test_list": [
            "assert score_calculation_base(9, 50, False, False) == (16000, '\u500d\u6ee14000-8000\u70b9')",
            "assert score_calculation_base(0, 50, True, False) == (0, '')",
            "assert score_calculation_base(7, 50, False, False) == (12000, '\u8df3\u6ee13000-6000\u70b9')",
            "assert score_calculation_base(8, 50, False, False) == (16000, '\u500d\u6ee14000-8000\u70b9')",
            "assert score_calculation_base(10, 50, False, False) == (16000, '\u500d\u6ee14000-8000\u70b9')"
        ]
    },
    {
        "func_name": "min_edit_script",
        "code": "def min_edit_script(source, target, allow_copy=False):\n    a = [[(len(source) + len(target) + 1, None)] * (len(target) + 1) for _ in range(len(source) + 1)]\n    for i in range(0, len(source) + 1):\n        for j in range(0, len(target) + 1):\n            if i == 0 and j == 0:\n                a[i][j] = (0, \"\")\n            else:\n                if allow_copy and i and j and source[i - 1] == target[j - 1] and a[i - 1][j - 1][0] < a[i][j][0]:\n                    a[i][j] = (a[i - 1][j - 1][0], a[i - 1][j - 1][1] + \"\u2192\")\n                if i and a[i - 1][j][0] < a[i][j][0]:\n                    a[i][j] = (a[i - 1][j][0] + 1, a[i - 1][j][1] + \"-\")\n                if j and a[i][j - 1][0] < a[i][j][0]:\n                    a[i][j] = (a[i][j - 1][0] + 1, a[i][j - 1][1] + \"+\" + target[j - 1])\n    return a[-1][-1][1]",
        "prompt": "Finds the minimum edit script to transform the source to the target",
        "task_id": "1985",
        "test_list": [
            "assert min_edit_script('intention', 'execution') == 'i\u2192e\u2192x\u2192e\u2192c\u2192u\u2192t\u2192i\u2192o\u2192n\u2192+n'",
            "assert min_edit_script('flaw', 'lawn') == 'f\u2192l\u2192a\u2192w'",
            "assert min_edit_script('algorithm', 'altruistic') == 'a\u2192l\u2192t\u2192r\u2192i\u2192z\u2192m\u2192o\u2192n\u2192+a\u2192l\u2192u\u2192t\u2192r\u2192i\u2192s\u2192t\u2192i\u2192c'",
            "assert min_edit_script('abc', 'yabd') == 'a\u2192y\u2192a\u2192b\u2192d'",
            "assert min_edit_script('kitten', 'sitting') == 's\u2192i\u2192t\u2192t\u2192+i\u2192g'"
        ]
    },
    {
        "func_name": "common_conv2d_pool_output_shape",
        "code": "def common_conv2d_pool_output_shape(input_NHWC, filter_HWIO, stride_NHWC, padding):\n    # check inputs\n    if padding != 'SAME' and padding != 'VALID':\n        raise ValueError(\"Padding must be 'SAME' or 'valid'.\")\n    if not (len(input_NHWC) == len(filter_HWIO) == len(stride_NHWC) == 4):\n        raise ValueError(\n            \"input_NHWC, filter_HWIO, stride_NHWC must be length 4.\")\n\n    # get input / filter shape\n    N, H, W, C = input_NHWC\n    R, S, C_, K = filter_HWIO\n    if C != C_:\n        raise ValueError(\"Input channel must be the same as filter channel.\")\n\n    # only support [1, X, X, 1] stride_NHWC for importer now\n    if stride_NHWC[0] != 1 or stride_NHWC[3] != 1:\n        raise NotImplementedError(\"Strides on batch axis (N) and channel axis \"\n                                  \"(C) must be 1 for importer.\")\n\n    # get output shape\n    if 'SAME' == padding:\n        out_height = math.ceil(float(H) / float(stride_NHWC[1]))\n        out_width = math.ceil(float(W) / float(stride_NHWC[2]))\n    elif 'VALID' == padding:\n        out_height = math.ceil(float(H - R + 1) / float(stride_NHWC[1]))\n        out_width = math.ceil(float(W - S + 1) / float(stride_NHWC[2]))\n\n    return tuple([int(i) for i in [N, out_height, out_width, K]])",
        "prompt": "Get output shape for convolution or padding.",
        "task_id": "2059",
        "test_list": [
            "assert common_conv2d_pool_output_shape((1, 28, 28, 1), (5, 5, 1, 32), (1, 1, 1, 1), 'SAME') == (1, 28, 28, 32)",
            "assert common_conv2d_pool_output_shape((1, 28, 28, 3), (3, 3, 3, 16), (1, 1, 1, 1), 'VALID') == (1, 26, 26, 16)",
            "assert common_conv2d_pool_output_shape((1, 32, 32, 3), (3, 3, 3, 64), (2, 2, 2, 1), 'SAME') == (1, 32, 32, 64)",
            "assert common_conv2d_pool_output_shape((1, 64, 64, 3), (3, 3, 3, 128), (1, 1, 1, 1), 'SAME') == (1, 64, 64, 128)",
            "assert common_conv2d_pool_output_shape((1, 64, 64, 3), (7, 7, 3, 128), (2, 2, 2, 1), 'VALID') == (1, 58, 58, 128)"
        ]
    },
    {
        "func_name": "featurize_finance",
        "code": "def featurize_finance(investment, average_money):\n\n\t#newVec = [0, 0, 0, 0, 0, 0, 0, 0]\n\tnewVec = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n\tif investment == 0: money = average_money\n\telse: money = investment\n\n\tif   money < 1*10**5: newVec[0]=1\n\telif money < 5*10**5: newVec[1]=1\n\telif money < 1*10**6: newVec[2]=1\n\telif money < 5*10**6: newVec[3]=1\n\telif money < 1*10**7: newVec[4]=1\n\telif money < 5*10**7: newVec[5]=1\n\telif money < 1*10**8: newVec[6]=1\n\telif money < 5*10**8: newVec[7]=1\n\telif money < 1*10**9: newVec[8]=1\n\telse: newVec[9]=1\n\n\treturn newVec",
        "prompt": "Converts a single monetary investment into an extracted feature vector, where the amount is bucketed based on magnitude.",
        "task_id": "2086",
        "test_list": [
            "assert featurize_finance(500000, 0) == [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
            "assert featurize_finance(0, 500000) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",
            "assert featurize_finance(0, 0) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
            "assert featurize_finance(5000000, 0) == [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",
            "assert featurize_finance(1500000, 0) == [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]"
        ]
    },
    {
        "func_name": "tmux_format",
        "code": "\nfrom datetime import timedelta\n\ndef tmux_format(working, x):\n    if working and x.days >= 0:\n        message = \"KW\"\n        r = \"reverse\"\n        fg = \"colour4\"\n        bg = \"white\"\n    elif working and x.days < 0:\n        message = \"HB\"\n        r = \"noreverse\"\n        fg = \"black\"\n        bg = \"yellow\"\n    elif not working and x.days >= 0:\n        message = \"EB\"\n        r = \"noreverse\"\n        fg = \"black\"\n        bg = \"green\"\n    elif not working and x.days < 0:\n        message = \"GW\"\n        r = \"reverse\"\n        fg = \"colour1\"\n        bg = \"white\"\n\n    s = \"#[%s,fg=%s,bg=%s]  %s\" % (r, fg, bg, message)\n\n    if x.days >= 0:\n        n = x.seconds / 60 + 1\n        if n == 1:\n            s += \": %d min\" % n\n        else:\n            s += \": %d mins\" % n\n\n    return s + \"  \"\n",
        "prompt": "A function for formatting the output for the tmux status bar. working is a boolean, x is timedelta until important time",
        "task_id": "2109",
        "test_list": [
            "assert tmux_format(True, timedelta(days=1, seconds=30)) == '#[reverse,fg=colour4,bg=white]  KW: 2 mins' + '  '",
            "assert tmux_format(True, timedelta(days=0, seconds=60)) == '#[reverse,fg=colour4,bg=white]  KW: 1 min' + '  '",
            "assert tmux_format(True, timedelta(seconds=0)) == '#[reverse,fg=colour4,bg=white]  KW: 0 min' + '  '",
            "assert tmux_format(False, timedelta(days=0, seconds=0)) == '#[noreverse,fg=black,bg=green]  EB: 0 min' + '  '",
            "assert tmux_format(False, timedelta(days=-1, seconds=45)) == '#[noreverse,fg=black,bg=yellow]  GW: 1 min' + '  '"
        ]
    },
    {
        "func_name": "next_point_in_8_neigh",
        "code": "def next_point_in_8_neigh(b, c):\r\n    if c[0]-1 == b[0] and c[1]+1 == b[1]:\r\n        return (b[0], b[1]-1)\r\n    if c[0] == b[0] and c[1]+1 == b[1]:\r\n        return (b[0]-1, b[1]-1)\r\n    if c[0]+1 == b[0] and c[1]+1 == b[1]:\r\n        return (b[0]-1, b[1])\r\n    if c[0]+1 == b[0] and c[1] == b[1]:\r\n        return (b[0]-1, b[1]+1)\r\n    if c[0]+1 == b[0] and c[1]-1 == b[1]:\r\n        return (b[0], b[1]+1)\r\n    if c[0] == b[0] and c[1]-1 == b[1]:\r\n        return (b[0]+1, b[1]+1)\r\n    if c[0]-1 == b[0] and c[1]-1 == b[1]:\r\n        return (b[0]+1, b[1])\r\n    if c[0]-1 == b[0] and c[1] == b[1]:\r\n        return (b[0]+1, b[1]-1)",
        "prompt": "Next point of 8neighbourhood b in clockwise order",
        "task_id": "2244",
        "test_list": [
            "assert next_point_in_8_neigh((0, 0), (1, 1)) == (0, 1)",
            "assert next_point_in_8_neigh((1, 1), (1, 0)) == (1, 2)",
            "assert next_point_in_8_neigh((2, 2), (1, 2)) == (1, 2)",
            "assert next_point_in_8_neigh((1, 1), (1, 2)) == (1, 0)",
            "assert next_point_in_8_neigh((0, 0), (0, 1)) == (0, -1)"
        ]
    },
    {
        "func_name": "cal_overlap_neg_strand",
        "code": "\nCOMP_OVL = \"Complete overlap\"\nNO_OVL = \"No overlap\"\n\ndef cal_overlap_neg_strand(s1, e1, s2, e2):\n\n    overlap = None\n\n    len1 = abs(e1 - s1)\n    len2 = abs(e2 - s2)\n\n    min_len = min(len1, len2)\n\n    # seq2 within seq1 region - this may match the partial overlap case\n    if s1 > s2 and e1 < e2:\n        overlap = COMP_OVL\n\n    # no overlap, seq1 before seq2\n    elif s1 > s2 and e1 >= s2:\n        overlap = NO_OVL\n\n    # partial overlap, seq1 before seq2\n    elif s1 >= s2 and s2 > e1 and e1 >= e2:\n        overlap = float(s2 - e1 + 1) / float(min_len)\n\n    # seq1 within seq2 region\n    elif s2 > s1 and e1 > e2:\n        overlap = COMP_OVL\n\n    # no overlap, seq2 before seq1\n    elif s2 > s1 and e2 >= s1:\n        overlap = NO_OVL\n\n    # partial overlap, seq2 before seq1\n    elif s2 >= s1 and s1 > e2 and e2 >= e1:\n        overlap = float(s1 - e2 + 1) / float(min_len)\n\n    return overlap\n",
        "prompt": "Calculates the region overlap between two regions on the 3' strand and returns the degree of overlap",
        "task_id": "2261",
        "test_list": [
            "assert cal_overlap_neg_strand(200, 300, 250, 350) == COMP_OVL",
            "assert cal_overlap_neg_strand(0, 100, 50, 150) == COMP_OVL",
            "assert cal_overlap_neg_strand(300, 400, 350, 450) == COMP_OVL",
            "assert cal_overlap_neg_strand(100, 200, 150, 250) == COMP_OVL",
            "assert cal_overlap_neg_strand(50, 150, 100, 200) == COMP_OVL"
        ]
    },
    {
        "func_name": "find_repeat",
        "code": "\nFUNCTIONS = ['up', 'down', 'left', 'right']\n\ndef find_repeat(directions: list) -> list:\n    max_match = 4\n\n    # skip compressed patterns\n    start_index = 0\n    for start_index, direction in enumerate(directions):\n        if direction not in FUNCTIONS:\n            break\n\n    # index for first pattern\n    end_index = start_index\n\n    # index for second pattern\n    second_index = end_index + 2\n\n    # directions matched\n    match_count = 0\n\n    # look until all results exhausted\n    while second_index < len(directions):\n        # compare and move to next character\n        if directions[end_index] == directions[second_index] \\\n                and directions[end_index] not in FUNCTIONS \\\n                and directions[second_index] not in FUNCTIONS:\n            match_count += 1\n            if match_count == max_match:\n                break\n            if end_index >= second_index - match_count + 1:\n                match_count -= 1\n                break\n            else:\n                end_index += 1\n        else:\n            # found a match\n            if match_count > 1:\n                end_index -= 1\n                break\n            # no matching pattern restart check\n            else:\n                end_index = start_index\n                match_count = 0\n\n        second_index += 1\n\n    return directions[start_index: end_index + 1]\n",
        "prompt": "find repeats in direction list only a max of 4 per function",
        "task_id": "2317",
        "test_list": [
            "assert find_repeat(['left', 'left', 'left', 'right', 'up', 'up', 'down', 'down', 'down', 'right', 'left', 'left']) == ['left', 'left', 'left', 'right']",
            "assert find_repeat(['down', 'down', 'down', 'down', 'up', 'up', 'up', 'up', 'left', 'left', 'right', 'right']) == ['down', 'down', 'down', 'down']",
            "assert find_repeat(['up', 'up', 'down', 'left', 'left', 'left', 'right', 'up', 'up', 'up', 'up']) == ['up', 'up', 'left', 'left', 'left']",
            "assert find_repeat(['down', 'down', 'right', 'up', 'up', 'down', 'down', 'right', 'left', 'left', 'up', 'up']) == ['down', 'down', 'right', 'up', 'up']",
            "assert find_repeat(['up', 'up', 'up', 'up', 'down', 'down', 'down', 'down', 'left', 'left', 'right', 'right']) == ['up', 'up', 'up', 'up']"
        ]
    },
    {
        "func_name": "get_next_queen_recursion_coordinates",
        "code": "\nclass Square:\n    def __init__(self, rank, file):\n        self.rank = rank\n        self.file = file\n\ndef get_next_queen_recursion_coordinates(current_square, horizontal_coordinate, target_square, vertical_coordinate):\n    next_square_rank = current_square.rank\n    next_square_file = current_square.file\n    if vertical_coordinate == horizontal_coordinate:\n        if vertical_coordinate > 0:\n            next_square_rank = target_square.rank + 1\n            next_square_file = target_square.file + 1\n        elif vertical_coordinate < 0:\n            next_square_rank = target_square.rank - 1\n            next_square_file = target_square.file - 1\n    elif vertical_coordinate == -horizontal_coordinate:\n        if vertical_coordinate > 0:\n            next_square_rank = target_square.rank + 1\n            next_square_file = target_square.file - 1\n        elif vertical_coordinate < 0:\n            next_square_rank = target_square.rank - 1\n            next_square_file = target_square.file + 1\n    elif horizontal_coordinate == 0:\n        if vertical_coordinate > 0:\n            next_square_rank = target_square.rank + 1\n        elif vertical_coordinate < 0:\n            next_square_rank = target_square.rank - 1\n    elif vertical_coordinate == 0:\n        if horizontal_coordinate > 0:\n            next_square_file = target_square.file + 1\n        elif horizontal_coordinate < 0:\n            next_square_file = target_square.file - 1\n    return next_square_file, next_square_rank\n",
        "prompt": "Method to obtain the coordinates of the next move in the queen's move validity recursion. If the move is a diagonal one, horizontal one or vertical one, the method returns the adequate next step to be validated.",
        "task_id": "2385",
        "test_list": [
            "assert get_next_queen_recursion_coordinates(Square(4, 4), 0, Square(4, 4), -1) == (3, 3)",
            "assert get_next_queen_recursion_coordinates(Square(4, 4), -1, Square(4, 4), 0) == (3, 4)",
            "assert get_next_queen_recursion_coordinates(Square(4, 4), 0, Square(4, 4), 0) == (4, 5)",
            "assert get_next_queen_recursion_coordinates(Square(4, 4), 1, Square(4, 4), 0) == (5, 4)",
            "assert get_next_queen_recursion_coordinates(Square(4, 4), 0, Square(4, 4), 1) == (5, 5)"
        ]
    },
    {
        "func_name": "calc_num_weights3",
        "code": "\ndef calc_num_weights3(num_inputs, layer_sizes, num_outputs, m_trainable_arr, b_trainable_arr):\n    n = 0\n    if len(layer_sizes) == 0:\n        if m_trainable_arr and m_trainable_arr[0]:\n            n += num_inputs * num_outputs\n        if b_trainable_arr and b_trainable_arr[0]:\n            n += num_outputs\n        return n\n    if m_trainable_arr and m_trainable_arr[0]:\n        n += num_inputs * layer_sizes[0]\n    if b_trainable_arr and b_trainable_arr[0]:\n        n += layer_sizes[0]\n    for i in range(1, len(layer_sizes)):\n        if m_trainable_arr and i < len(m_trainable_arr) and m_trainable_arr[i]:\n            n += layer_sizes[i-1] * layer_sizes[i]\n        if b_trainable_arr and i < len(b_trainable_arr) and b_trainable_arr[i]:\n            n += layer_sizes[i]\n    if m_trainable_arr and m_trainable_arr[-1]:\n        n += layer_sizes[-1] * num_outputs\n    if b_trainable_arr and b_trainable_arr[-1]:\n        n += num_outputs\n    return n\n",
        "prompt": "accounts for fact that certain weight matrices / bias vectors may not be trainable",
        "task_id": "2395",
        "test_list": [
            "assert calc_num_weights3(3, [4, 4], 1, [True, True], [True]) == 32",
            "assert calc_num_weights3(3, [4, 5], 2, [True, True, True], [False, False]) == 26",
            "assert calc_num_weights3(3, [5], 2, [True], [True]) == 16",
            "assert calc_num_weights3(3, [4, 5], 2, [False, False, False], [False, False]) == 0",
            "assert calc_num_weights3(3, [4, 5], 2, [True, False, True], [True, False]) == 26"
        ]
    },
    {
        "func_name": "get_intersect_point",
        "code": "\ndef get_intersect_point(v1, v2, width, height):\n    x1, y1, x2, y2 = *v1, *v2\n    if x2 - x1 == 0:\n        k = None\n    else:\n        k = (y2 - y1) / (x2 - x1)\n    if k is not None:\n        b = y1 - k * x1\n        x_max, x_min = max(x1, x2), min(x1, x2)\n        y_max, y_min = max(y1, y2), min(y1, y2)\n\n        if b >= 0 and b <= y_max and b >= y_min:\n            return [0, round(b)]\n\n        y_right = width * k + b\n        if y_right >= 0 and y_right <= y_max and y_right >= y_min:\n            return [width, round(y_right)]\n\n        x_top = (-1) * b / k\n        if x_top >= 0 and x_top <= x_max and x_top >= x_min:\n            return [round(x_top), 0]\n\n        x_bot = (height - b) / k\n        if x_bot >= 0 and x_bot <= x_max and x_bot >= x_min:\n            return [round(x_bot), height]\n\n    return None\n",
        "prompt": "To deal with the outofframe polygons, we need to compute the intersection points of missing vertex and contained vertex to generate a new polygon to crop. This is a helper function to compute the intersect point of the line between two vertecies and all four edge lines.",
        "task_id": "2515",
        "test_list": [
            "assert get_intersect_point([0, 0, 1, 2], [0, 2, 2, 0], 1, 1) == [0, 1]",
            "assert get_intersect_point([0, 0, 1, 0], [0, 0, 0, 1], 1, 1) == None",
            "assert get_intersect_point([0, 0, 2, 2], [0, 2, 2, 0], 2, 2) == [1, 1]",
            "assert get_intersect_point([0, 0, 1, 1], [0, 1, 1, 0], 1, 1) == [0, 0]",
            "assert get_intersect_point([0, 0, 1, 0], [0, 1, 1, 1], 1, 1) == [0, 0]"
        ]
    },
    {
        "func_name": "check_dead_corner",
        "code": "def check_dead_corner(xanadu, other_objs):\n    # check whether the xanadu is at top right\n    is_dead = True\n    for other_obj in other_objs:\n        if xanadu[0] < other_obj[0] or xanadu[1] < other_obj[1]:\n            is_dead = False\n            break\n    if is_dead:\n        return True\n\n    # check whether the xanadu is at top left\n    is_dead = True\n    for other_obj in other_objs:\n        if xanadu[0] > other_obj[0] or xanadu[1] < other_obj[1]:\n            is_dead = False\n            break\n    if is_dead:\n        return True\n\n    # check whether the xanadu is at bottom right\n    is_dead = True\n    for other_obj in other_objs:\n        if xanadu[0] < other_obj[0] or xanadu[1] > other_obj[1]:\n            is_dead = False\n            break\n    if is_dead:\n        return True\n\n    # check whether the xanadu is at top right\n    is_dead = True\n    for other_obj in other_objs:\n        if xanadu[0] > other_obj[0] or xanadu[1] > other_obj[1]:\n            is_dead = False\n            break\n    if is_dead:\n        return True",
        "prompt": "Check whether the xanadu is position at the dead corner which it can never escape",
        "task_id": "2557",
        "test_list": [
            "assert check_dead_corner((0, 0), [(1, 1), (2, 2)]) == True",
            "assert check_dead_corner((1, 1), [(0, 0), (2, 2)]) == False",
            "assert check_dead_corner((2, 2), [(0, 0), (1, 1)]) == False",
            "assert check_dead_corner((0, 2), [(0, 1), (1, 1)]) == False",
            "assert check_dead_corner((1, 0), [(0, 0), (2, 2)]) == False"
        ]
    },
    {
        "func_name": "formatTime",
        "code": "def formatTime(time_diff: int):\n    if time_diff < 0:  # timeDiff should never be negative in this function\n        return \"ERROR: Negative timeDiff\"\n\n    response = [\"\", \"0 hours\", \"0 minutes\", \"0 seconds\"]  # Create an array of formatted times (DAYS HOURS MINUTES SECONDS)\n\n    # Convert from seconds into days, hours, minutes and seconds\n    m, s = divmod(time_diff, 60)\n    h, m = divmod(m, 60)\n    d, h = divmod(h, 24)\n\n    if d == 1: response[0] = \"1 day\"\n    elif d > 1: response[0] = \"{} days\".format(d)\n\n    if h == 1: response[1] = \"1 hour\"\n    elif h > 1: response[1] = \"{} hours\".format(h)\n\n    if m == 1: response[2] = \"1 minute\"\n    elif m > 1: response[2] = \"{} minutes\".format(m)\n\n    if s == 1: response[3] = \"1 second\"\n    elif s > 1: response[3] = \"{} seconds\".format(s)\n\n    return response",
        "prompt": "r\"\"\"Returns a formatted time diff",
        "task_id": "2733",
        "test_list": [
            "assert formatTime(86399) == ['0 days', '23 hours', '59 minutes', '59 seconds']",
            "assert formatTime(86461) == ['1 day', '0 hours', '1 minute', '1 second']",
            "assert formatTime(-1) == 'ERROR: Negative timeDiff'",
            "assert formatTime(3600) == ['0 days', '1 hour', '0 minutes', '0 seconds']",
            "assert formatTime(3661) == ['0 days', '1 hour', '1 minute', '1 second']"
        ]
    },
    {
        "func_name": "fileNamer",
        "code": "def fileNamer(node_model: str = None, dataset_name: str = None, model_name: str = None, l_inf: float = None,\n              l_0: float = None, num_layers: int = None,\n              seed: int = None, targeted: bool = None, continuous_epochs: int = None, patience: int = None,\n              start: str = None, end: str = None) -> str:\n\n    file_name = ''\n\n    if node_model is not None:\n        if node_model is True:\n            node_model = 'NodeModel'\n        else:\n            node_model = 'EdgeModel'\n    l_inf = 'Linf' + str(l_inf) if l_inf is not None else l_inf\n    l_0 = 'AttrRatio' + str(l_0) if l_0 is not None else l_0\n    num_layers = str(num_layers) + 'Layers' if num_layers is not None else num_layers\n    seed = 'Seed' + str(seed) if seed is not None else seed\n    if targeted is not None:\n        targeted_attack_str = ''\n        if not targeted:\n            targeted_attack_str += 'un'\n        targeted = targeted_attack_str + 'targeted'\n    continuous_epochs = str(continuous_epochs) + 'K' if continuous_epochs is not None else continuous_epochs\n    patience = 'patience' + str(patience) if patience is not None else patience\n\n    for input in [start, node_model, dataset_name, model_name, num_layers, seed, l_inf, l_0, targeted,\n                  continuous_epochs, patience]:\n        if input is not None:\n            file_name += '_' + input\n\n    if end is not None:\n        file_name += end\n    return file_name[1:]",
        "prompt": "creates the generic name of the output file",
        "task_id": "2798",
        "test_list": [
            "assert fileNamer(dataset_name='mnist', model_name='cnn', num_layers=3, seed=123, targeted=False, continuous_epochs=50, patience=5, start='val', end='best') == 'mnist_cnn_3LayersSeedLinfAttrRatiounK50patienceKvalbest'",
            "assert fileNamer(dataset_name='coco', model_name='inception', num_layers=18, seed=0, targeted=True, continuous_epochs=200, patience=None, start='train', end='epoch_5') == 'coco_inception_18LayersSeedLinftargetedK200patienceKtrainepoch_5'",
            "assert fileNamer(dataset_name='pascal', model_name='faster_rcnn', num_layers=4, seed=0, targeted=False, continuous_epochs=None, patience=15, start='train', end='epoch_20') == 'pascal_faster_rcnn_4LayersSeedLinfAttrRatioepocentenatpepoch_20'",
            "assert fileNamer(dataset_name='imagenet', model_name='vgg', num_layers=19, seed=0, targeted=False, continuous_epochs=None, patience=20, start='test', end='epoch_10') == 'imagenet_vgg_19LayersSeedLinfAttrRatioepocentestepoch_10'",
            "assert fileNamer(dataset_name='cifar10', model_name='resnet', num_layers=50, seed=42, targeted=True, continuous_epochs=100, patience=10, start='train', end='final') == 'cifar10_resnet_50LayersSeedLinfAttrRatiountargetedK100patienceKtrainfinal'"
        ]
    },
    {
        "func_name": "detect_side",
        "code": "def detect_side(start: dict, point: dict, degrees): \r\n    if start['lat'] < point['lat'] and start['lng'] < point['lng']:\r\n        return f'{degrees} degrees right' \r\n    elif start['lat'] < point['lat'] and start['lng'] > point['lng']:\r\n        return f'{degrees} degrees left' \r\n    elif start['lat'] > point['lat'] and start['lng'] < point['lng']:\r\n        return f'{degrees + 90} degrees right' \r\n    elif start['lat'] > point['lat'] and start['lng'] > point['lng']:\r\n        return f'{degrees + 90} degrees left' \r\n    elif degrees == 0: \r\n        return f'{0} degress' \r\n    elif degrees == 180: \r\n        return f'{180} degrees right' \r\n    elif start['lat'] == point['lat'] and start['lng'] < point['lng']:\r\n        return f'{degrees} degress right' \r\n    elif start['lat'] == point['lat'] and start['lng'] > point['lng']:\r\n        return f'{degrees} degress left'",
        "prompt": "detect to which side robot should rotate",
        "task_id": "2870",
        "test_list": [
            "assert detect_side({'lat': 45, 'lng': 45}, {'lat': 45, 'lng': 45}, 90) == '90 degrees right'",
            "assert detect_side({'lat': 60, 'lng': 60}, {'lat': 60, 'lng': 60}, 30) == '30 degrees right'",
            "assert detect_side({'lat': 30, 'lng': 30}, {'lat': 30, 'lng': 30}, 45) == '45 degrees right'",
            "assert detect_side({'lat': 10, 'lng': 10}, {'lat': 10, 'lng': 20}, 90) == '90 degrees right'",
            "assert detect_side({'lat': 75, 'lng': 75}, {'lat': 75, 'lng': 75}, 15) == '15 degrees right'"
        ]
    },
    {
        "func_name": "circle_line_intersection",
        "code": "def circle_line_intersection(circle_center, circle_radius, pt1, pt2, full_line=True, tangent_tol=1e-9):\n\n    (p1x, p1y), (p2x, p2y), (cx, cy) = pt1, pt2, circle_center\n    (x1, y1), (x2, y2) = (p1x - cx, p1y - cy), (p2x - cx, p2y - cy)\n    dx, dy = (x2 - x1), (y2 - y1)\n    dr = (dx ** 2 + dy ** 2)**.5\n    big_d = x1 * y2 - x2 * y1\n    discriminant = circle_radius ** 2 * dr ** 2 - big_d ** 2\n\n    if discriminant < 0:  # No intersection between circle and line\n        return []\n    else:  # There may be 0, 1, or 2 intersections with the segment\n        intersections = [\n            (cx + (big_d * dy + sign * (-1 if dy < 0 else 1) * dx * discriminant**.5) / dr ** 2,\n             cy + (-big_d * dx + sign * abs(dy) * discriminant**.5) / dr ** 2)\n            for sign in ((1, -1) if dy < 0 else (-1, 1))]  # This makes sure the order along the segment is correct\n        # If only considering the segment, filter out intersections that do not fall within the segment\n        if not full_line:\n            fraction_along_segment = [(xi - p1x) / dx if abs(dx) > abs(dy) else (yi - p1y) / dy for xi, yi in intersections]\n            intersections = [pt for pt, frac in zip(intersections, fraction_along_segment) if 0 <= frac <= 1]\n        # If line is tangent to circle, return just one point (as both intersections have same location)\n        if len(intersections) == 2 and abs(discriminant) <= tangent_tol:\n            return [intersections[0]]\n        else:\n            return intersections",
        "prompt": "Find the points at which a circle intersects a linesegment. This can happen at 0, 1, or 2 points.",
        "task_id": "2938",
        "test_list": [
            "assert circle_line_intersection((0, 0), 5, (3, 4), (4, 3)) == [(3, 4), (4, 3)]",
            "assert circle_line_intersection((0, 0), 5, (0, -7), (0, 7)) == [(0, -5), (0, 5)]",
            "assert circle_line_intersection((0, 0), 5, (1, 1), (1, -1)) == [(1, 0)]",
            "assert circle_line_intersection((0, 0), 5, (-5, 0), (5, 0)) == [(-5, 0), (5, 0)]",
            "assert circle_line_intersection((0, 0), 5, (0, -6), (0, 6)) == [(0, -5), (0, 5)]"
        ]
    },
    {
        "func_name": "fire_gun",
        "code": "\ndef fire_gun(x, y, xvel, yvel, time_passed_seconds, player):\n    HEIGHT = 800\n    WIDTH = 600\n    hit = False\n    obstacle = False\n    # position = velocity times time\n    distance_moved_x = (time_passed_seconds * xvel)\n    distance_moved_y = (time_passed_seconds * yvel)\n    x += distance_moved_x\n    y += distance_moved_y\n    # if the ball hits a wall or the ground, it's not in the air\n    if y > HEIGHT - 5 or x > WIDTH or x < 0:\n        inair = False\n    else:\n        inair = True\n    # if player one hits player two, hit is true\n    if player == 1:\n        if x > WIDTH - 80 and x < WIDTH and y > HEIGHT - 80 and y < HEIGHT:\n            hit = True\n    if player == 2:\n        if x > 0 and x < 80 and y > HEIGHT - 80 and y < HEIGHT:\n            hit = True\n    if x > (WIDTH / 2) - 100 and y > HEIGHT - 200 and x < (WIDTH / 2) + 100:\n        obstacle = True\n        inair = False\n    return (int(x), int(y), inair, hit, obstacle)\n",
        "prompt": "Fires the cannon. Returns a posistion, whether or not there is a hit, and whether the projectile is in the air",
        "task_id": "2964",
        "test_list": [
            "assert fire_gun(0, 0, 100, 100, 1, 2) == (100, 100, True, True, False)",
            "assert fire_gun(0, 0, 100, 100, 10, 2) == (1000, 1000, False, False, True)",
            "assert fire_gun(0, 0, 100, 100, 10, 1) == (1000, 1000, False, True, False)",
            "assert fire_gun(0, 0, 100, 100, 1, 1) == (100, 100, True, False, False)",
            "assert fire_gun(0, 0, 100, 100, 5, 1) == (500, 500, False, False, False)"
        ]
    },
    {
        "func_name": "rollDie",
        "code": "\nimport random\n\nRED = 'red'\nYELLOW = 'yellow'\nGREEN = 'green'\nCOLOR = 'color'\nICON = 'icon'\nSHOTGUN = 'shotgun'\nFOOTSTEPS = 'footsteps'\nBRAINS = 'brains'\n\ndef rollDie(die):\n    roll = random.randint(1, 6)\n    if die == RED:\n        if roll in (1, 2, 3):\n            return {COLOR: RED, ICON: SHOTGUN}\n        elif roll in (4, 5):\n            return {COLOR: RED, ICON: FOOTSTEPS}\n        elif roll in (6,):\n            return {COLOR: RED, ICON: BRAINS}\n    elif die == YELLOW:\n        if roll in (1, 2):\n            return {COLOR: YELLOW, ICON: SHOTGUN}\n        elif roll in (3, 4):\n            return {COLOR: YELLOW, ICON: FOOTSTEPS}\n        elif roll in (5, 6):\n            return {COLOR: YELLOW, ICON: BRAINS}\n    elif die == GREEN:\n        if roll in (1,):\n            return {COLOR: GREEN, ICON: SHOTGUN}\n        elif roll in (2, 3):\n            return {COLOR: GREEN, ICON: FOOTSTEPS}\n        elif roll in (4, 5, 6):\n            return {COLOR: GREEN, ICON: BRAINS}\n",
        "prompt": "Returns the result of a single die roll as a dictionary with keys 'color' and 'icon'. The die parameter is a string of the color of the die (i.e. 'green', 'yellow', 'red'). The 'color' values in the return dict are one of 'green', 'yellow', 'red'. The 'icon' values are one of 'shotgun', 'footsteps', 'brains'.",
        "task_id": "2970",
        "test_list": [
            "assert rollDie('yellow') == {'color': 'yellow', 'icon': 'footsteps'}",
            "assert rollDie('red') == {'color': 'red', 'icon': 'footsteps'}",
            "assert rollDie('yellow') == {'color': 'yellow', 'icon': 'shotgun'}",
            "assert rollDie('red') == {'color': 'red', 'icon': 'shotgun'}",
            "assert rollDie('green') == {'color': 'green', 'icon': 'shotgun'}"
        ]
    },
    {
        "func_name": "idx_for_diag_se_from_tr",
        "code": "def idx_for_diag_se_from_tr(num_rows=2, num_cols=3):\n\n    if num_rows <= num_cols:\n        \n        # upper right triangle\n        for col in range(num_cols, num_cols-num_rows, -1):\n            row = 0\n            while col < num_cols:\n                yield row, col\n                row += 1\n                col += 1\n\n        # middle diagonals\n        for col in range(num_cols-num_rows, -1, -1):\n            row = 0\n            while row < num_rows:\n                yield row, col\n                row += 1\n                col += 1\n\n        # lower left triangle\n        for row in range(1, num_rows):\n            col = 0\n            while row < num_rows:\n                yield row, col\n                row += 1\n                col += 1\n                \n    else:\n                        \n        # upper right triangle\n        for col in range(num_cols-1, 0, -1):\n            row = 0\n            while col < num_cols:\n                yield row, col\n                row += 1\n                col += 1\n                \n        # middle diagonals\n        for row in range(num_rows-num_cols+1):\n            col = 0\n            while col < num_cols:\n                yield row, col\n                row += 1\n                col += 1\n                \n        # lower left triangle\n        for row in range(num_rows-num_cols+1, num_rows):\n            col = 0\n            while row < num_rows:\n                yield row, col\n                row += 1\n                col += 1",
        "prompt": "Traverse southeast diagonals from top right This is the most important variant Eg. 0 1 2 \\\\ \\\\ \\\\ 1 ['A', 'B', 'C'] \\\\ \\\\ \\\\ ['D', 'E', 'F']",
        "task_id": "3136",
        "test_list": [
            "assert list(idx_for_diag_se_from_tr(4, 1)) == [(0, 0), (1, 0), (2, 0), (3, 0)]",
            "assert list(idx_for_diag_se_from_tr(3, 2)) == [(0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]",
            "assert list(idx_for_diag_se_from_tr(2, 3)) == [(0, 2), (1, 1), (1, 0), (1, 2), (0, 1), (0, 0)]",
            "assert list(idx_for_diag_se_from_tr(3, 3)) == [(0, 2), (1, 1), (1, 0), (2, 0), (2, 1), (2, 2), (1, 2), (0, 1), (0, 0)]",
            "assert list(idx_for_diag_se_from_tr(1, 4)) == [(0, 3), (0, 2), (0, 1), (0, 0)]"
        ]
    },
    {
        "func_name": "idx_for_diag_se_from_bl",
        "code": "def idx_for_diag_se_from_bl(num_rows=2, num_cols=3):\n\n    if num_rows <= num_cols:\n        \n        # lower left triangle\n        for row in range(num_rows-1, 0, -1):\n            col = 0\n            while row < num_rows:\n                yield row, col\n                row += 1\n                col += 1\n                \n        # middle diagonals\n        for col in range(0, num_cols-num_rows+1):\n            row = 0\n            while row < num_rows:\n                yield row, col\n                row += 1\n                col += 1\n                \n        # upper right triangle\n        for col in range(num_cols-num_rows+1, num_cols):\n            row = 0\n            while col < num_cols:\n                yield row, col\n                row += 1\n                col += 1\n\n    else:\n    \n        # lower left triangle\n        for row in range(num_rows-1, num_rows-num_cols, -1):\n            col = 0\n            while row < num_rows:\n                yield row, col\n                row += 1\n                col += 1\n                \n        # middle diagonals\n        for row in range(num_rows-num_cols, -1, -1):\n            col = 0\n            while col < num_cols:\n                yield row, col\n                row += 1\n                col += 1\n                \n        # upper right triangle\n        for col in range(1, num_cols):\n            row = 0\n            while col < num_cols:\n                yield row, col\n                row += 1\n                col += 1",
        "prompt": "Traverse southeast diagonals from bottom left This is the second most important variant Eg. 0 1 2 \\\\ \\\\ \\\\ 1 ['A', 'B', 'C'] \\\\ \\\\ \\\\ ['D', 'E', 'F']",
        "task_id": "3137",
        "test_list": [
            "assert list(idx_for_diag_se_from_bl(5, 1)) == [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)]",
            "assert list(idx_for_diag_se_from_bl(2, 3)) == [(0, 0), (1, 0), (1, 1), (0, 1), (0, 2), (1, 2)]",
            "assert list(idx_for_diag_se_from_bl(3, 2)) == [(0, 0), (1, 0), (1, 1), (2, 1), (2, 0)]",
            "assert list(idx_for_diag_se_from_bl(1, 5)) == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)]",
            "assert list(idx_for_diag_se_from_bl(3, 3)) == [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2), (1, 2), (0, 2), (0, 1)]"
        ]
    },
    {
        "func_name": "remove_chars",
        "code": "def remove_chars(line, chars = ' \\t', quotes = '\\'\\\"', comments = None):\n    new_line = ''\n    quote_stack = ''\n    remove_comments = (type(comments) is list) or (type(comments) is str)\n\n    for c in line:\n\n        if remove_comments and len(quote_stack) == 0 and c in comments:\n            break\n\n        if len(quote_stack) == 0 and c in chars:\n            continue\n\n        if c in quotes:\n            if len(quote_stack) == 0 or c != quote_stack[-1]:\n                quote_stack += c\n            elif len(quote_stack) != 0:\n                quote_stack = quote_stack[:-1]\n\n            continue\n\n        new_line += c\n\n    return new_line",
        "prompt": "Removes all specified characters but leaves quotes intact. Removes comments if comment character is specified.",
        "task_id": "3237",
        "test_list": [
            "assert remove_chars(\"Hello, 'World' 'and' Universe!\", chars=' ,') == \"Hello'World' 'and' Universe!\"",
            "assert remove_chars('Hello, World!', chars=' ,') == 'HelloWorld!'",
            "assert remove_chars(\"Hello, 'World'!\", chars=' ,') == \"Hello'World'!\"",
            "assert remove_chars('Hello, World! How are you?', chars=' ,!?', quotes='\\'\"') == \"Hello'World' How are you?\"",
            "assert remove_chars('Hello, World!', chars=' ,', comments='World') == 'Hello, !'"
        ]
    },
    {
        "func_name": "cigar_prefix_length",
        "code": "def cigar_prefix_length(cigar, reference_bases):\n\t\tref_pos = 0\n\t\tquery_pos = 0\n\t\tfor op, length in cigar:\n\t\t\tif op in (0, 7, 8):  # M, X, =\n\t\t\t\tref_pos += length\n\t\t\t\tquery_pos += length\n\t\t\t\tif ref_pos >= reference_bases:\n\t\t\t\t\treturn (reference_bases, query_pos + reference_bases - ref_pos)\n\t\t\telif op == 2:  # D\n\t\t\t\tref_pos += length\n\t\t\t\tif ref_pos >= reference_bases:\n\t\t\t\t\treturn (reference_bases, query_pos)\n\t\t\telif op == 1:  # I\n\t\t\t\tquery_pos += length\n\t\t\telif op == 4 or op == 5:  # soft or hard clipping\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\t# TODO it should be possible to handle the N operator (ref. skip)\n\t\t\t\tassert False\n\t\tassert ref_pos < reference_bases\n\t\treturn (ref_pos, query_pos)",
        "prompt": "Given a prefix of length reference_bases relative to the reference, how",
        "task_id": "3357",
        "test_list": [
            "assert cigar_prefix_length([(2, 5), (1, 10)], 15) == (15, 10)",
            "assert cigar_prefix_length([(4, 3), (1, 7), (0, 5)], 10) == (10, 7)",
            "assert cigar_prefix_length([(0, 10), (1, 5)], 15) == (15, 15)",
            "assert cigar_prefix_length([(1, 5), (1, 5), (1, 5)], 15) == (15, 15)",
            "assert cigar_prefix_length([(0, 5), (0, 5), (0, 5), (0, 5)], 20) == (20, 20)"
        ]
    },
    {
        "func_name": "get_segment_directions",
        "code": "def get_segment_directions(x, y, segment_size, matrix_dimensions):\n    if x < 0 or y < 0 or x > matrix_dimensions[0] or y > matrix_dimensions[1]:\n        raise Exception(\"The point (%d, %d) doesn't belong into the matrix\" %\n            (x, y))\n\n    distance = segment_size - 1\n    directions = []\n\n    if x - distance >= 0 and y - distance >= 0:\n        directions += ['NW']\n\n    if x - distance >= 0:\n        directions += ['N']\n\n    if x - distance >= 0 and y + distance < matrix_dimensions[1]:\n        directions += ['NE']\n\n    if y - distance >= 0:\n        directions += ['W']\n\n    if y + distance < matrix_dimensions[1]:\n        directions += ['E']\n\n    if x + distance < matrix_dimensions[0] and y - distance >= 0:\n        directions += ['SW']\n\n    if x + distance < matrix_dimensions[0]:\n        directions += ['S']\n\n    if (x + distance < matrix_dimensions[0] and\n        y + distance < matrix_dimensions[1]):\n        directions += ['SE']\n\n    return directions",
        "prompt": "For a given point in the matrix (x,y), returns the directions where there is a segment of a given size.",
        "task_id": "3563",
        "test_list": [
            "assert get_segment_directions(0, 0, 3, (10, 10)) == ['NW', 'N', 'NE', 'E', 'SE', 'S', 'SW', 'W']",
            "assert get_segment_directions(5, 5, 3, (10, 10)) == ['NW', 'N', 'NE', 'W', 'E', 'SW', 'S', 'SE']",
            "assert get_segment_directions(5, 5, 1, (10, 10)) == ['N', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N']",
            "assert get_segment_directions(0, 0, 1, (10, 10)) == ['N', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N']",
            "assert get_segment_directions(9, 9, 3, (10, 10)) == ['NW', 'N', 'NE', 'E', 'SE', 'S', 'SW', 'W']"
        ]
    },
    {
        "func_name": "max2GetIdx",
        "code": "def max2GetIdx(A, lo, hi):\n    if hi-lo == 1:\n        raise IndexError(\"Array size too small: (lo=%d, hi=%d)\" % (lo, hi))\n    elif hi-lo == 2:\n        x1, x2 = lo, lo+1\n        if A[x2] > A[x1]:\n            x1, x2 = x2, x1\n        return x1, x2\n    elif hi-lo == 3:\n        x1, x2 = lo, lo+1\n        if A[lo+2] > A[x1]:\n            x2 = x1\n            x1 = lo+2\n        elif A[lo+2] > A[x2]:  # A[x2] < A[lo+2] <= A[x1]\n            x2 = lo+2\n        return x1, x2\n\n    mi = (lo+hi) >> 1\n    lx1, lx2 = max2GetIdx(A, lo, mi)\n    rx1, rx2 = max2GetIdx(A, mi, hi)\n    if A[lx1] > A[rx1]:\n        x1 = lx1\n        if A[lx2] > A[rx1]:\n            x2 = lx2\n        else:\n            x2 = rx1\n    else:  # rx1 > lx1\n        x1 = rx1\n        if A[rx2] > A[lx1]:\n            x2 = rx2\n        else:\n            x2 = lx1\n    return x1, x2",
        "prompt": "Helper function for divide and conqure approach in 01E09 1st example Improved impl based on max2GetIdxVer1 T(n) = 2T(n/2) + 2",
        "task_id": "3569",
        "test_list": [
            "assert max2GetIdx([5, 4, 3, 2, 1], 0, 4) == (0, 1)",
            "assert max2GetIdx([1, 3, 2, 5, 4], 1, 4) == (3, 4)",
            "assert max2GetIdx([1, 3, 2, 5, 4], 0, 1) == (1, 1)",
            "assert max2GetIdx([1, 2, 3, 4, 5], 0, 4) == (4, 4)",
            "assert max2GetIdx([1, 3, 2, 5, 4], 0, 4) == (3, 4)"
        ]
    },
    {
        "func_name": "getYAxisMinMaxGC",
        "code": "def getYAxisMinMaxGC(LGC,RGC):\n\tTotGCTT1=max(LGC) \n\tTotGCTT2 = max(RGC)\n\tif TotGCTT1 > TotGCTT2:\n\t\tylimMaxGC=TotGCTT1\n\telse :\n\t\tylimMaxGC = TotGCTT2\n\tTotMinGCTT1 = min(LGC)\n\tTotMinGCTT2 = min(RGC)\n\tif TotMinGCTT1 < TotMinGCTT2:\n\t\tylimMinGC = TotMinGCTT1\n\telse : \n\t\tylimMinGC = TotMinGCTT2\n\n\tif 0<ylimMaxGC<50:\n\t\tylimMaxGC = 50\n\telif 50<ylimMaxGC<100:\n\t\tylimMaxGC = 100\n\telif 100<ylimMaxGC<150:\n\t\tylimMaxGC = 150\n\telif 150<ylimMaxGC<200:\n\t\tylimMaxGC = 200\n\telif 200<ylimMaxGC<250:\n\t\tylimMaxGC = 250\n\telif 250<ylimMaxGC<300:\n\t\tylimMaxGC = 300\n\telif 300<ylimMaxGC<350:\n\t\tylimMaxGC = 350\n\telif 350<ylimMaxGC<400:\n\t\tylimMaxGC = 400\n\telif 400<ylimMaxGC<450:\n\t\tylimMaxGC = 450\n\n\tif -100<ylimMinGC<-50:\n\t\tylimMinGC = -100\n\telif -50<ylimMinGC<0:\n\t\tylimMinGC = -50\n\telse : \n\t\tylimMinGC = 0\n\n\treturn ylimMinGC, ylimMaxGC",
        "prompt": "This function returns the max and min of the fluorescence DR/R100 y axis.",
        "task_id": "3621",
        "test_list": [
            "assert getYAxisMinMaxGC([10, 20, 30, 40, 500], [5, 15, 25, 35, 450]) == (5, 500)",
            "assert getYAxisMinMaxGC([10, 20, 30, 40, 500, 600], [5, 15, 25, 35, 450, 550]) == (5, 600)",
            "assert getYAxisMinMaxGC([10, 20, 30, 40, 500, 600, 700], [5, 15, 25, 35, 450, 550, 650]) == (5, 700)",
            "assert getYAxisMinMaxGC([10, 20, 30, 40], [5, 15, 25, 35]) == (5, 40)",
            "assert getYAxisMinMaxGC([10, 20, 30], [5, 15, 25]) == (-50, 50)"
        ]
    },
    {
        "func_name": "calculate_possibility",
        "code": "def calculate_possibility(ind1, ind2, angle1):\n    if ind1[0] == 0 and ind2[0] == 0:\n        if ind1[2] <= ind2[2]:\n            #priority for boundaries more at the right as it is a top border\n            if angle1 > 0:\n                #if angle is bigger than zero, we give priority to upper boundary\n                if ind2[1] <= ind1[1]:\n                    return 1\n                else:\n                    return 0.4\n\n            elif angle1 < 0:\n                # if angle is smaller than zero, we give priority to bottom boundary\n                if ind2[1] >= ind1[1]:\n                    return 1\n                else:\n                    return 0.4\n\n            else:\n                #when angle is zero, there's no priority\n                return 1\n        else:\n            return 0.01\n\n    elif ind1[0] == 1 and ind2[0] == 1:\n        if ind1[2] >= ind2[2]:\n            #priority for boundaries more at the left as it is a bottom border\n            if angle1 > 0:\n                #if angle is bigger than zero, we give priority to bottom boundary\n                if ind2[1] >= ind1[1]:\n                    return 1\n                else:\n                    return 0.4\n\n            elif angle1 < 0:\n                # if angle is smaller than zero, we give priority to upper boundary\n                if ind2[1] <= ind1[1]:\n                    return 1\n                else:\n                    return 0.4\n\n            else:\n                # when angle is zero, there's no priority\n                return 1\n\n        else:\n            return 0.01\n\n    elif ind1[0] == 2 and ind2[0] == 2:\n        if ind1[1] >= ind2[1]:\n            #priority for boundaries more at the top (smaller in y) as it is a left border\n            if angle1 > 0:\n                #if angle is bigger than zero, we give priority to more right boundaries\n                if ind2[2] >= ind1[2]:\n                    return 1\n                else:\n                    return 0.4\n\n            else:\n                # if angle is smaller than zero, we give priority to more leff boundaries\n                if ind2[2] <= ind1[2]:\n                    return 1\n                else:\n                    return 0.4\n\n        else:\n            return 0.01\n\n    elif ind1[0] == 3 and ind2[0] == 3:\n        if ind1[1] <= ind2[1]:\n            # priority for boundaries more at the bottom (higher in y) as it is a right border\n            if angle1 > 0:\n                # if angle is bigger than zero, we give priority to more left boundaries\n                if ind2[2] <= ind1[2]:\n                    return 1\n                else:\n                    return 0.4\n\n            else:\n                # if angle is smaller than zero, we give priority to more right boundaries\n                if ind2[2] >= ind1[2]:\n                    return 1\n                else:\n                    return 0.4\n\n        else:\n            return 0.01\n    else:\n        return 1",
        "prompt": "This method is use to fine tune the cases of same boundaries",
        "task_id": "3690",
        "test_list": [
            "assert calculate_possibility((3, 3, 5), (3, 3, 3), 0) == 1",
            "assert calculate_possibility((0, 1, 5), (0, 1, 3), 0) == 1",
            "assert calculate_possibility((0, 0, 5), (0, 0, 3), 0) == 1",
            "assert calculate_possibility((2, 2, 5), (2, 2, 3), 0) == 1",
            "assert calculate_possibility((1, 1, 5), (1, 1, 3), 0) == 1"
        ]
    },
    {
        "func_name": "iterative_levenshtein",
        "code": "def iterative_levenshtein(s, t, costs=(1, 1, 1)):\n\n    rows = len(s) + 1\n    cols = len(t) + 1\n    deletes, inserts, substitutes = costs\n\n    dist = [[0 for x in range(cols)] for x in range(rows)]\n    H, D, S, I = 0, 0, 0, 0\n    for row in range(1, rows):\n        dist[row][0] = row * deletes\n    for col in range(1, cols):\n        dist[0][col] = col * inserts\n\n    for col in range(1, cols):\n        for row in range(1, rows):\n            if s[row - 1] == t[col - 1]:\n                cost = 0\n            else:\n                cost = substitutes\n            dist[row][col] = min(dist[row - 1][col] + deletes,\n                                 dist[row][col - 1] + inserts,\n                                 dist[row - 1][col - 1] + cost)\n    row, col = rows - 1, cols - 1\n    while row != 0 or col != 0:\n        if row == 0:\n            I += col\n            col = 0\n        elif col == 0:\n            D += row\n            row = 0\n        elif dist[row][col] == dist[row - 1][col] + deletes:\n            D += 1\n            row = row - 1\n        elif dist[row][col] == dist[row][col - 1] + inserts:\n            I += 1\n            col = col - 1\n        elif dist[row][col] == dist[row - 1][col - 1] + substitutes:\n            S += 1\n            row, col = row - 1, col - 1\n        else:\n            H += 1\n            row, col = row - 1, col - 1\n    D, I = I, D\n    return H, D, S, I",
        "prompt": "Computes Levenshtein distance between the strings s and t. For all i and j, dist[i,j] will contain the Levenshtein distance between the first i characters of s and the first j characters of t",
        "task_id": "3850",
        "test_list": [
            "assert iterative_levenshtein('intention', 'execution') == (5, 5, 0, 5)",
            "assert iterative_levenshtein('abcdef', 'azced') == (3, 3, 3, 3)",
            "assert iterative_levenshtein('kitten', 'sitting') == (3, 3, 2, 3)",
            "assert iterative_levenshtein('hello', 'hello') == (0, 0, 0, 0)",
            "assert iterative_levenshtein('flaw', 'lawn') == (2, 2, 1, 2)"
        ]
    },
    {
        "func_name": "centre_on_peak",
        "code": "def centre_on_peak(data):\r\n    # Error handling\r\n    if data is None or len(data) == 0:\r\n        return []\r\n\r\n    # First we need a minimum value to compare against.\r\n    max_value_found = sys.float_info.min\r\n    #index to find the location of the peak, and items for the size of the list\r\n    index_of_max_value = -1\r\n    items = int(len(data))\r\n    \"\"\"Update the index and the max value variables if the next value in the \r\n       array is larger, or equal to the max value found\"\"\"\r\n    for i in range(0,items):\r\n        if data[i]>= max_value_found:\r\n            max_value_found = data[i]\r\n            index_of_max_value = i\r\n            \r\n    \"\"\"finding shifts needed to get the highest value in the centre\"\"\"\r\n     \r\n     # Check if the data is even\r\n    if  items  % 2 == 0:\r\n        #items is a float number, must be turned to integer first\r\n        midpoint = int((items - 1) / 2) \r\n    else:\r\n        midpoint = int(items / 2)\r\n        \r\n    #Counting the left shifts needed to centre the data.\r\n    shift = 0\r\n    # Updating the numbers of shifts based on the index of the max value.\r\n    if index_of_max_value < midpoint:\r\n        shift = (midpoint+index_of_max_value) + 1\r\n    elif index_of_max_value == midpoint:\r\n        return data # No need to shift, max value already in the middle.\r\n    else:\r\n        shift = index_of_max_value - midpoint\r\n          \r\n    \"\"\"shifting the data\"\"\"\r\n    for i in range(shift):\r\n        #temporarily store the data on first position\r\n        temp = data[0]\r\n        #do the shift, every item will move one to the left\r\n        for i in range(items-1):\r\n            data[i] = data[i + 1] \r\n        #item on the first position gets stored now on the last position\r\n        data[items-1] = temp\r\n    #Plotting data to test if it is getting properly centered, (commented out)    \r\n    #plt.plot(data)\r\n    #plt.show()\r\n    return data",
        "prompt": "Centres a number array",
        "task_id": "3934",
        "test_list": [
            "assert centre_on_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) == [17, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]",
            "assert centre_on_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) == [19, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]",
            "assert centre_on_peak([1, 2, 3, 4, 5]) == [5, 1, 2, 3, 4]",
            "assert centre_on_peak([5, 1, 2, 3, 4]) == [5, 1, 2, 3, 4]",
            "assert centre_on_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == [15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]"
        ]
    },
    {
        "func_name": "locate_alignment",
        "code": "\ndef locate_alignment(Qseq, Sseq, Qstart, resMatch=False):\n    if resMatch:\n        matchPos = [i for i, ch in enumerate(Qseq) if i < len(Sseq) and (ch != '-') and (Sseq[i] == ch)]\n    else:\n        matchPos = [i for i, ch in enumerate(Qseq) if i < len(Sseq) and (ch != '-') and (Sseq[i] != '-')]\n    gapPos = [i for i, ch in enumerate(Qseq) if i < len(Sseq) and ch == '-']\n    if len(gapPos) == 0:\n        return [pos + Qstart for pos in matchPos]\n    else:\n        numGaps = [len([g for g in gapPos if g < pos]) for pos in matchPos]\n        return [pos + Qstart - gaps for pos, gaps in zip(matchPos, numGaps)]\n",
        "prompt": "Transform single sequence alignment to positions on query sequence.",
        "task_id": "4032",
        "test_list": [
            "assert locate_alignment('ACGT', 'AC-T', 0) == [0, 1]",
            "assert locate_alignment('ACGTACGT', 'AC-T', 0) == [0, 1, 2, 3, 4, 5, 6]",
            "assert locate_alignment('ACGT', 'ACGT', 0, True) == [0, 1, 2, 3]",
            "assert locate_alignment('A-CGT', 'AC-T', 0, False) == [0, 1, 2]",
            "assert locate_alignment('A-CGT', 'AC-T', 0) == [0, 1, 2]"
        ]
    },
    {
        "func_name": "smooth_param",
        "code": "def smooth_param(x,sm_degree):\r\n    lx = len(x)\r\n    if lx < 150:\r\n        lx = lx + (150 - lx)\r\n    if sm_degree == 'very_rough':\r\n        win = round(lx/180)\r\n        if win%2 == 0:\r\n            win = win+1\r\n        polyorder = 6\r\n        deriv = 0\r\n        delta = 0\r\n        last = 'interp'\r\n    if sm_degree == 'rough':\r\n        win = round(lx/90)\r\n        if win%2 == 0:\r\n            win = win+1\r\n        polyorder = 5\r\n        deriv = 0\r\n        delta = 0\r\n        last = 'interp'\r\n    elif sm_degree == 'middle':\r\n        win = round(lx/40)\r\n        if win%2 == 0:\r\n            win= win+1\r\n        polyorder = 3\r\n        deriv = 0\r\n        delta = 0\r\n        last = 'interp'\r\n    elif sm_degree == 'fine':\r\n        win = round(lx/15)\r\n        if win%2 == 0:\r\n            win=win+1\r\n        polyorder = 2\r\n        deriv = 0\r\n        delta = 0\r\n        last = 'interp'\r\n    elif sm_degree == 'very_fine':\r\n        win = round(lx/6)\r\n        if win%2 == 0:\r\n            win=win+1\r\n        polyorder = 1\r\n        deriv = 0\r\n        delta = 0\r\n        last = 'interp'\r\n    return [win, polyorder, deriv, delta, last]",
        "prompt": "degree of smoothin can be 'rough', 'middle', or 'fine'.",
        "task_id": "4108",
        "test_list": [
            "assert smooth_param([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 'rough') == [11, 5, 0, 0, 'interp']",
            "assert smooth_param([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 'very_fine') == [2, 1, 0, 0, 'interp']",
            "assert smooth_param([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30], 'fine') == [16, 2, 0, 0, 'interp']",
            "assert smooth_param([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 'very_rough') == [9, 6, 0, 0, 'interp']",
            "assert smooth_param([1, 2, 3, 4, 5], 'middle') == [3, 3, 0, 0, 'interp']"
        ]
    },
    {
        "func_name": "look_up_latest_epoch",
        "code": "def look_up_latest_epoch(autoencoder_stage, epoch, encoder_epoch, model_folder, modeltag, class_type, encoder_version):\n    if autoencoder_stage==0 and epoch==-1:\n        epoch=0\n        while True:\n            if os.path.isfile(model_folder + \"trained_\" + modeltag + \"_autoencoder_epoch\" + str(epoch+1) + '.h5')==True:\n                epoch+=1\n            else:\n                break\n    elif autoencoder_stage==1 and encoder_epoch == -1:\n        encoder_epoch=0\n        while True:\n            if os.path.isfile(model_folder + \"trained_\" + modeltag + \"_autoencoder_epoch\" + str(epoch) +  \"_supervised_\" + class_type[1] + encoder_version + '_epoch' + str(encoder_epoch+1) + '.h5')==True:\n                encoder_epoch+=1\n            else:\n                break\n    elif autoencoder_stage==2 and encoder_epoch == -1:\n        encoder_epoch=0\n        while True:\n            if os.path.isfile(model_folder + \"trained_\" + modeltag + \"_supervised_\" + class_type[1] + encoder_version + '_epoch' + str(encoder_epoch+1) + '.h5')==True:\n                encoder_epoch+=1\n            else:\n                break\n    elif autoencoder_stage==3 and encoder_epoch == -1:\n        encoder_epoch=0\n        while True:\n            if os.path.isfile(model_folder + \"trained_\" + modeltag + \"_autoencoder_supervised_parallel_\" + class_type[1] + encoder_version + '_epoch' + str(encoder_epoch+1) + '.h5')==True:\n                encoder_epoch+=1\n            else:\n                break\n    return epoch, encoder_epoch",
        "prompt": "Automatically look up the epoch of the most recent saved model",
        "task_id": "4164",
        "test_list": [
            "assert look_up_latest_epoch(2, 0, 0, 'test_folder', 'testtag', ('class', 'type'), 'v1') == (0, 0)",
            "assert look_up_latest_epoch(1, 0, 0, 'test_folder', 'testtag', ('class', 'type'), 'v1') == (1, 1)",
            "assert look_up_latest_epoch(0, -1, 0, 'test_folder', 'testtag', ('class', 'type'), 'v1') == (0, 0)",
            "assert look_up_latest_epoch(1, 0, 0, 'test_folder', 'testtag', ('class', 'type'), 'v1') == (0, 1)",
            "assert look_up_latest_epoch(3, 0, 0, 'test_folder', 'testtag', ('class', 'type'), 'v1') == (0, 0)"
        ]
    },
    {
        "func_name": "find_adjacent_product",
        "code": "def find_adjacent_product(N: int, data: list) -> int:\r\n    # Define array limits and initial product value\r\n    rows = len(data)\r\n    columns = len(data[0])\r\n    max_product = -1\r\n\r\n    for row in range(rows):\r\n        for col in range(columns):\r\n            # Define flags about possible directions for specific element\r\n            up_flag = (row-N > 0)\r\n            down_flag = (row+N < rows+1)\r\n            left_flag = (col-N > 0)\r\n            right_flag = (col+N < columns+1)\r\n\r\n            # Define possible routes (cross)\r\n            dx, dy = 0, 0\r\n            if up_flag:\r\n                dx, dy = -1, 0\r\n            if down_flag:\r\n                dx, dy = 1, 0\r\n            if left_flag:\r\n                dx, dy = 0, -1\r\n            if right_flag:\r\n                dx, dy = 0, 1\r\n\r\n            # Define possible routes (diagonal)\r\n            if (down_flag and right_flag):\r\n                dx, dy = 1, 1\r\n            if (up_flag and left_flag):\r\n                dx, dy = -1, -1\r\n            if (up_flag and right_flag):\r\n                dx, dy = -1, 1\r\n            if (down_flag and left_flag):\r\n                dx, dy = 1, -1\r\n\r\n            # Compute the adjacent product and compare it with maximum\r\n            product = 1\r\n            for i in range(N):\r\n                idx_x = row + i*dx\r\n                idx_y = col + i*dy\r\n                product *= data[idx_x][idx_y]\r\n\r\n            max_product = max(product, max_product)\r\n\r\n    return max_product",
        "prompt": "Finds the greatest product of N adjacent numbers in the same direction (up, down, left, right, or diagonally)",
        "task_id": "4190",
        "test_list": [
            "assert find_adjacent_product(2, [[5, 1, 2, 3], [6, 7, 8, 9], [4, 5, 6, 7], [1, 2, 3, 4]]) == 504",
            "assert find_adjacent_product(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 504",
            "assert find_adjacent_product(2, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 72",
            "assert find_adjacent_product(1, [[1, 2], [3, 4]]) == 8",
            "assert find_adjacent_product(2, [[1, 0, 1], [0, 0, 0], [1, 0, 1]]) == 1"
        ]
    },
    {
        "func_name": "convert_location_to_pitch",
        "code": "def convert_location_to_pitch(cur_clef, loc):\n\n    # Define the respective positions of notes, rests\n    # notes = (0,1) (2,3) 0-85 (bot to top)\n    # rests = 86-89 (first to last)\n\n    # Check for rest\n    if loc >= 86:\n        return 'rest'\n\n    note_order_mapping = {'C': 0, 'D': 1, 'E': 2,\n                        'F': 3, 'G': 4, 'A': 5, 'B': 6}\n\n    note_order_mapping_rev = {0: 'C', 1: 'D', 2: 'E',\n                          3: 'F', 4: 'G', 5: 'A', 6: 'B'}\n\n    # Get note position (divide by 2 because up to 2 of same notes can occur)\n    note = loc // 2\n\n    # List of clefs supported\n    '''\n    clef-G2     -- Treble Clef      -- D2 = 0\n    clef-G1                         -- F2 = 0\n    clef-F4     -- Bass Clef        -- F0 = 0\n    clef-F3                         -- A0 = 0\n    clef-F5                         -- D0 = 0\n    clef-C3     -- Alto Clef        -- E1 = 0\n    clef-C4                         -- C1 = 0\n    clef-C5                         -- A0 = 0\n    clef-C1                         -- B1 = 0\n    clef-C2                         -- G1 = 0\n    '''\n\n    # Function mapping a note to its position on clef (bottom note, bottom num) indicates clef\n    def mapper(note, bottom_note, bottom_num):\n        number_inc = note // 7\n        note_inc = note % 7\n        note_val = note_order_mapping_rev[(note_order_mapping[bottom_note] + note_inc + 5) % 7]\n        note_num = bottom_num + number_inc\n        new_note = 'note-' + note_val + str(note_num)\n        return new_note\n\n    # Depending on clef, calculate position on staff of note L-1, S-1, L0, S0, ... L7\n    if cur_clef == 'clef-G2':    # D2 is starting base point\n        idx = mapper(note, 'D', 2)\n    elif cur_clef == 'clef-G1':  # F2 starting point\n        idx = mapper(note, 'F', 2)\n    elif cur_clef == 'clef-F4':  # F0 is starting base point\n        idx = mapper(note, 'F', 0)\n    elif cur_clef == 'clef-F3':  # A0 is starting base point\n        idx = mapper(note, 'A', 0)\n    elif cur_clef == 'clef-F5':  # D0 is starting base point\n        idx = mapper(note, 'D', 0)\n    elif cur_clef == 'clef-C3':  # E1 is starting base point\n        idx = mapper(note, 'E', 1)\n    elif cur_clef == 'clef-C4':  # C1 is starting base point\n        idx = mapper(note, 'C', 1)\n    elif cur_clef == 'clef-C5':  # A0 is starting base point\n        idx = mapper(note, 'A', 0)\n    elif cur_clef == 'clef-C1':  # B1 is starting base point\n        idx = mapper(note, 'B', 1)\n    elif cur_clef == 'clef-C2':  # G1 is starting base point\n        idx = mapper(note, 'G', 1)\n\n    return idx",
        "prompt": "Function that takes a location on binary vector along with the current clef and returns corresponding note ie \"[[1], [15], [(22, 6), (26, 0), (36, 6)], [(32, 0)], [(36, 0)], [(40, 0)], [(26, 6), (40, 6)], [0]]\" and converts to location on line ie. \"clefG2 + timeSigEM + noteA4\"",
        "task_id": "4319",
        "test_list": [
            "assert convert_location_to_pitch('clef-G2', 85) == 'rest'",
            "assert convert_location_to_pitch('clef-G2', 14) == 'clefG2 + timeSigEM + noteC5'",
            "assert convert_location_to_pitch('clef-G2', 28) == 'clefG2 + timeSigEM + noteC6'",
            "assert convert_location_to_pitch('clef-G2', 0) == 'clefG2 + timeSigEM + noteC4'",
            "assert convert_location_to_pitch('clef-G2', 42) == 'clefG2 + timeSigEM + noteC7'"
        ]
    },
    {
        "func_name": "oracle2numpy",
        "code": "\ndef oracle2numpy(desc):\n    or_n = 'or_n'\n    or_f = 'or_f'\n    or_s = 'or_s'\n    \n    name = desc[0]\n    otype = desc[1]\n    size = desc[3]\n    digits = desc[4]\n    scale = desc[5]\n\n    if otype == or_n:\n        if scale is None and digits is None:\n            return \"f8\"\n        if scale == 0 and digits != 0:\n            if digits <= 4:\n                return \"i2\"\n            elif digits <= 9:\n                return \"i4\"\n            else:\n                return \"i8\"\n        else:\n            if digits is None:\n                return \"f8\"\n            if digits <= 6:\n                return \"f4\"\n            elif digits <= 15:\n                return \"f8\"\n            else:\n                return \"f16\"\n    elif otype == or_f:\n        if size == 4:\n            return \"f4\"\n        elif size == 8:\n            return \"f8\"\n    elif otype == or_s:\n        return \"S\" + str(size)\n    else:\n        return \"\"\n",
        "prompt": "Takes an Oracle data type and converts to a numpy dtype string.",
        "task_id": "4333",
        "test_list": [
            "assert oracle2numpy(['f', 'or_f', 8, 0, None, None]) == 'f8'",
            "assert oracle2numpy(['n', 'or_n', 4, 0, None, None]) == 'i2'",
            "assert oracle2numpy(['n', 'or_n', 4, 0, 8, None]) == 'f8'",
            "assert oracle2numpy(['f', 'or_f', 4, 0, None, None]) == 'f4'",
            "assert oracle2numpy(['s', 'or_s', 8, 0, None, None]) == 'S8'"
        ]
    },
    {
        "func_name": "turn_sequence",
        "code": "def turn_sequence(move_list):\n    u = [0,1]\n    d = [0,-1]\n    r = [1, 0]\n    l = [-1, 0]\n    turn_seq = \"\"\n    for i, move in enumerate(move_list[:-1]):\n        next_move = move_list[i+1]\n        if move == next_move:\n            turn_seq += \"s\"  # s for straight\n        elif move == u and next_move == r:  # turned right\n            turn_seq += \"r\"\n        elif move == u and next_move == l:  # turned left\n            turn_seq += \"l\"\n        elif move == d and next_move == r:\n            turn_seq += \"l\"\n        elif move == d and next_move == l:\n            turn_seq += \"r\"\n        elif move == r and next_move == u:\n            turn_seq += \"l\"\n        elif move == r and next_move == d:\n            turn_seq += \"r\"\n        elif move == l and next_move == u:\n            turn_seq += \"r\"\n        elif move == l and next_move == d:\n            turn_seq += \"l\"\n    return turn_seq",
        "prompt": "Given a move list, we can think of the chain formed by starting at [0,0] and applying each move. Then we can think of the intersections along the path of the chain. At each intersection we either go straight (s), turn left (l), or turn right (r). This returns the string \"srlr...\", one character for each turn.",
        "task_id": "4355",
        "test_list": [
            "assert turn_sequence([u, u, r, d, l, r, d, u, l, d]) == 'srllr'",
            "assert turn_sequence([u, r, u, l, d, r, u, l, d, u]) == 'srllr'",
            "assert turn_sequence([d, l, d, r, u, l, d, r, u, l]) == 'srllr'",
            "assert turn_sequence([l, l, r, r, u, u, d, d, l, r]) == 'rrssrr'",
            "assert turn_sequence([r, u, r, u, l, l, d, d, r, u]) == 'rrssrr'"
        ]
    },
    {
        "func_name": "count_leading_digits_var2",
        "code": "def count_leading_digits_var2(numd):\n\n    # Initialize the repartition by ones to avoid division by zero error further ahead\n    f=[1, 1, 1, 1, 1, 1, 1, 1, 1]\n    \n    for i in numd:\n        c = str(int(i))[0]\n        if c == '1':\n            f[0] += 1\n        elif c == '2':\n            f[1] += 1;\n        elif c == '3':\n            f[2] += 1;\n        elif c == '4':\n            f[3] += 1;\n        elif c == '5':\n            f[4] += 1;\n        elif c == '6':\n            f[5] += 1;\n        elif c == '7':\n            f[6] += 1;\n        elif c == '8':\n            f[7] += 1;\n        elif c == '9':\n            f[8] += 1;\n          \n    return f",
        "prompt": "Get the distribution of leading digits of a given numerical distribution",
        "task_id": "4363",
        "test_list": [
            "assert count_leading_digits_var2([100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]",
            "assert count_leading_digits_var2([0, 10, 20, 30, 40, 50, 60, 70, 80, 90]) == [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]",
            "assert count_leading_digits_var2([123, 456, 789, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]",
            "assert count_leading_digits_var2([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]",
            "assert count_leading_digits_var2([111, 222, 333, 444, 555, 666, 777, 888, 999]) == [9, 0, 0, 0, 0, 0, 0, 0, 0]"
        ]
    },
    {
        "func_name": "calculate_circular_pile_set_positions",
        "code": "\nimport math\n\nclass Pile_Position_Offset:\n    NO_OFFSET = 0\n\ndef calculate_circular_pile_set_positions(starting_mat_center, pile_offset, piles_per_side,\n                                          player_index, n_player, pile_position_offset, starting_index_type=None,\n                                          self_player_index=None, counterclockwise=True):\n    if self_player_index is None:\n        self_player_index = 0\n    if starting_index_type is None:\n        starting_index_type = Pile_Position_Offset.NO_OFFSET\n\n    if piles_per_side[0] == -1:\n        nrow = piles_per_side[1]\n        ncol = math.ceil((n_player - 2 * (nrow - 2)) / 2)\n    elif piles_per_side[1] == -1:\n        ncol = piles_per_side[0]\n        nrow = math.ceil((n_player - 2 * (ncol - 2)) / 2)\n    else:\n        ncol = piles_per_side[0]\n        nrow = piles_per_side[1]\n\n    mat_position_index = (player_index - self_player_index + pile_position_offset) % n_player\n    if counterclockwise:\n        if 0 <= mat_position_index <= ncol - 1:\n            grid_position = mat_position_index, 0\n        elif ncol <= mat_position_index <= (ncol - 1 + nrow - 1):\n            grid_position = ncol - 1, mat_position_index - (ncol - 1)\n        elif (ncol - 1 + nrow) <= mat_position_index <= (ncol - 1 + nrow - 1 + ncol - 1):\n            grid_position = (ncol - 1) - (mat_position_index - (ncol - 1 + nrow - 1)), nrow - 1\n        else:\n            grid_position = 0, (nrow - 1) - (mat_position_index - (ncol - 1 + nrow - 1 + ncol - 1))\n    else:\n        if 0 <= mat_position_index < nrow:\n            grid_position = 0, mat_position_index\n        elif nrow <= mat_position_index < (nrow - 1) + ncol:\n            grid_position = mat_position_index - (nrow - 1), nrow - 1\n        elif (nrow - 1) + ncol <= mat_position_index < (nrow - 1) + (ncol - 1) + nrow:\n            grid_position = ncol - 1, (nrow - 1) - (mat_position_index - ((nrow - 1) + ncol))\n        else:\n            grid_position = (ncol - 1) - (mat_position_index - (nrow - 1) + (ncol - 1) + nrow), 0\n    mat_x = starting_mat_center[0] + grid_position[0] * pile_offset[0]\n    mat_y = starting_mat_center[1] + grid_position[1] * pile_offset[1]\n\n    return mat_x, mat_y\n",
        "prompt": "calculate posiitons of indidvidual piles in a circule pile set",
        "task_id": "4400",
        "test_list": [
            "assert calculate_circular_pile_set_positions((0, 0), (1, 1), (3, 3), 0, 4, 0) == (1, 1)",
            "assert calculate_circular_pile_set_positions((0, 0), (1, 1), (3, 3), 1, 4, 0, counterclockwise=True) == (1, 1)",
            "assert calculate_circular_pile_set_positions((0, 0), (1, 1), (3, 3), 3, 4, 0, counterclockwise=True) == (1, 1)",
            "assert calculate_circular_pile_set_positions((0, 0), (1, 1), (3, 3), 2, 4, 0, counterclockwise=True) == (1, 1)",
            "assert calculate_circular_pile_set_positions((0, 0), (1, 1), (3, 3), 0, 4, 0, counterclockwise=False) == (0, 0)"
        ]
    },
    {
        "func_name": "maximal_mesh_pattern_of_occurrence",
        "code": "def maximal_mesh_pattern_of_occurrence(perm, occ):\n\n    k = len(occ)\n\n    con = set(perm[i] for i in occ)\n    colcnt = 0\n    col = [-1] * len(perm)\n    for v in perm:\n        if v in con:\n            colcnt += 1\n        else:\n            col[v] = colcnt\n    rowcnt = 0\n    row = [-1] * len(perm)\n    for v in range(len(perm)):\n        if v in con:\n            rowcnt += 1\n        else:\n            row[v] = rowcnt\n    # bad is the set of boxes that contain points and can not be shaded\n    bad = set((u, v) for u, v in zip(col, row) if u != -1)\n    # cur is the set of boxes that can be shaded\n    cur = set((u, v) for u in range(k + 1) for v in range(k + 1) if (u, v) not in bad)\n    return cur",
        "prompt": "Return the maximal shading M of the classical pattern std(occ) so that the given occurrence is an occurrence of the mesh pattern (std(occ), M).",
        "task_id": "4407",
        "test_list": [
            "assert maximal_mesh_pattern_of_occurrence([0, 1, 2, 0, 1, 2, 3, 4, 5, 6], [0, 1, 2, 3, 4, 5, 6]) == {(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)}",
            "assert maximal_mesh_pattern_of_occurrence([0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 4, 5]) == {(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)}",
            "assert maximal_mesh_pattern_of_occurrence([0, 1, 2, 3, 4, 5], [0, 1, 2, 0, 1, 2]) == {(0, 0), (1, 1), (2, 2), (0, 1), (1, 2), (2, 0), (0, 2), (1, 0), (2, 1)}",
            "assert maximal_mesh_pattern_of_occurrence([0, 1, 2, 0, 1, 2], [0, 1, 2, 3, 4, 5]) == {(0, 0), (1, 1), (2, 2), (0, 1), (1, 2), (2, 0), (0, 2), (1, 0), (2, 1)}",
            "assert maximal_mesh_pattern_of_occurrence([0, 1, 2, 3, 4, 5], [0, 0, 0, 0, 0, 0]) == {(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)}"
        ]
    },
    {
        "func_name": "process_lines_for_spell",
        "code": "def process_lines_for_spell(lines, dh, base_heal=None):\n    n_h = 0\n    n_oh = 0\n    n_f_oh = 0\n    n_oh_nc = 0\n\n    total_h = 0.0\n    total_oh = 0.0\n\n    total_h_nc = 0.0\n    total_oh_nc = 0.0\n\n    for h, oh, crit in lines:\n        dh_c = dh\n\n        oh_nc = oh\n        h_nc = h\n\n        if base_heal and h < base_heal:\n            # Skip unexpectedly low heals\n            continue\n\n        if crit:\n            # scale spell power differential by 1.5 if spell was a crit\n            dh_c *= 1.5\n\n            # Scale oh down\n            h_nc = h / 1.5\n            oh_nc = oh - (h - h_nc)\n\n        # remove spell power contribution\n        h -= dh_c\n        oh -= dh_c\n        if oh < 0.0:\n            oh = 0.0\n\n        h_nc -= dh\n        oh_nc -= dh\n        if oh_nc < 0.0:\n            oh_nc = 0.0\n\n        n_h += 1\n\n        if oh > 0.0:\n            n_oh += 1\n            if oh >= h:\n                n_f_oh += 1\n\n        if oh_nc > 0.0:\n            n_oh_nc += 1\n\n        total_h += h\n        total_oh += oh\n\n        total_h_nc += h_nc\n        total_oh_nc += oh_nc\n\n    return n_h, n_oh, n_f_oh, n_oh_nc, total_h, total_oh, total_h_nc, total_oh_nc",
        "prompt": "Counts up heals and overheals, as well as sum heal and overheal amounts for given spell power adjustment.",
        "task_id": "4419",
        "test_list": [
            "assert process_lines_for_spell([(0, 0, False), (0, 0, True)], 5, 12) == (1, 0, 0, 0, 0, 0, 0, 0)",
            "assert process_lines_for_spell([(10, 10, False), (10, 10, False), (10, 10, False)], 5, 12) == (3, 3, 0, 0, 30, 30, 0, 0)",
            "assert process_lines_for_spell([(5, 3, False), (10, 7, False), (15, 12, True)], 5, 12) == (3, 2, 0, 1, 15, 10, 0, 2)",
            "assert process_lines_for_spell([(20, 15, False), (25, 20, False), (30, 25, True)], 5, 12) == (3, 3, 0, 0, 60, 45, 0, 0)",
            "assert process_lines_for_spell([(10, 5, False), (15, 10, True)], 5, 12) == (2, 2, 1, 1, 20, 15, 5, 5)"
        ]
    },
    {
        "func_name": "crosscount",
        "code": "\nimport math\n\ndef crosscount(v):\n    people = ['A', 'B', 'C', 'D']  # Define the list of people\n    links = [('A', 'B'), ('C', 'D')]  # Define the list of links\n    loc = {p:(v[2*i],v[2*i+1]) for i, p in enumerate(people)}\n    total = 0\n\n    for i in range(len(links)):\n        for j in range(i+1, len(links)):\n            (x1,y1),(x2,y2) = loc[links[i][0]],loc[links[i][1]]\n            (x3,y3),(x4,y4) = loc[links[j][0]],loc[links[j][1]]\n            den = (y4-y3)*(x2-x1)-(x4-x3)*(y2-y1)\n\n            if den == 0: continue\n\n            ua=((x4-x3)*(y1-y3)-(y4-y3)*(x1-x3))/den\n            ub=((x2-x1)*(y1-y3)-(y2-y1)*(x1-x3))/den\n\n            if ua>0 and ua<1 and ub>0 and ub<1: total +=1\n\n        for i in range(len(people)):\n            for j in range(i+1, len(people)):\n                (x1,y1), (x2,y2) = loc[people[i]], loc[people[j]]\n                dist = math.sqrt(math.pow(x1-x2,2)+math.pow(y1-y2,2))\n                if dist < 50: total += (1.0-(dist/50))\n    return total\n",
        "prompt": "Fun przechodzi po kazdej parze linii uzywajac aktualnych koordynatow ich koncow, by okreslic czy sie przecinaja. Jesli tak fun dodaje 1 do calkowitego wyniku",
        "task_id": "4509",
        "test_list": [
            "assert crosscount([0, 0, 100, 100, 200, 200]) == 1",
            "assert crosscount([0, 0, 100, 100, 150, 150, 200, 200]) == 2",
            "assert crosscount([0, 0, 100, 100, 150, 150, 200, 200, 250, 250, 300, 300, 350, 350, 400, 400, 450, 450, 500, 500]) == 5",
            "assert crosscount([0, 0, 100, 100, 200, 200, 300, 300, 400, 400]) == 3",
            "assert crosscount([0, 0, 100, 100, 150, 150, 200, 200, 250, 250, 300, 300, 350, 350, 400, 400]) == 4"
        ]
    },
    {
        "func_name": "checkFormulas",
        "code": "def checkFormulas(arguments, formulaTuple, state):\n\tfor formula in formulaTuple:\n\t\tif len(formula) == 1 and formula[0] not in state:\n\t\t\treturn False\n\t\tif len(formula) == 2\\\n\t\t\tand (formula[0] not in state or arguments[formula[1]] not in state[formula[0]]):\n\t\t\treturn False\n\t\tif len(formula) == 3\\\n\t\t\tand (formula[0] not in state or (arguments[formula[1]], arguments[formula[2]]) not in state[formula[0]]):\n\t\t\treturn False\n\treturn True",
        "prompt": "The arguments are checked against the conditions in \"formulaTuple\" in context \"state\".",
        "task_id": "4724",
        "test_list": [
            "assert checkFormulas({'x': 10, 'y': 20, 'z': 30}, [('x', 'y'), ('y', 'z')], {'x': {10, 11}, 'y': {20, 21}, 'z': {30, 31}}) == True",
            "assert checkFormulas({'x': 'apple', 'y': 'banana', 'z': 'cherry'}, [('x', 'y'), ('y', 'z')], {'x': {'apple'}, 'y': {'banana'}, 'z': {'cherry'}}) == True",
            "assert checkFormulas({'a': 'apple', 'b': 'banana', 'c': 'cherry'}, [('a', 'b'), ('b', 'c'), ('c', 'a')], {'a': {'apple'}, 'b': {'banana'}, 'c': {'cherry'}}) == False",
            "assert checkFormulas({'a': 1, 'b': 2}, [('a', 'b'), ('b', 'a')], {'a': {1, 2}, 'b': {2, 3}}) == True",
            "assert checkFormulas({'alpha': 'A', 'beta': 'B', 'gamma': 'C'}, [('alpha', 'beta'), ('beta', 'gamma')], {'alpha': {'A'}, 'beta': {'B'}, 'gamma': {'C'}}) == True"
        ]
    },
    {
        "func_name": "bound_line_in_box",
        "code": "\nfrom typing import Tuple, Union\nimport math\n\ndef bound_line_in_box(w: float, h: float,\n        x0: float, y0: float, dir_x: float, dir_y: float,\n        length_margin: float) -> Tuple[Union[None, bool], float, float]:\n    # length_margin: positive for length, negative for margin to boundary\n    # make sure x0, y0 is in the box\n    assert( 0 <= x0 <= w and 0 <= y0 <= h)\n    # check possible boundary points\n    # make sure dir_x, dir_y is valid\n    assert( not (dir_x == 0 and dir_y == 0) )\n   \n    float_eps = 1e-12\n    bound_x, bound_y = 0, 0\n    # conditions for checking cross with right edge\n    if x0 != w and dir_x > 0 and \\\n        ( (dir_y >= 0 and dir_y / dir_x <= (h-y0) / (w-x0) + float_eps) or \\\n          (dir_y < 0 and -dir_y / dir_x <= y0 / (w-x0) + float_eps) ):\n        # cross with right edge\n        bound_x = w\n        bound_y = dir_y / dir_x * (w-x0) + y0 \n    elif x0 != 0 and dir_x < 0 and \\\n        ( (dir_y >= 0 and dir_y / -dir_x <= (h-y0) / x0 + float_eps) or \\\n          (dir_y < 0 and dir_y / dir_x <= y0 / x0  + float_eps) ):\n        # cross with left edge\n        bound_x = 0 \n        bound_y = dir_y / -dir_x * x0 + y0\n    elif y0 != h and dir_y > 0 and \\\n        ( (dir_x >= 0 and dir_x / dir_y <= (w-x0) / (h-y0) + float_eps) or \\\n          (dir_x < 0 and -dir_x / dir_y <= x0 / (h-y0) + float_eps) ):\n        # cross with top edge\n        bound_y = h\n        bound_x = dir_x / dir_y * (h-y0) + x0\n    elif y0 != 0 and dir_y < 0 and \\\n        ( (dir_x >= 0 and dir_x / -dir_y <= (w-x0) / y0 + float_eps) or \\\n          (dir_x < 0 and dir_x / dir_y <= x0 / y0 + float_eps) ):\n        # cross with bottom edge\n        bound_y = 0\n        bound_x = dir_x / -dir_y * y0 + x0\n    else:\n        # impossible to bound \n        return None, -x0, -y0\n\n    bound_dist = math.sqrt((x0 - bound_x) ** 2 + (y0 - bound_y) ** 2)\n    dir_dist = math.sqrt(dir_x ** 2 + dir_y ** 2)\n    if length_margin > 0:\n        if bound_dist >= length_margin:\n            # clip to length\n            okay_x = x0 + dir_x / dir_dist * length_margin\n            okay_y = y0 + dir_y / dir_dist * length_margin\n            return False, okay_x, okay_y\n        else:\n            return True, bound_x, bound_y # clipped\n    else:\n        a_length = bound_dist + length_margin\n        if a_length <= 0:\n            # can't satisfy the margin, stop\n            return None, -x0, -y0\n        else:\n            okay_x = x0 + dir_x / dir_dist * a_length\n            okay_y = y0 + dir_y / dir_dist * a_length\n            return False, okay_x, okay_y\n",
        "prompt": "start from x0, y0 towards the direction (dir_x, dir_y), find the x1, y1 so that the distance of (x0, y0) to (x1, y1) is length_margin if positive, or distance of (x1, y1) to canvas boundary is length_margin if negative, unless it reaches the boundary before then (x1, y1) is the point on boundary",
        "task_id": "4772",
        "test_list": [
            "assert bound_line_in_box(10, 10, 5, 5, 0, 1, 5) == (False, 5, 10)",
            "assert bound_line_in_box(10, 10, 0, 0, 1, 1, 5) == (False, 5, 5)",
            "assert bound_line_in_box(10, 10, 5, 5, 1, 0, 5) == (False, 10, 5)",
            "assert bound_line_in_box(10, 10, 9, 9, -1, -1, 5) == (False, 0, 0)",
            "assert bound_line_in_box(10, 10, 5, 5, 1, 1, 5) == (False, 10, 10)"
        ]
    },
    {
        "func_name": "change_display",
        "code": "def change_display(data, mode):\n    for i in range(len(data)):\n        data[i] = int(data[i])\n    if mode < 1 or mode > 20:\n        return data\n    if mode < 11:  # if in modes 1-10\n        if mode < 6:\n            for i in range(mode):\n                data[i] += 64\n        else:\n            mode -= 5\n            for i in range(5):\n                data[i] += 64\n            for i in range(mode):\n                data[(i + 1) * -1] += 32\n\n    else:  # if in modes 11-20\n        mode -= 10  # avoid getting list index out of range\n        if mode < 6:\n            for i in range(5):\n                data[i] += 32\n            for i in range(5 - mode):\n                data[(i + 1) * -1] += 64\n        else:\n            mode -= 5\n            for i in range(5 - mode):\n                data[i] += 32\n\n    return data",
        "prompt": "Updates the display content.",
        "task_id": "4824",
        "test_list": [
            "assert change_display([1, 2, 3, 4, 5], 5) == [65, 66, 67, 68, 69]",
            "assert change_display([1, 2, 3, 4, 5], 6) == [65, 66, 67, 68, 69, 70]",
            "assert change_display([1, 2, 3, 4, 5], 8) == [65, 66, 67, 68, 69, 70, 71, 72]",
            "assert change_display([1, 2, 3, 4, 5], 1) == [65, 66, 67, 68, 69]",
            "assert change_display([1, 2, 3, 4, 5], 7) == [65, 66, 67, 68, 69, 70, 71]"
        ]
    },
    {
        "func_name": "oligo_complements",
        "code": "def oligo_complements(oligo):\n    complement = \"\"\n    reverse = \"\"\n    reverse_complement = \"\"\n    oligo2 = \"\"\n    for ch in oligo:\n        if ch == 'A':\n            complement += 'T'\n        elif ch == 'T' or ch == 'U':\n            complement += 'A'\n        elif ch == 'C':\n            complement += 'G'\n        elif ch == 'G':\n            complement += 'C'\n    for ch in oligo:\n        if ch == 'U':\n            oligo2 += 'T'\n        else:\n            oligo2 += ch\n\n    i = len(oligo) - 1\n    while i >= 0:\n        reverse += oligo[i]\n        reverse_complement += complement[i]\n        i -= 1\n    oligos = [oligo2, complement, reverse, reverse_complement]\n    return oligos",
        "prompt": ">>> oligo_complements('AAAAA') ['AAAAA', 'TTTTT', 'AAAAA', 'TTTTT'] >>> oligo_complements('CCA') ['CCA', 'GGT', 'ACC', 'TGG']",
        "task_id": "4861",
        "test_list": [
            "assert oligo_complements('GCGC') == ['GCGC', 'CGCG', 'GCGC', 'CGCG']",
            "assert oligo_complements('AUGC') == ['AUGC', 'UACG', 'AUGC', 'UACG']",
            "assert oligo_complements('AUCG') == ['AUCG', 'TAGC', 'AUCG', 'TAGC']",
            "assert oligo_complements('GATC') == ['GATC', 'CTAG', 'GATC', 'CTAG']",
            "assert oligo_complements('TTTT') == ['TTTT', 'AAAA', 'TTTT', 'AAAA']"
        ]
    },
    {
        "func_name": "get_text_point_at_line",
        "code": "def get_text_point_at_line(extents, p1, p2, align, padding):\n    name_dx = 0.0\n    name_dy = 0.0\n    ofs = 5\n\n    dx = float(p2[0]) - float(p1[0])\n    dy = float(p2[1]) - float(p1[1])\n\n    name_w, name_h = extents\n\n    if dy == 0:\n        rc = 1000.0  # quite a lot...\n    else:\n        rc = dx / dy\n    abs_rc = abs(rc)\n    h = dx > 0  # right side of the box\n    v = dy > 0  # bottom side\n\n    if abs_rc > 6:\n        # horizontal line\n        if h:\n            name_dx = ofs\n            name_dy = -ofs - name_h\n        else:\n            name_dx = -ofs - name_w\n            name_dy = -ofs - name_h\n    elif 0 <= abs_rc <= 0.2:\n        # vertical line\n        if v:\n            name_dx = -ofs - name_w\n            name_dy = ofs\n        else:\n            name_dx = -ofs - name_w\n            name_dy = -ofs - name_h\n    else:\n        # Should both items be placed on the same side of the line?\n        r = abs_rc < 1.0\n\n        # Find out alignment of text (depends on the direction of the line)\n        align_left = (h and not r) or (r and not h)\n        align_bottom = (v and not r) or (r and not v)\n        if align_left:\n            name_dx = ofs\n        else:\n            name_dx = -ofs - name_w\n        if align_bottom:\n            name_dy = -ofs - name_h\n        else:\n            name_dy = ofs\n    return p1[0] + name_dx, p1[1] + name_dy",
        "prompt": "Calculate position of the text relative to a line defined by points (p1, p2). Text is aligned using align and padding information.",
        "task_id": "4939",
        "test_list": [
            "assert get_text_point_at_line((100, 50), (0, 0), (0, 100), 'center', 10) == (-5, 5)",
            "assert get_text_point_at_line((100, 50), (0, 0), (100, 100), 'bottom', 10) == (10, 90)",
            "assert get_text_point_at_line((100, 50), (0, 0), (0, 100), 'top', 10) == (-10, 10)",
            "assert get_text_point_at_line((100, 50), (0, 0), (0, 100), 'right', 10) == (-10, 0)",
            "assert get_text_point_at_line((100, 50), (0, 0), (100, 0), 'left', 10) == (10, 0)"
        ]
    },
    {
        "func_name": "bin_search_range",
        "code": "def bin_search_range(array, hi, lo, min_r, max_r):    \n    count = 0\n    while True:\n        mid = math.ceil((hi + lo) / 2)\n        if lo >= hi:\n            return count\n        count += 1\n        if min_r <= array[mid] <= max_r:\n            mid1 = mid\n            while True:\n                # going backwards\n                if mid == 0 or array[mid] < min_r:\n                    break\n                if min_r <= array[mid]:\n                    count += 1\n                    mid -= 1\n                else:\n                    break\n            while True:\n                if mid1 == len(array) or array[mid] > max_r:\n                    break\n                if max_r >= array[mid1]:\n                    count += 1\n                    mid1 += 1\n                else:\n                    break\n            return count\n        elif array[mid] < min_r:\n            lo = mid + 1\n        elif array[mid] > max_r:\n            hi = mid - 1",
        "prompt": "Same idea as the typicall binary search but this time as soon as we hit a number inside the specified range linearly check every element before and after if they meet the range requirements",
        "task_id": "4946",
        "test_list": [
            "assert bin_search_range([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 9, 0, 50, 90) == 7",
            "assert bin_search_range([10, 20, 30, 40, 50], 4, 0, 25, 45) == 3",
            "assert bin_search_range([1, 3, 5, 7, 9, 11, 13, 15], 7, 0, 6, 12) == 5",
            "assert bin_search_range([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 9, 0, 3, 7) == 6",
            "assert bin_search_range([5, 15, 25, 35, 45], 4, 0, 10, 40) == 2"
        ]
    },
    {
        "func_name": "descartes",
        "code": "def descartes(poly_array):\n    poly_array_aux = [ x for x in poly_array if x is not 0 ]\n\n    positive_alternate_signs = 0\n    i = 0\n    while i <= len(poly_array_aux) - 2:\n        aux_1 = poly_array_aux[i]\n        aux_2 = poly_array_aux[i+1]\n        if (aux_1 > 0 and aux_2 < 0) or (aux_1 < 0 and aux_2 > 0):\n            positive_alternate_signs += 1\n        i += 1\n \n    negative_alternate_signs = 0\n    i = 0\n    poly_array_aux = poly_array[:]\n    for i in range(len(poly_array_aux)):\n        if (i % 2) != 0:\n            poly_array_aux[i] = - poly_array_aux[i]\n    poly_array_aux = [ x for x in poly_array_aux if x is not 0 ]\n    i = 0\n    while i <= len(poly_array_aux) - 2:\n        aux_1 = poly_array_aux[i]\n        aux_2 = poly_array_aux[i+1]\n        if (aux_1 > 0 and aux_2 < 0) or (aux_1 < 0 and aux_2 > 0):\n            negative_alternate_signs += 1    \n        i += 1\n\n    degree = len(poly_array) - 1\n    x = (positive_alternate_signs // 2) + 1\n    y = (negative_alternate_signs // 2) + 1\n    possible_pos_roots = [positive_alternate_signs - 2*i for i in range(x) if (positive_alternate_signs - 2*i) >= 0]\n    possible_neg_roots = [negative_alternate_signs - 2*i for i in range(y) if (negative_alternate_signs - 2*i) >= 0]\n    possibility_matrix = [[ 0 for i in range(3) ] for j in range(x*y)]\n\n    k = 0\n    for i in possible_pos_roots:\n        for j in possible_neg_roots:\n            possibility_matrix[k][0] = i\n            possibility_matrix[k][1] = j\n            possibility_matrix[k][2] = degree - (i+j)\n            k += 1\n    \n    return possibility_matrix",
        "prompt": "Retorna uma matriz de possibilidades de raizes reais positivas (coluna 0) / reais negativas (coluna 1) / complexas (coluna 2)",
        "task_id": "4956",
        "test_list": [
            "assert descartes([1, 2, 3, 4, 5, 6, 7, 8]) == [[4, 4, 4], [4, 4, 4], [0, 0, 8]]",
            "assert descartes([1, -1, 2, -2, 3, -3, 0, 0]) == [[1, 1, 4], [1, 1, 4], [0, 0, 6]]",
            "assert descartes([0, 0, 0, 0, 0, 0, 0, 0]) == [[0, 0, 0], [0, 0, 0], [0, 0, 0]]",
            "assert descartes([0, 1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 8, -8]) == [[4, 4, 4], [4, 4, 4], [0, 0, 16]]",
            "assert descartes([-1, -2, -3, -4, -5, -6, -7, -8]) == [[4, 4, 4], [4, 4, 4], [0, 0, 8]]"
        ]
    },
    {
        "func_name": "row_revile_indexes",
        "code": "\ndef row_revile_indexes(lines_vars, labale_X='X', labale_dX='dX', labale_Y='Y', labale_dY='dY'):\n    # default value for the indexes\n    index_x, index_dx, index_y, index_dy = -1, -1, -1, -1\n\n    for line_vas in enumerate(lines_vars):\n        \n        # have all the indexes been defined, if so return the result\n        if index_x != -1 and index_dx != -1 and index_y != -1 and index_dy != -1:\n            return index_x, index_dx, index_y, index_dy\n\n        labale = line_vas[1][0].lower()\n\n        if labale == labale_X and index_x == -1:\n            index_x = line_vas[0]\n        \n        elif labale == labale_dX and index_dx == -1:\n            index_dx = line_vas[0]\n        \n        elif labale == labale_Y and index_y == -1:\n            index_y = line_vas[0]\n        \n        elif labale == labale_dY and index_dy == -1:\n            index_dy = line_vas[0]\n    \n    # making sure the result would be returned\n    return index_x, index_dx, index_y, index_dy\n",
        "prompt": "returns the indexes of the x, dx, y and dy rows respectively (type int)",
        "task_id": "4964",
        "test_list": [
            "assert row_revile_indexes([['X', 'a'], ['dX', 'b'], ['Y', 'c'], ['dY', 'd']]) == (-1, -1, -1, -1)",
            "assert row_revile_indexes([['X', 'a'], ['dX', 'b'], ['dX', 'c'], ['dY', 'd']]) == (0, 0, -1, -1)",
            "assert row_revile_indexes([['X', 'a'], ['X', 'b'], ['Y', 'c'], ['dX', 'd']]) == (0, 1, 2, -1)",
            "assert row_revile_indexes([['X', 'a'], ['dX', 'b'], ['Y', 'c'], ['dY', 'd']]) == (0, 1, 2, 3)",
            "assert row_revile_indexes([['X', 'a'], ['Y', 'b'], ['dX', 'c'], ['dY', 'd']]) == (0, 2, 1, 3)"
        ]
    },
    {
        "func_name": "usage_bound",
        "code": "def usage_bound(disk_sizes, num_devices, raid_level):\n    # Determine RAID parameters\n    data_ratio = 1\n    stripes = 1\n    parity = 0\n\n    # Number of chunks to write at a time: as many as possible within the\n    # number of stripes\n    chunks = num_devices\n\n    if raid_level == 'single':\n        chunks = 1\n    elif raid_level == 'raid0':\n        stripes = 2\n    elif raid_level == 'raid1':\n        data_ratio = 2\n        chunks = 2\n    elif raid_level == 'raid10':\n        data_ratio = 2\n        stripes = max(2, int(num_devices / 2))\n    elif raid_level == 'raid5':\n        parity = 1\n    elif raid_level == 'raid6':\n        parity = 2\n\n    # Round down so that we have an exact number of duplicate copies\n    chunks -= chunks % data_ratio\n\n    # Check for feasibility at the lower end\n    if num_devices < data_ratio * (stripes + parity):\n        return 0\n\n    # Compute the trivial bound\n    bound = int(sum(disk_sizes) / chunks)\n\n    # For each partition point q, compute B_q (the test predicate) and\n    # modify the trivial bound if it passes.\n    bounding_q = -1\n    for q in range(chunks - 1):\n        slice = sum(disk_sizes[q + 1:])\n        b = int(slice / (chunks - q - 1))\n        if disk_sizes[q] >= b and b < bound:\n            bound = b\n            bounding_q = q\n\n    # The bound is the number of allocations we can make in total. If we\n    # have no bounding_q, then we have hit the trivial bound, and exhausted\n    # all space, so we can return immediately.\n    if bounding_q == -1:\n        return bound * ((chunks / data_ratio) - parity)\n\n    # If we have a bounding_q, then all the devices past q are full, and\n    # we can remove them. The devices up to q have been used in every one\n    # of the allocations, so we can just reduce them by bound.\n    disk_sizes = [size - bound for index, size in enumerate(disk_sizes)\n                  if index <= bounding_q]\n\n    new_bound = usage_bound(disk_sizes, bounding_q + 1, raid_level)\n\n    return bound * ((chunks / data_ratio) - parity) + new_bound",
        "prompt": "Return the total amount of storage possible within this pool's set of disks, in bytes.",
        "task_id": "5150",
        "test_list": [
            "assert usage_bound([100, 200, 300, 400], 4, 'raid1') == 300",
            "assert usage_bound([500, 500, 500], 3, 'raid10') == 500",
            "assert usage_bound([100, 200, 300, 400, 500], 5, 'raid6') == 0",
            "assert usage_bound([100, 200, 300], 3, 'raid5') == 600",
            "assert usage_bound([100, 200, 300, 400, 500, 600], 6, 'raid0') == 600"
        ]
    },
    {
        "func_name": "define_neighbours",
        "code": "def define_neighbours(m,i,j):\r\n    #Defining all the elements as 0\r\n    n=e=w=s=ne=nw=se=sw=[]\r\n    a=len(m)\r\n    b=len(m[0])\r\n    if(i!=0 and j!=0 and i!=(a-1) and j!=(b-1)):\r\n        n=[i-1,j]\r\n        e=[i,j+1]\r\n        w=[i,j-1]\r\n        s=[i+1,j]\r\n        ne=[i-1,j+1]\r\n        nw=[i-1,j-1]\r\n        se=[i+1,j+1]\r\n        sw=[i+1,j-1]\r\n    elif(i==0):\r\n        s=[i+1,j]\r\n        n=[a-1,j]\r\n        if(j==0):\r\n            se=[i+1,j+1]\r\n            e=[i,j+1]\r\n            ne=[a-1,j+1]\r\n            w=[i,b-1]\r\n            nw=[a-1,b-1]\r\n            sw=[i+1,b-1]\r\n        elif(j==b-1):\r\n            e=[i,0]\r\n            w=[i,j-1]\r\n            nw=[a-1,j-1]\r\n            ne=[a-1,0]\r\n            sw=[i+1,j-1]\r\n            se=[i+1,0]\r\n        else:\r\n            e=[i,j+1]\r\n            w=[i,j-1]\r\n            se=[i+1,j+1]\r\n            sw=[i+1,j-1]\r\n            ne=[a-1,j+1]\r\n            nw=[a-1,j-1]\r\n    elif (i==a-1):\r\n        n=[i-1,j]\r\n        s=[0,j]\r\n        if(j==0):\r\n            e=[i,j+1]\r\n            w=[i,b-1]\r\n            ne=[i-1,j+1]\r\n            nw=[i-1,b-1]\r\n            sw=[0,b-1]\r\n            se=[0,j+1]\r\n        elif(j==b-1):\r\n            w=[i,j-1]\r\n            e=[i,0]\r\n            ne=[i-1,0]\r\n            nw=[i-1,j-1]\r\n            sw=[0,j-1]\r\n            se=[0,0]\r\n        else:\r\n            e=[i,j+1]\r\n            w=[i,j-1]\r\n            nw=[i-1,j-1]\r\n            ne=[i-1,j+1]\r\n            sw=[0,j-1]\r\n            se=[0,j+1]\r\n    elif(j==0):\r\n        n=[i-1,j]\r\n        e=[i,j+1]\r\n        w=[i,b-1]\r\n        s=[i+1,j]\r\n        ne=[i-1,j+1]\r\n        nw=[i-1,b-1]\r\n        se=[i+1,j+1]\r\n        sw=[i+1,b-1]\r\n    elif(j==b-1):\r\n        n=[i-1,j]\r\n        e=[i,0]\r\n        w=[i,j-1]\r\n        s=[i+1,j]\r\n        ne=[i-1,0]\r\n        nw=[i-1,j-1]\r\n        se=[i+1,0]\r\n        sw=[i+1,j-1]\r\n    neighbours=[n,ne,e,se,s,sw,w,nw]\r\n    return neighbours",
        "prompt": "This will define the position of all the neighbours, and store them in a list in the format [[i,j],[i,j]] The list returned will be of format [n,ne,e,se,s,sw,w,nw]",
        "task_id": "5205",
        "test_list": [
            "assert define_neighbours([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1, 1, [[0, 2], [1, 0], [2, 2], [1, 0], [0, 1], [2, 0], [1, 2], [2, 1]]) == [[0, 2], [1, 0], [2, 2], [1, 0], [0, 1], [2, 0], [1, 2], [2, 1]]",
            "assert define_neighbours([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 0, 0, [[1, 0], [0, 1], [1, 1], [0, 0], [1, 0], [0, 1], [1, 0], [0, 1]]) == [[1, 0], [0, 1], [1, 1], [0, 0], [1, 0], [0, 1], [1, 0], [0, 1]]",
            "assert define_neighbours([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2, 2, [[1, 1], [2, 1], [1, 1], [2, 1], [1, 2], [1, 1], [2, 1], [2, 1]]) == [[1, 1], [2, 1], [1, 1], [2, 1], [1, 2], [1, 1], [2, 1], [2, 1]]",
            "assert define_neighbours([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2, 0, [[1, 0], [2, 0], [1, 1], [2, 1], [1, 0], [2, 0], [1, 1], [2, 1]]) == [[1, 0], [2, 0], [1, 1], [2, 1], [1, 0], [2, 0], [1, 1], [2, 1]]",
            "assert define_neighbours([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 0, 2, [[1, 1], [0, 2], [1, 1], [0, 1], [1, 1], [0, 1], [1, 1], [0, 1]]) == [[1, 1], [0, 2], [1, 1], [0, 1], [1, 1], [0, 1], [1, 1], [0, 1]]"
        ]
    },
    {
        "func_name": "_get_barchart_sizings",
        "code": "\ndef _get_barchart_sizings(x_title, n_clusters, n_bars_in_cluster, max_x_lbl_width):\n    debug = False\n    MIN_PXLS_PER_BAR = 30\n    MIN_CLUSTER_WIDTH = 60\n    MIN_CHART_WIDTH = 450\n    PADDING_PXLS = 35\n    DOJO_MINOR_TICKS_NEEDED_FROM_N = 10\n    AVG_CHAR_WIDTH_PXLS = 6  # Define AVG_CHAR_WIDTH_PXLS\n    min_width_per_cluster = MIN_PXLS_PER_BAR * n_bars_in_cluster\n    width_per_cluster = max([min_width_per_cluster, MIN_CLUSTER_WIDTH, max_x_lbl_width * AVG_CHAR_WIDTH_PXLS]) + PADDING_PXLS\n    width_x_title = len(x_title) * AVG_CHAR_WIDTH_PXLS + PADDING_PXLS\n    width = max([width_per_cluster * n_clusters, width_x_title, MIN_CHART_WIDTH])\n    if n_clusters <= 2:\n        xgap = 20\n    elif n_clusters <= 5:\n        xgap = 10\n    elif n_clusters <= 8:\n        xgap = 8\n    elif n_clusters <= 10:\n        xgap = 6\n    elif n_clusters <= 16:\n        xgap = 5\n    else:\n        xgap = 4\n    if n_clusters <= 5:\n        xfontsize = 10\n    elif n_clusters > 10:\n        xfontsize = 8\n    else:\n        xfontsize = 9\n    init_margin_offset_l = 35 if width > 1200 else 25\n    minor_ticks = 'true' if n_clusters >= DOJO_MINOR_TICKS_NEEDED_FROM_N else 'false'\n    if debug:\n        print(width, xgap, xfontsize, minor_ticks, init_margin_offset_l)\n    return width, xgap, xfontsize, minor_ticks, init_margin_offset_l\n",
        "prompt": "minor_ticks generally we don't want them as they result in lots of ticks between the groups in clustered bar charts each with a distracting and meaningless value e.g. if we have two groups 1 and 2 we don't want a tick for 0.8 and 0.9 etc. But if we don't have minor ticks when we have a massive number of clusters we get no ticks at all. Probably a dojo bug I am trying to work around.",
        "task_id": "5249",
        "test_list": [
            "assert _get_barchart_sizings('Cluster', 16, 10, 100) == (450, 4, 8, 'false', 25)",
            "assert _get_barchart_sizings('Cluster', 10, 3, 100) == (450, 6, 8, 'false', 35)",
            "assert _get_barchart_sizings('Cluster', 3, 5, 100) == (450, 10, 10, 'false', 35)",
            "assert _get_barchart_sizings('Cluster', 1, 10, 100) == (450, 20, 10, 'false', 35)",
            "assert _get_barchart_sizings('Cluster', 8, 1, 100) == (60, 8, 9, 'false', 25)"
        ]
    },
    {
        "func_name": "flag_meaning",
        "code": "def flag_meaning(flag):\n    \n    if flag == 'all':\n        meaning = \"Flare Flag Codes: \\na0 - In attenuator state 0 (None) sometime during flare \\na1 - In attenuator state 1 (Thin) sometime during flare \\na2 - In attenuator state 2 (Thick) sometime during flare \\na3 - In attenuator state 3 (Both) sometime during flare \\nAn - Attenuator state (0=None, 1=Thin, 2=Thick, 3=Both) at peak of flare \\nDF - Front segment counts were decimated sometime during flare\\nDR - Rear segment counts were decimated sometime during flare \\nED - Spacecraft eclipse (night) sometime during flare\\nEE - Flare ended in spacecraft eclipse (night) \\nES - Flare started in spacecraft eclipse (night) \\nFE - Flare ongoing at end of file \\nFR - In Fast Rate Mode \\nFS - Flare ongoing at start of file \\nGD - Data gap during flare \\nGE - Flare ended in data gap\\nGS - Flare started in data gap \\nMR - Spacecraft in high-latitude zone during flare \\nNS - Non-solar event\\nPE - Particle event: Particles are present \\nPS - Possible Solar Flare; in front detectors, but no position\\nPn - Position Quality: P0 = Position is NOT valid, P1 = Position is valid \\nQn - Data Quality: Q0 = Highest Quality, Q11 = Lowest Quality\\nSD - Spacecraft was in SAA sometime during flare \\nSE - Flare ended when spacecraft was in SAA\\nSS - Flare started when spacecraft was in SAA\"\n    elif flag == 'a0':\n        meaning = 'a0 - In attenuator state 0 (None) sometime during flare'\n    elif flag == 'a1':\n        meaning = 'a1 - In attenuator state 1 (Thin) sometime during flare'\n    elif flag == 'a2':\n        meaning = 'a2 - In attenuator state 2 (Thick) sometime during flare'\n    elif flag == 'a3':\n        meaning = 'a3 - In attenuator state 3 (Both) sometime during flare'\n    elif flag[0] == 'A':\n        meaning = 'An - Attenuator state (0=None, 1=Thin, 2=Thick, 3=Both) at peak of flare'\n    elif flag == 'DF':\n        meaning = 'DF - Front segment counts were decimated sometime during flare'\n    elif flag == 'DR':\n        meaning = 'DR - Rear segment counts were decimated sometime during flare'\n    elif flag == 'ED':\n        meaning = 'ED - Spacecraft eclipse (night) sometime during flare'\n    elif flag == 'EE':\n        meaning = 'EE - Flare ended in spacecraft eclipse (night)'\n    elif flag == 'ES':\n        meaning = 'ES - Flare started in spacecraft eclipse (night)'\n    elif flag == 'FE':\n        meaning = 'FE - Flare ongoing at end of file'\n    elif flag == 'FR':\n        meaning = 'FR - In Fast Rate Mode'\n    elif flag == 'FS':\n        meaning = 'FS - Flare ongoing at start of file'\n    elif flag == 'GD':\n        meaning = 'GD - Data gap during flare'\n    elif flag == 'GE':\n        meaning = 'GE - Flare ended in data gap'\n    elif flag == 'GS':\n        meaning = 'GS - Flare started in data gap'\n    elif flag == 'MR':\n        meaning = 'MR - Spacecraft in high-latitude zone during flare'\n    elif flag == 'NS':\n        meaning = 'NS - Non-solar event'\n    elif flag == 'PE':\n        meaning = 'PE - Particle event: Particles are present'\n    elif flag == 'PS':\n        meaning = 'PS - Possible Solar Flare; in front detectors, but no position'\n    elif flag[0] == 'P':\n        meaning = 'Pn - Position Quality: P0 = Position is NOT valid, P1 = Position is valid'\n    elif flag[0] == 'Q':\n        meaning = 'Qn - Data Quality: Q0 = Highest Quality, Q11 = Lowest Quality'  \n    elif flag == 'SD':\n        meaning = 'SD - Spacecraft was in SAA sometime during flare'\n    elif flag == 'SE':\n        meaning = 'SE - Flare ended when spacecraft was in SAA'\n    elif flag == 'SS':\n        meaning = 'SS - Flare started when spacecraft was in SAA'\n    else:\n        meaning = 'Error: invalid flag'\n    \n    return meaning",
        "prompt": "return the meaning of a flag, return all meanings if flag == all",
        "task_id": "5264",
        "test_list": [
            "assert flag_meaning('SD') == 'SD - Spacecraft was in SAA sometime during flare'",
            "assert flag_meaning('EE') == 'EE - Flare ended in spacecraft eclipse (night)'",
            "assert flag_meaning('a0') == 'a0 - In attenuator state 0 (None) sometime during flare'",
            "assert flag_meaning('FR') == 'FR - In Fast Rate Mode'",
            "assert flag_meaning('NS') == 'NS - Non-solar event'"
        ]
    },
    {
        "func_name": "coord_finder",
        "code": "def coord_finder(S):\n\tx = 0\n\ty = 0\n\torientation = 0\n\tfor s in S:\n\t\tif orientation == 0:\n\t\t\tif s == \"F\":\n\t\t\t\tx += 1\n\t\t\telif s == \"L\":\n\t\t\t\ty += 1\n\t\t\t\torientation = 1\n\t\t\telif s == \"R\":\n\t\t\t\ty -= 1\n\t\t\t\torientation = 3\n\t\telif orientation == 1:\n\t\t\tif s == \"F\":\n\t\t\t\ty += 1\n\t\t\telif s == \"L\":\n\t\t\t\tx -= 1\n\t\t\t\torientation = 2\n\t\t\telif s == \"R\":\n\t\t\t\tx += 1\n\t\t\t\torientation = 0\n\t\telif orientation == 2:\n\t\t\tif s == \"F\":\n\t\t\t\tx -= 1\n\t\t\telif s == \"L\":\n\t\t\t\ty -= 1\n\t\t\t\torientation = 3\n\t\t\telif s == \"R\":\n\t\t\t\ty += 1\n\t\t\t\torientation = 1\n\t\telif orientation == 3:\n\t\t\tif s == \"F\":\n\t\t\t\ty -= 1\n\t\t\telif s == \"L\":\n\t\t\t\tx += 1\n\t\t\t\torentation = 0\n\t\t\telif s == \"R\":\n\t\t\t\tx -= 1\n\t\t\t\torientation = 2\n\treturn (x, y)",
        "prompt": "return the coord of a turtle/drunk after it follows the string S, without using swampy. Has to follow foward/left/right instructions, while measuring displacement with (x, y)...",
        "task_id": "5288",
        "test_list": [
            "assert coord_finder('F10,R10,F10,L10,F10') == (10, 0)",
            "assert coord_finder('F10,F10,R90,F10,L90,F10') == (10, 0)",
            "assert coord_finder('F10,R10,F10,L10,F10,R10') == (10, 0)",
            "assert coord_finder('F5,R5,F5,L5,R90,F5,R90,F5') == (5, 5)",
            "assert coord_finder('R180,F10,R180,F10,R180,F10') == (0, 10)"
        ]
    },
    {
        "func_name": "__transform_coors",
        "code": "def __transform_coors(coor, i, j, xstride, ystride):\n    x1, y1, x2, y2 = coor\n\n    dx = x2 - x1\n    dy = y2 - y1\n    A = dx * dy\n\n    # Def some functions\n    def inframe(e, stride, n): return e // stride == n\n\n    def new_e(e, stride): return e % stride\n\n    if (inframe(x1, xstride, i) and inframe(y1, ystride, j)) \\\n       or (inframe(x2, xstride, i) and inframe(y2, ystride, j)):\n\n        if inframe(x1, xstride, i):\n            x1_prime = int(new_e(x1, xstride))\n        else:\n            x1_prime = 0\n\n        if inframe(y1, ystride, j):\n            y1_prime = int(new_e(y1, ystride))\n        else:\n            y1_prime = 0\n\n        if inframe(x2, xstride, i):\n            x2_prime = int(new_e(x2, xstride))\n        else:\n            x2_prime = xstride\n\n        if inframe(y2, ystride, j):\n            y2_prime = int(new_e(y2, ystride))\n        else:\n            y2_prime = ystride\n\n        dx_prime = x2_prime - x1_prime\n        dy_prime = y2_prime - y1_prime\n        A_prime = dx_prime * dy_prime\n\n        # Save the feature if the box is valid, and if the area of the box\n        # is at least 40% of the original object area\n        if (x2 > x1) and (y2 > y1) and (A_prime > .4 * A):\n            return (x1_prime, y1_prime, x2_prime, y2_prime)",
        "prompt": "Map coordinates into the new space Args coor i j",
        "task_id": "5615",
        "test_list": [
            "assert __transform_coors((10, 20, 30, 40), 1, 1, 5, 5) == (0, 0, 5, 5)",
            "assert __transform_coors((0, 0, 9, 9), 2, 2, 5, 5) == (0, 0, 4, 4)",
            "assert __transform_coors((0, 0, 10, 10), 1, 1, 5, 5) == (0, 0, 5, 5)",
            "assert __transform_coors((0, 0, 4, 4), 1, 1, 5, 5) == (0, 0, 4, 4)",
            "assert __transform_coors((0, 0, 9, 9), 1, 1, 5, 5) == (0, 0, 4, 4)"
        ]
    },
    {
        "func_name": "lumen_type",
        "code": "\ndef lumen_type(lumen_list, border_set, wild_list=[], mutants_list = [], wild_mutants_list=[], topology='hexagonal') :\n    l = {}\n    if topology == 'chain' :\n        for n in range(len(lumen_list)) :\n            l[n] = 'ICMmi'\n        return l\n    # if no mutants :\n    if len(mutants_list) == 0 :\n        for elem in range(len(lumen_list)) :\n            if elem in border_set :\n                s = 'TE'\n                if lumen_list[elem][1] == 1 :\n                    s += 'mi'\n                elif lumen_list[elem][1] == 3 :\n                    s += 'bi'\n                l[elem] = s\n            else :\n                s = 'ICM'\n                if lumen_list[elem][1] == 0 :\n                    s += 'mi'\n                elif lumen_list[elem][1] == 2 :\n                    s += 'bi'\n                l[elem] = s\n    \n    # if mutants :\n    else :\n        for elem in range(len(lumen_list)) :\n            if elem in border_set :\n                if elem in wild_list :\n                    l[elem] = 'TEmi'\n                elif elem in mutants_list :\n                    l[elem] = 'mutantsmi'\n                else :\n                    l[elem] = 'wild_mutantsmi'\n            else :\n                l[elem] = 'ICMmi'\n    return l\n",
        "prompt": "lumen_type(lumen_list, border_set, wild_list=[], mutants_list = [], wild_mutants_list=[]) Returns the type of each lumen Inputs",
        "task_id": "5634",
        "test_list": [
            "assert lumen_type([(0, 0), (1, 1), (2, 2), (3, 3)], {0, 1, 2, 3}, mutants_list=[], wild_mutants_list=[], topology='hexagonal') == {0: 'ICMmi', 1: 'ICMmi', 2: 'ICMmi', 3: 'ICMmi'}",
            "assert lumen_type([(0, 0), (1, 1), (2, 2), (3, 3)], {0, 1, 2, 3}, mutants_list=[3], wild_mutants_list=[2]) == {0: 'ICMmi', 1: 'ICMmi', 2: 'wild_mutantsmi', 3: 'mutantsmi'}",
            "assert lumen_type([(0, 0), (1, 1), (2, 2), (3, 3)], {0, 1, 2, 3}, mutants_list=[], wild_mutants_list=[2, 3]) == {0: 'ICMmi', 1: 'ICMmi', 2: 'wild_mutantsmi', 3: 'wild_mutantsmi'}",
            "assert lumen_type([(0, 0), (1, 1), (2, 2)], {0, 1}, wild_list=[2]) == {0: 'ICMmi', 1: 'ICMmi', 2: 'TEmi'}",
            "assert lumen_type([(0, 0), (1, 1), (2, 2), (3, 3)], {0, 1, 2, 3}, mutants_list=[], wild_mutants_list=[], topology='chain') == {0: 'ICMmi', 1: 'ICMmi', 2: 'ICMmi', 3: 'ICMmi'}"
        ]
    },
    {
        "func_name": "judge_1d100_with_7_ver",
        "code": "\nimport math\n\ndef judge_1d100_with_7_ver(target: int, dice: int, difficult: str):\n    if dice > target:\n        if dice >= 96:\n            return \"\u30d5\u30a1\u30f3\u30d6\u30eb\", \"COLOR_FUMBLE\"\n        return \"\u5931\u6557\", \"COLOR_FAILURE\"\n    elif dice > math.floor(target / 2) and difficult == \"H\":\n        if dice >= 96:\n            return \"\u30d5\u30a1\u30f3\u30d6\u30eb\", \"COLOR_FUMBLE\"\n        return \"\u5931\u6557\", \"COLOR_FAILURE\"\n    elif dice > math.floor(target / 5) and difficult == \"E\":\n        if dice >= 96:\n            return \"\u30d5\u30a1\u30f3\u30d6\u30eb\", \"COLOR_FUMBLE\"\n        return \"\u5931\u6557\", \"COLOR_FAILURE\"\n\n    if dice <= math.floor(target / 5):\n        return \"\u30a4\u30af\u30b9\u30c8\u30ea\u30fc\u30e0\", \"COLOR_CRITICAL\"\n    elif dice <= math.floor(target / 2):\n        return \"\u30cf\u30fc\u30c9\", \"COLOR_SUCCESS\"\n\n    return \"\u6210\u529f\", \"COLOR_NORMAL_SUCCESS\"\n",
        "prompt": "Judge 1d100 dice result, and return text and color for message. Result is critical, success, failure or fumble.",
        "task_id": "5754",
        "test_list": [
            "assert judge_1d100_with_7_ver(50, 30, 'E') == ('\u30cf\u30fc\u30c9', 'COLOR_SUCCESS')",
            "assert judge_1d100_with_7_ver(25, 10, 'E') == ('\u30a4\u30af\u30b9\u30c8\u30ea\u30fc\u30e0', 'COLOR_CRITICAL')",
            "assert judge_1d100_with_7_ver(100, 95, 'H') == ('\u30d5\u30a1\u30f3\u30d6\u30eb', 'COLOR_FUMBLE')",
            "assert judge_1d100_with_7_ver(50, 75, 'E') == ('\u5931\u6557', 'COLOR_FAILURE')",
            "assert judge_1d100_with_7_ver(100, 50, 'H') == ('\u6210\u529f', 'COLOR_NORMAL_SUCCESS')"
        ]
    },
    {
        "func_name": "ratioLimits",
        "code": "def ratioLimits(numerator, denominator, mode='yaxis'):\n    limits = []\n    for i in range(len(numerator)):\n\n        # In \"Y-Axis\" notation\n        if mode == 'yaxis':\n            if numerator[i] == '^v' or denominator[i] == '^v':\n                limits += ['^v']\n\n            if numerator[i] == 'v' and denominator[i] == 'v':\n                limits += ['^v']\n            if numerator[i] == '^' and denominator[i] == '^':\n                limits += ['^v']\n\n            if numerator[i] == '^' and denominator[i] == 'v':\n                 limits += ['^']\n            if numerator[i] == 'v' and denominator[i] == '^':\n                 limits += ['v']\n\n            if numerator[i] == '^' and denominator[i] == 'o':\n                limits += ['^']\n            if numerator[i] == 'o' and denominator[i] == '^':\n                limits += ['v']\n\n            if numerator[i] == 'v' and denominator[i] == 'o':\n                limits += ['v']\n            if numerator[i] == 'o' and denominator[i] == 'v':\n                limits += ['^']\n            if numerator[i] == 'o' and denominator[i] == 'o':\n                limits += ['o']\n\n        if mode == 'text':\n            if numerator[i] == '^v' or denominator[i] == '^v':\n                limits += ['^v']\n\n            if numerator[i] == '<' and denominator[i] == '<':\n                limits += ['^v']\n            if numerator[i] == '>' and denominator[i] == '>':\n                limits += ['^v']\n\n            if numerator[i] == '>' and denominator[i] == '<':\n                 limits += ['>']\n            if numerator[i] == '<' and denominator[i] == '>':\n                 limits += ['<']\n\n            if numerator[i] == '>' and denominator[i] == 'o':\n                limits += ['>']\n            if numerator[i] == 'o' and denominator[i] == '>':\n                limits += ['<']\n\n            if numerator[i] == '<' and denominator[i] == 'o':\n                limits += ['<']\n            if numerator[i] == 'o' and denominator[i] == '<':\n                limits += ['>']\n\n            if numerator[i] == 'o' and denominator[i] == 'o':\n                limits += ['o']\n    return limits",
        "prompt": "r\"\"\" Evaluation of upper/lower limits when building the ratio of two values with limits.",
        "task_id": "5943",
        "test_list": [
            "assert ratioLimits(['^', 'v', 'o', 'v', 'o'], ['^', 'v', 'o', 'v', 'o'], mode='yaxis') == ['^', 'v', 'o', 'v', 'o']",
            "assert ratioLimits(['^', 'v', 'o'], ['^', 'v', 'o'], mode='text') == ['^', 'v', 'o']",
            "assert ratioLimits(['^', 'v', 'o', 'v', 'o'], ['^', 'v', 'o', 'o', 'v'], mode='text') == ['^', 'v', 'o', 'o', 'v']",
            "assert ratioLimits(['^', 'v', 'o', 'v', 'o'], ['v', 'o', 'o', 'v', 'v'], mode='yaxis') == ['^', 'v', 'o', 'v', 'v']",
            "assert ratioLimits(['^', 'v', 'o'], ['v', 'o', 'o']) == ['^', 'v', 'o']"
        ]
    },
    {
        "func_name": "_piecewise",
        "code": "def _piecewise(a):\n        b = [\n            (\n                a[2 * i]\n                .replace(\"\u5c0f\u4e8e\", \"\")\n                .replace(\"\u5927\u4e8e\", \"\")\n                .replace(\"\u7b49\u4e8e\", \"\")\n                .replace(\"\u4e2a\", \"\")\n            ).split(\"\uff0c\")\n            for i in range(int(len(a) / 2))\n        ]\n        for j, tem in enumerate(b):\n            for i, num in enumerate(tem):\n                if num[-1] == \"\u5929\":\n                    num = int(num[:-1])\n                elif num[-1] == \"\u6708\":\n                    num = int(num[:-1]) * 30\n                else:\n                    num = int(num[:-1]) * 365\n                b[j][i] = num\n        if len(b[0]) == 1:  # \u6709\u65f6\u8d4e\u56de\u8d39\u4f1a\u5199\u5927\u4e8e\u7b49\u4e8e\u4e00\u5929\n            b[0].insert(0, 0)\n        elif len(b[0]) == 2:\n            b[0][0] = 0\n        else:\n            print(_warnmess)\n        for i in range(len(b) - 1):  # \u6709\u65f6\u8d4e\u56de\u8d39\u4e24\u533a\u95f4\u90fd\u662f\u95ed\u533a\u95f4\n            if b[i][1] - b[i + 1][0] == -1:\n                b[i][1] = b[i + 1][0]\n            elif b[i][1] == b[i + 1][0]:\n                pass\n            else:\n                print(_warnmess)\n\n        return b",
        "prompt": "Transform the words list into a pure number segment list for redemption fee, eg. [[0,7],[7,365],[365]]",
        "task_id": "6012",
        "test_list": [
            "assert _piecewise(['\u5927\u4e8e0\u5e74', '\u5c0f\u4e8e1\u5e74', '\u7b49\u4e8e0\u5e74']) == [[0, 365], [365, 365], [365, 365]]",
            "assert _piecewise(['\u5927\u4e8e0\u5e74', '\u5927\u4e8e0\u5e74', '\u5927\u4e8e0\u5e74']) == [[0, 365], [365, 365], [365, 365]]",
            "assert _piecewise(['\u5c0f\u4e8e0\u5929', '\u5927\u4e8e7\u5929', '\u7b49\u4e8e365\u5929']) == [[0, 7], [7, 365], [365]]",
            "assert _piecewise(['\u5927\u4e8e0\u4e2a\u6708', '\u5c0f\u4e8e1\u4e2a\u6708', '\u7b49\u4e8e0\u4e2a\u6708']) == [[0, 30], [30, 30], [30, 365]]",
            "assert _piecewise(['\u5927\u4e8e0\u5e74', '\u5c0f\u4e8e1\u5e74', '\u5927\u4e8e0\u5e74']) == [[0, 365], [365, 365], [365, 365]]"
        ]
    },
    {
        "func_name": "tr_tet_tr_oct_cubo_coord_test",
        "code": "def tr_tet_tr_oct_cubo_coord_test(x, y, z):  # dist2 = 4\n    x = abs(x) % 6\n    y = abs(y) % 6\n    z = abs(z) % 6\n    if x > 3:\n        x = 6-x\n    if y > 3:\n        y = 6-y\n    if z > 3:\n        z = 6-z\n    dist2 = x**2 + y**2\n    return ((z % 6 == 0 and (dist2 == 2 or dist2 == 8)) or\n            (z % 6 == 1 and (dist2 == 1 or dist2 == 13)) or\n            (z % 6 == 2 and (dist2 == 4 or dist2 == 10)) or\n            (z % 6 == 3 and dist2 == 5))",
        "prompt": "Test for coordinate in truncated tetrahedron/truncated octahedron/ cuboctahedron grid",
        "task_id": "6025",
        "test_list": [
            "assert tr_tet_tr_oct_cubo_coord_test(5, 1, 3) == True",
            "assert tr_tet_tr_oct_cubo_coord_test(4, 4, 4) == True",
            "assert tr_tet_tr_oct_cubo_coord_test(0, 0, 0) == False",
            "assert tr_tet_tr_oct_cubo_coord_test(2, 2, 0) == True",
            "assert tr_tet_tr_oct_cubo_coord_test(3, 3, 3) == True"
        ]
    },
    {
        "func_name": "convert_operand_kind",
        "code": "def convert_operand_kind(operand_tuple):\n    kind, quantifier = operand_tuple\n    # The following cases are where we differ between the JSON grammar and\n    # spirv-tools.\n    if kind == 'IdResultType':\n        kind = 'TypeId'\n    elif kind == 'IdResult':\n        kind = 'ResultId'\n    elif kind == 'IdMemorySemantics' or kind == 'MemorySemantics':\n        kind = 'MemorySemanticsId'\n    elif kind == 'IdScope' or kind == 'Scope':\n        kind = 'ScopeId'\n    elif kind == 'IdRef':\n        kind = 'Id'\n\n    elif kind == 'ImageOperands':\n        kind = 'Image'\n    elif kind == 'Dim':\n        kind = 'Dimensionality'\n    elif kind == 'ImageFormat':\n        kind = 'SamplerImageFormat'\n    elif kind == 'KernelEnqueueFlags':\n        kind = 'KernelEnqFlags'\n\n    elif kind == 'LiteralExtInstInteger':\n        kind = 'ExtensionInstructionNumber'\n    elif kind == 'LiteralSpecConstantOpInteger':\n        kind = 'SpecConstantOpNumber'\n    elif kind == 'LiteralContextDependentNumber':\n        kind = 'TypedLiteralNumber'\n\n    elif kind == 'PairLiteralIntegerIdRef':\n        kind = 'LiteralIntegerId'\n    elif kind == 'PairIdRefLiteralInteger':\n        kind = 'IdLiteralInteger'\n    elif kind == 'PairIdRefIdRef':  # Used by OpPhi in the grammar\n        kind = 'Id'\n\n    if kind == 'FPRoundingMode':\n        kind = 'FpRoundingMode'\n    elif kind == 'FPFastMathMode':\n        kind = 'FpFastMathMode'\n\n    if quantifier == '?':\n        kind = 'Optional{}'.format(kind)\n    elif quantifier == '*':\n        kind = 'Variable{}'.format(kind)\n\n    return 'SPV_OPERAND_TYPE_{}'.format(\n        re.sub(r'([a-z])([A-Z])', r'\\1_\\2', kind).upper())",
        "prompt": "Returns the corresponding operand type used in spirvtools for the given operand kind and quantifier used in the JSON grammar.",
        "task_id": "6054",
        "test_list": [
            "assert convert_operand_kind(('Dim', '*')) == 'SPV_OPERAND_TYPE_DIMENSIONALITY_VARIABLE'",
            "assert convert_operand_kind(('IdScope', '*')) == 'SPV_OPERAND_TYPE_SCOPEID_VARIABLE'",
            "assert convert_operand_kind(('ImageFormat', '*')) == 'SPV_OPERAND_TYPE_SAMPLERIMAGEFORMAT_VARIABLE'",
            "assert convert_operand_kind(('LiteralSpecConstantOpInteger', '?')) == 'SPV_OPERAND_TYPE_SPECCONSTANTOPNUMBER_OPTIONAL'",
            "assert convert_operand_kind(('IdResult', '?')) == 'SPV_OPERAND_TYPE_IDRESULT_OPTIONAL'"
        ]
    },
    {
        "func_name": "get_highest_density_window",
        "code": "\ndef get_highest_density_window(document_words, terms, size=5):\n    document_size = len(document_words)\n\n    count = 0\n    high_count = 0\n    start_index = read_start = 0\n    end_index = read_end = start_index + size - 1\n\n    if document_size < size:\n        return (start_index, document_size, 0)\n\n    re = {}\n    for i in range(read_start, read_end):\n        dq = document_words[i]\n        if dq in terms:\n            if dq in re:\n                count += 0.01\n                high_count += 0.01\n                continue\n            count += 1\n            high_count += 1\n            re[dq] = 1\n\n    read_start += 1\n    read_end += 1\n\n    while read_end < document_size:\n        re = {}\n        count = 0\n        for i in range(read_start, read_end):\n            dq = document_words[i]\n            if dq in terms:\n                if dq in re:\n                    count += 0.01\n                    continue\n                count += 1\n                re[dq] = 1\n\n        if count > high_count:\n            high_count = count\n            start_index = read_start\n            end_index = read_end\n\n        read_start += 1\n        read_end += 1\n\n    return (start_index, end_index + 1, high_count)\n",
        "prompt": "Given a list of positions in a corpus, returns the shortest span of words that contain all query terms >>> get_highest_density_window('this case is a good test', 'test case', size=5) (1, 6)",
        "task_id": "6182",
        "test_list": [
            "assert get_highest_density_window(['apple', 'banana', 'cherry', 'date', 'apple', 'banana', 'cherry', 'date', 'apple', 'banana'], ['kiwi', 'mango'], size=5) == (0, 0)",
            "assert get_highest_density_window(['this', 'case', 'is', 'a', 'good', 'test', 'case', 'is', 'a', 'good', 'test'], ['test', 'case'], size=5) == (1, 6)",
            "assert get_highest_density_window(['apple', 'banana', 'cherry', 'date', 'apple', 'banana', 'cherry', 'date', 'apple', 'banana'], ['apple', 'banana'], size=3) == (0, 3)",
            "assert get_highest_density_window(['apple', 'banana', 'cherry', 'date', 'apple', 'banana', 'cherry', 'date', 'apple', 'banana'], ['apple', 'banana', 'cherry', 'date'], size=10) == (0, 9)",
            "assert get_highest_density_window(['apple', 'banana', 'cherry', 'date', 'apple', 'banana', 'cherry', 'date', 'apple', 'banana'], ['apple', 'banana', 'cherry'], size=5) == (0, 5)"
        ]
    },
    {
        "func_name": "annotate_descr",
        "code": "def annotate_descr(s):\n\n\t# Host:\n\tif(re.search('\\s18s', s, re.I) != None \n\t\tor re.search('\\s5s', s, re.I) != None\n\t\tor re.search('ribosomal', s, re.I) != None\n\t\tor re.search('its1', s, re.I) != None\n\t\tor re.search('its2', s, re.I) != None \n\t\tor re.search('internal', s, re.I) != None\n\t\tor re.search('\\s45s', s, re.I) != None):\n\t\treturn ['HOST', 'NA', 'NA']\n\n\t# Superfamily match:\n\tif(re.search('gypsy', s, re.I) != None\n\t\tor re.search( 'ty3', s, re.I) != None\n\t\tor re.search( 'cinful', s, re.I) != None\n\t\tor re.search( 'grande', s, re.I) != None\n\t\tor re.search( '\\ssmilt', s, re.I) != None\n\t\tor re.search( '\\sshuck', s, re. I) != None):\n\t\treturn ['1', 'LTR', 'GYPSY']\n\n\telif(re.search('copia', s, re.I) != None \n\t\tor re.search('ty1', s, re.I) != None\n\t\tor re.search('\\sji', s, re.I) != None\n\t\tor re.search('\\sopie', s, re.I) != None\n\t\tor re.search('hopscotch', s, re.I) != None\n\t\tor re.search('\\ssire', s, re.I) != None\n\t\tor re.search('\\ssto', s, re.I) != None):\n\t\treturn ['1', 'LTR', 'COPIA']\n\n\telif(re.search('angela', s, re.I) != None):\n\t\treturn ['1', 'LTR', 'ANGELA']\n\n\telif(re.search('athila', s, re.I) != None):\n\t\treturn ['1', 'LTR', 'ATHILA']\n\n\telif(re.search('retrolyc1', s, re.I ) != None):\n\t\treturn ['1', 'RETRO', 'RETROLYC1']\n\n\telif( re.search( 'tip100', s, re.I ) != None\n\t\tor re.search( 'tip201', s, re.I ) != None\n\t\tor re.search( 'dihydroflavonol', s, re.I ) != None\n\t\tor re.search( 'activator', s, re.I ) != None\n\t\tor re.search( 'Ac-Ds', s, re.I ) != None\n\t\tor re.search( 'AcDs', s, re.I ) != None\n\t\tor re.search( 'Ac/Ds', s, re.I ) != None ):\n\t\treturn ['2', 'TIR', 'ACDS']\n\n\telif(re.search('tpn1', s, re.I ) != None\n\t\tor re.search('en/spm', s, re.I) != None\n\t\tor re.search('en-spm', s, re.I) != None\n\t\tor re.search('enspm', s, re.I) != None\n\t\tor re.search('\\sspm', s, re.I) != None):\n\t\treturn ['2', 'TIR', 'ENSPM']\n\n\telif(re.search('cacta', s, re.I) != None):\n\t\treturn ['2', 'TIR', 'CACTA']\n\n\telif(re.search('tourist', s, re.I) != None):\n\t\treturn ['2', 'TIR', 'PIF/HARBRINGER']\n\telif(re.search( '\\sshat', s, re.I) != None):\n\t\treturn ['2', 'TIR', 'HAT']\n\n\telif(re.search( 'mite', s, re.I) != None\n\t\tor re.search( 'mite-adh', s, re.I) != None):\n\t\treturn ['2', 'TIR', 'MITE']\n\n\telif(re.search('helitron', s, re.I) != None):\n\t\treturn ['2', 'HELITRON', 'HELITRON']\n\n\t# Order match:\n\tif(re.search('endonuclease', s, re.I) != None\n\t\tor re.search( '\\sline\\s', s, re.I) != None ):\n\t\treturn ['1', 'LINE', 'NA']\n\telif(re.search( '\\ssine\\s', s, re.I) != None ):\n\t\treturn ['1', 'SINE', 'NA']\n\telif(re.search('\\sgag\\s', s, re.I) != None \n\t\tor re.search('retroposon', s, re.I) != None\n\t\tor re.search('retrotransposon', s, re.I) != None\n\t\tor re.search('retrotransposon-like', s, re.I) != None\n\t\tor re.search('transcriptase-like', s, re.I) != None\n\t\tor re.search('polyprotein', s, re.I) != None \n\t\tor re.search('reverse transcriptase', s, re.I) != None\n\t\tor re.search('\\sbare', s, re.I) != None\n\t\tor re.search('sukkula', s, re.I) != None\n\t\tor re.search('leviathan', s, re.I) != None):\n\t\treturn ['1', 'LTR', 'NA']\n\telif(re.search('terminal repeat', s, re.I) != None\n\t\tor re.search('transposase', s, re.I) != None\n\t\tor re.search('tetn02', s, re.I) != None \n\t\tor re.search(' mariner', s, re.I) != None ):\n\t\treturn ['2', 'TIR', 'NA']\n\n\treturn ['NA', 'NA', 'NA']",
        "prompt": "Annotates TE based on BLAST description.",
        "task_id": "6369",
        "test_list": [
            "assert annotate_descr('internal ribosomal transposon') == ['HOST', 'NA', 'NA']",
            "assert annotate_descr('copia retrotransposon') == ['1', 'LTR', 'COPIA']",
            "assert annotate_descr('gypsy retrotransposon') == ['1', 'LTR', 'GYPSY']",
            "assert annotate_descr('Ac-Ds transposase') == ['2', 'TIR', 'ACDS']",
            "assert annotate_descr('retrolyc1 retrotransposon') == ['1', 'RETRO', 'RETROLYC1']"
        ]
    },
    {
        "func_name": "convert_to_letter_month",
        "code": "def convert_to_letter_month(some_date):\n    \n    some_date_str = str(some_date)\n    \n    dd = some_date_str[-2:]\n    yyyy = some_date_str[:4]\n\n    mm = some_date_str[5:7]\n\n    if mm == \"01\":\n        mm = \"Jan\"\n    elif mm == \"02\":\n        mm = \"Feb\"\n    elif mm == \"03\":\n        mm = \"Mar\"\n    elif mm == \"04\":\n        mm = \"Apr\"\n    elif mm == \"05\":\n        mm = \"May\"\n    elif mm == \"06\":\n        mm = \"Jun\"   \n    elif mm == \"07\":\n        mm = \"Jul\"\n    elif mm == \"08\":\n        mm = \"Aug\"\n    elif mm == \"09\":\n        mm = \"Sep\"\n    elif mm == \"10\":\n        mm = \"Oct\"\n    elif mm == \"11\":\n        mm = \"Nov\"\n    elif mm == \"12\":\n        mm = \"Dec\"\n\n    return dd + \" \" + mm + \" \" + yyyy",
        "prompt": "some_date in format yyyymmdd converted to string ddAPRyyyy and returned",
        "task_id": "6375",
        "test_list": [
            "assert convert_to_letter_month('20210304') == '03 Mar 2021'",
            "assert convert_to_letter_month('20200915') == '09 Sep 2020'",
            "assert convert_to_letter_month('20200401') == '04 Apr 2020'",
            "assert convert_to_letter_month('20200704') == '07 Jul 2020'",
            "assert convert_to_letter_month('20201231') == '12 Dec 2021'"
        ]
    },
    {
        "func_name": "unmet_compare",
        "code": "\nNO_NEW = 0\nPKG_TRADED_UNMET = 1\nPKG_NEW_UNMET = 2\nTRADED_PKG = 3\nNEW_PKG = 4\n\ndef unmet_compare(cur, new):\n    def set_dif_msg(n, c):\n        return ' '.join([pkg for pkg in n if not pkg in c])\n\n    def stringify_unmet_entry(pkg, unmet):\n        depended_upon_things = ', '.join(unmet[pkg])\n        return \"%s depends on %s \" % (pkg, depended_upon_things)\n\n    def list_new_entries(new, cur):\n        return [stringify_unmet_entry(pkg, new)\n                for pkg in new if not pkg in cur]\n    \n    if len(new) > len(cur):\n        new_prob_msg = 'New packages with dependency problems \\n\\t ' \\\n                       + '\\n\\t'.join(list_new_entries(new, cur))\n        return (NEW_PKG, new_prob_msg)\n    elif len(new) == len(cur):\n        for new_problem in new:\n            if not new_problem in cur:\n                new_probs = set_dif_msg(new, cur)\n                gone_probs = set_dif_msg(cur, new)\n                msg = \"Solved some dependency problems, but created others\\nNew problems are \\n\\t%s\\nOld problems were \\n\\t%s\" % (\n                    '\\n\\t'.join(list_new_entries(new, cur)),\n                    '\\n\\t'.join(list_new_entries(cur, new)))\n                                \n                return (TRADED_PKG, msg)\n\n        for new_problem in new:\n            if len(new[new_problem]) > len(cur[new_problem]):\n                msg = \"Package %s gained new dependency %s \" % (\n                    new_problem,set_dif_msg(new[new_problem],cur[new_problem]))\n                return (PKG_NEW_UNMET, msg)\n\n        for new_problem in new:\n            for new_unmet_dep in new[new_problem]:\n                if not new_unmet_dep in cur[new_problem]:\n                    new_prob_list = new[new_problem]\n                    cur_prob_list = cur[new_problem]\n                    new_probs = set_dif_msg(new_prob_list, cur_prob_list)\n                    gone_probs = set_dif_msg(cur_prob_list, new_prob_list)\n                    msg = \"%s swapped unmet dependencies\\n\\tgained %s\\n\\tlost %s\" % (\n                        new_problem, new_probs, gone_probs)\n                    return (PKG_TRADED_UNMET, msg)\n\n    return (NO_NEW, 'No new dependency problems')\n",
        "prompt": "See changes in the dependency problems between the current and new cur dependency problem info formatted like return of unmet new same format as current (code, description) where code is and integer of increasing value for increasing dependency badness, and description is a string containing some message about the problem Values for code, in increasing badness order NO_NEW for no new dependency problems PKG_TRADED_UNMET for when a package with a dependency problem in current also has a dependency problem in new, except that it is a different dependency PKG_NEW_UNMET for when a package with a dependency problem in current gains a new unmet dependency TRADED_PKG for when a package that used to be a dependency problem in current is now gone, but a package that did not have a problem in current has one in new NEW_PKG for when there are more packages with dependency problems in new than in current",
        "task_id": "6496",
        "test_list": [
            "assert unmet_compare([{'a': ['b', 'c']}], [{'a': ['b', 'c'], 'b': ['c']}]) == (PKG_TRADED_UNMET, 'Package a swapped unmet dependencies\\tgained b\\tlost c')",
            "assert unmet_compare([{'a': ['b', 'c']}], [{'a': ['b', 'c'], 'b': ['c', 'd'], 'c': ['d']}]) == (PKG_TRADED_UNMET, 'Package b swapped unmet dependencies\\tgained d\\tlost c')",
            "assert unmet_compare([{'a': ['b', 'c']}], [{'a': ['b', 'c'], 'b': ['c', 'd'], 'c': ['d', 'e']}]) == (PKG_TRADED_UNMET, 'Package b swapped unmet dependencies\\tgained d\\tlost c')",
            "assert unmet_compare([], [{'a': ['b', 'c']}, {'b': ['c']}]) == (NO_NEW, 'No new dependency problems')",
            "assert unmet_compare([{'a': ['b', 'c']}], [{'a': ['b', 'c'], 'b': ['c', 'd']}]) == (PKG_NEW_UNMET, 'Package b gained new dependency d')"
        ]
    },
    {
        "func_name": "convolution_size",
        "code": "def convolution_size(\n    given_size, num_layers, kernel_sizes, padding=0, strides=1, dilations=1,\n    inverse=False\n):\n    if type(kernel_sizes) is int:\n        kernel_sizes = [kernel_sizes] * num_layers\n    else:\n        assert len(kernel_sizes) == num_layers\n    if type(padding) is int:\n        padding = [padding] * num_layers\n    else:\n        assert len(padding) == num_layers\n    if type(strides) is int:\n        strides = [strides] * num_layers\n    else:\n        assert len(strides) == num_layers\n    if type(dilations) is int:\n        dilations = [dilations] * num_layers\n    else:\n        assert len(dilations) == num_layers\n\n    size = given_size\n\n    if not inverse:\n        for i in range(num_layers):\n            size = int(\n                (size + (2 * padding[i]) - (dilations[i] * (kernel_sizes[i] - 1)) \\\n                 - 1) / strides[i]\n            ) + 1\n    else:\n        for i in range(num_layers - 1, -1, -1):\n            size = (strides[i] * (size - 1)) - (2 * padding[i]) + \\\n                   (dilations[i] * (kernel_sizes[i] - 1)) + 1\n    return size",
        "prompt": "Computes the size of the convolutional output after applying several layers of convolution to an input of a given size. Alternatively, this can also compute the size of a convolutional input needed to create the given size for an output.",
        "task_id": "6645",
        "test_list": [
            "assert convolution_size(128, 4, [3, 3, 3, 3], padding=1, strides=1, dilations=1, inverse=True) == 128",
            "assert convolution_size(256, 2, [7, 7], padding=0, strides=1, dilations=1, inverse=False) == 256",
            "assert convolution_size(64, 3, [5, 5, 5], padding=2, strides=2, dilations=1) == 64",
            "assert convolution_size(32, 2, [3, 3], padding=1, strides=1, dilations=1) == 32",
            "assert convolution_size(512, 3, [3, 3, 3], padding=[1, 1, 1], strides=[1, 1, 1], dilations=[1, 1, 1], inverse=False) == 512"
        ]
    },
    {
        "func_name": "stoprec_analysis_rltnshp",
        "code": "def stoprec_analysis_rltnshp(stoprecrange, analysisrange):\n    rec_in = stoprecrange[0]\n    rec_out = stoprecrange[1]\n    a_start = analysisrange[0]\n    a_end = analysisrange[1]\n    \n    if (rec_in > rec_out):\n        return 'backwards'\n    elif (a_start <= rec_in < a_end) and (a_start <= rec_out < a_end):\n        return 'inner'\n    elif (a_start <= rec_in < a_end) and (rec_out >= a_end):\n        return 'right'\n    elif (rec_in < a_start) and (a_start <= rec_out < a_end):\n        return 'left'\n    elif (rec_in < a_start) and (rec_out >= a_end):\n        return 'outer'\n    else:\n        return 'none'",
        "prompt": "Determines relationship type of stop record to analysis date range.",
        "task_id": "7062",
        "test_list": [
            "assert stoprec_analysis_rltnshp((20201231, 20200101), (20201231, 20201231)) == 'outer'",
            "assert stoprec_analysis_rltnshp((20200101, 20201231), (20200201, 20201231)) == 'inner'",
            "assert stoprec_analysis_rltnshp((20200101, 20201231), (20200101, 20201231)) == 'none'",
            "assert stoprec_analysis_rltnshp((20201231, 20200101), (20200201, 20201231)) == 'left'",
            "assert stoprec_analysis_rltnshp((20200101, 20201231), (20200301, 20201231)) == 'right'"
        ]
    },
    {
        "func_name": "rformat",
        "code": "def rformat(obj, indent=0, name=None, width=90, **kArgs):\n  #print(\" kArgs: %s\" % kArgs)\n  try:\n    kArgs['depth'] -= 1\n  except:\n    kArgs['depth'] = 100\n  if kArgs['depth']==0: \n    print(indent*\"  \"+\"...\")\n    return\n\n  \n  ss = repr(obj)\n  if len(ss)<width-indent*2:\n    #print(\"%s --%d %s\" % (name, len(ss), ss))\n    ss = indent*\"  \"+ss\n    \n  else:  # expression is too long, break it down\n    ss = \"\"\n    objType = type(obj)\n    #print(\"%s ++%s\" % (name, str(objType)))\n    if objType==list:\n      ss = \"\"\n      for it in obj:\n        ss += rformat(it, indent+1, width=width, **kArgs)+',\\n'\n      if ss[-2:] == \",\\n\":  ss = ss[:-2]+'\\n'\n      ss = indent*\"  \"+\"[\\n\"+ ss +indent*\"  \"+\"]\"\n      \n    elif objType==tuple:\n      ss += indent*\"  \"+\"(\\n\"\n      for it in obj:\n        ss += rformat(it, indent+1, width=width, **kArgs)+',\\n'\n      if ss[-2:] == \",\\n\":  ss = ss[:-2]+'\\n'\n      ss += indent*\"  \"+\")\"\n      \n    elif objType==dict or objType==bunch: # or objType==bun:\n      if objType==dict:\n        startTag = \"{\";  sep = \":\";  endTag = \"}\"\n      else:\n        startTag = \"bunch(\";  sep = \"=\";  endTag = \")\"\n        \n      ss += indent*\"  \"+startTag+\"\\n\"\n      for it in obj:\n        ss += indent*\"  \"+\"  \"+str(it)+sep+\" \"+rformat(obj[it],\n          indent+1, name=it, width=width, **kArgs).strip()+',\\n'\n      if ss[-2:] == \",\\n\":  ss = ss[:-2]+'\\n'\n      ss += indent*\"  \"+endTag\n    else:    \n      ss += indent*\"  \"+repr(obj)\n  return ss",
        "prompt": "ribo's format, converts an obj (a nesting of lists, tuples and dicts) into an indented, multiline string which is more readable",
        "task_id": "7069",
        "test_list": [
            "assert rformat([1, 2, 3]) == '  [\\n    1,\\n    2,\\n    3\\n  ]'",
            "assert rformat({'a': 1, 'b': {'c': 2, 'd': 3}, 'e': [4, 5], 'f': (6, 7)}) == '  {\\n    a: 1,\\n    b: {\\n      c: 2,\\n      d: 3\\n    },\\n    e: [\\n      4,\\n      5\\n    ],\\n    f: (\\n      6,\\n      7\\n    )\\n  }'",
            "assert rformat({'a': 1, 'b': {'c': 2, 'd': 3}, 'e': [4, 5], 'f': (6, 7), 'g': {'h': 8, 'i': 9}}) == '  {\\n    a: 1,\\n    b: {\\n      c: 2,\\n      d: 3\\n    },\\n    e: [\\n      4,\\n      5\\n    ],\\n    f: (\\n      6,\\n      7\\n    ),\\n    g: {\\n      h: 8,\\n      i: 9\\n    }\\n  }'",
            "assert rformat({'a': 1, 'b': {'c': 2, 'd': 3}, 'e': [4, 5]}) == '  {\\n    a: 1,\\n    b: {\\n      c: 2,\\n      d: 3\\n    },\\n    e: [\\n      4,\\n      5\\n    ]\\n  }'",
            "assert rformat([1, 2, 3, 4, 5]) == '  [\\n    1,\\n    2,\\n    3,\\n    4,\\n    5\\n  ]'"
        ]
    },
    {
        "func_name": "getLCCoeff",
        "code": "def getLCCoeff():\n    \n    lc_coeff_r_0 = {2: [(5, 0)],\n                    3: [(5, 0)],\n                    4: [(5, 0)]}\n\n    lc_coeff_r_1 = {2: [(5, 2), (5, 0)],\n                    3: [(5, 7), (5, 3)],\n                    4: [(5, 4), (5, 12)]}\n\n    lc_coeff_r_2 = {2: [(5, i) for i in range(4)],\n                    3: [(5, 2*i) for i in range(8)],\n                    4: [(5, 4*i) for i in range(16)]}\n    \n    lc_coeff_r_3 = {3: [(5, i) for i in range(8)],\n                    4: [(5, 2*i) for i in range(16)]}\n    \n    lc_coeff_r_4 = {4: [(5, i) for i in range(16)],\n                    5: [(5, 2*i) for i in range(32)]}\n    \n    lc_coeff_r_5 = {5: [(5, i) for i in range(32)],\n                    6: [(5, 2*i) for i in range(64)]}\n    \n    lc_coeff_r_6 = {6: [(5, i) for i in range(64)],\n                    7: [(5, 2*i) for i in range(128)]}\n    \n    lc_coeff_r_7 = {7: [(5, i) for i in range(128)],\n                    8: [(5, 2*i) for i in range(256)]}\n    \n    lc_coeff = {0: lc_coeff_r_0, 1: lc_coeff_r_1, 2: lc_coeff_r_2, 3: lc_coeff_r_3,\n                4: lc_coeff_r_4, 5: lc_coeff_r_5, 6: lc_coeff_r_6,\n                7: lc_coeff_r_7}\n    \n    return lc_coeff",
        "prompt": "Label generating LC coefficients for various rates and memory sizes",
        "task_id": "7120",
        "test_list": [
            "assert getLCCoeff()[2][2] == [(5, 0), (5, 2), (5, 4)]",
            "assert getLCCoeff()[4][4] == [(5, 8), (5, 16), (5, 24)]",
            "assert getLCCoeff()[5][5] == [(5, 16), (5, 32), (5, 48)]",
            "assert getLCCoeff()[3][3] == [(5, 7), (5, 11), (5, 15)]",
            "assert getLCCoeff()[6][6] == [(5, 32), (5, 64), (5, 96)]"
        ]
    },
    {
        "func_name": "reduce_base",
        "code": "\ndef reduce_base(k, base):\n    if k in base:\n        return 0, base\n    grade = len(base)\n    if grade == 1:\n        if k < base[0]:\n            return 1, [k, base[0]]\n        else:\n            return -1, [base[0], k]\n    ilo = 0\n    ihi = grade - 1\n    if k < base[0]:\n        return 1, [k] + base\n    if k > base[ihi]:\n        if grade % 2 == 0:\n            return 1, base + [k]\n        else:\n            return -1, base + [k]\n    imid = ihi + ilo\n    if grade == 2:\n        return -1, [base[0], k, base[1]]\n    while True:\n        if ihi - ilo == 1:\n            break\n        if base[imid] > k:\n            ihi = imid\n        else:\n            ilo = imid\n        imid = (ilo + ihi) // 2\n    if ilo % 2 == 1:\n        return 1, base[:ihi] + [k] + base[ihi:]\n    else:\n        return -1, base[:ihi] + [k] + base[ihi:]\n",
        "prompt": "If base is a list of sorted integers [i_1,...,i_R] then reduce_base sorts the list [k,i_1,...,i_R] and calculates whether an odd or even number of permutations is required to sort the list. The sorted list is returned and +1 for even permutations or 1 for odd permutations.",
        "task_id": "7262",
        "test_list": [
            "assert reduce_base(5, [1, 3, 4]) == (1, [1, 3, 4, 5])",
            "assert reduce_base(3, [1, 2, 4]) == (1, [1, 2, 3, 4])",
            "assert reduce_base(4, [1, 2, 3]) == (1, [1, 2, 3, 4])",
            "assert reduce_base(0, [1, 2, 3]) == (1, [0, 1, 2, 3])",
            "assert reduce_base(2, [1, 3, 4]) == (-1, [1, 2, 3, 4])"
        ]
    },
    {
        "func_name": "__to_matrix",
        "code": "def __to_matrix(lst, column_size):\n    l_length = len(lst)\n    if not column_size or column_size >= l_length:\n        return [lst]\n\n    if column_size == 1:\n        row_size = l_length\n    elif l_length // column_size == 1:\n        row_size = 2\n    else:  # top row + bottom row + side columns in between\n        row_size = ((l_length - 2 * column_size + 1) // 2 + 2)\n    matrix = [[\" \"] * column_size for j in range(row_size)]\n\n    current_row = 0\n    current_col = 0\n    direction = \"right\"  # \"right\", \"down\", \"left\", \"up\"\n    for e in lst:\n        # top row\n        if direction == \"right\":\n            if current_col <= column_size - 1:\n                matrix[current_row][current_col] = e\n                current_col += 1\n            if current_col >= column_size:\n                current_col = column_size - 1\n                current_row += 1\n                direction = \"down\" if row_size > 2 else \"left\"\n            continue\n        # right column\n        elif direction == \"down\":\n            if current_row < row_size - 1:\n                matrix[current_row][current_col] = e\n                current_row += 1\n            if current_row >= row_size - 1:\n                current_row = row_size - 1\n                direction = \"left\"\n            continue\n        # bottom row\n        elif direction == \"left\":\n            if current_col >= 0:\n                matrix[current_row][current_col] = e\n                current_col -= 1\n            if current_col < 0:\n                current_col = 0\n                current_row = row_size - 2\n                direction = \"up\"\n            continue\n        # left column\n        elif direction == \"up\":\n            if current_row >= 1:\n                matrix[current_row][current_col] = e\n                current_row -= 1\n            if current_row == 0:\n                break\n    return matrix",
        "prompt": "| 1 2 3 | [1, 2, 3, 4, 5, 6, 7, 8] => | 8 4 | | 7 6 5 |",
        "task_id": "7378",
        "test_list": [
            "assert __to_matrix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 3) == [[10, 7, 4], [9, 6, 3], [8, 5, 2], [11, 12]]",
            "assert __to_matrix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], 6) == [[21, 15, 9, 4, 1, 2], [22, 16, 10, 5, 3, 6], [23, 17, 11, 7, 8, 12], [24, 18, 13, 14, 19, 20]]",
            "assert __to_matrix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 5) == [[17, 12, 7, 2, 1], [18, 13, 8, 3, 4], [19, 14, 9, 5, 6], [20, 15, 10, 11, 16]]",
            "assert __to_matrix([1, 2, 3, 4, 5, 6, 7, 8], 2) == [[8, 4], [7, 6, 5]]",
            "assert __to_matrix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], 4) == [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]"
        ]
    },
    {
        "func_name": "processQuery",
        "code": "def processQuery(string:str):\n    withe = 0\n\n    string = string.replace(\"\\\\n\", \"\\n\").replace(\"\\\\t\", \"\\t\")\n\n    if re.fullmatch(r'\\bwith\\b', string):\n        parts = string.split('with')\n        if len(parts) != 2:\n            return False\n        assertive = parts[1].strip()\n        if assertive == 'assertions':\n            string = parts[0]\n            withe = 1\n\n    s = \"\"\n    inString = False\n    for char in string:\n        if char == \"@\" and not inString:\n            return False\n        if char == \"#\" and not inString:\n            break\n        if char == '\"':\n            inString = not inString\n        if char in \" \\t\" and not inString:\n            continue\n        s += char\n\n    if inString:\n        return False\n\n    return withe, s",
        "prompt": "Formats queries to Local Language",
        "task_id": "7454",
        "test_list": [
            "assert processQuery('with assertions #') == (1, 'with assertions')",
            "assert processQuery('with assertions and extra spaces') == (1, 'with assertions and extra spaces')",
            "assert processQuery('with assertions') == (1, 'assertions')",
            "assert processQuery('with assertions and leading with') == (1, 'with assertions and leading with')",
            "assert processQuery('with no assertions') == (0, 'with no assertions')"
        ]
    },
    {
        "func_name": "compute_range",
        "code": "def compute_range(nums, distance):\n    less, equal = 0, 0\n    a, b = 0, 0  # a, b are the extremes of the segment of less distances\n    c, d = 0, 0  # c, d are the extremes of the segment of less/equal distances\n    prev = None\n    for num in nums[:-1]:\n        if num != prev:\n            while c < len(nums) and nums[c] + distance < num: c += 1\n            a = c\n            while a < len(nums) and nums[a] + distance == num: a += 1\n            while b < len(nums) - 1 and nums[b + 1] - distance < num: b += 1\n            d = b\n            while d < len(nums) - 1 and nums[d + 1] - distance == num: d += 1\n        prev = num\n\n        less += b - a\n        equal += d - c\n\n    return max(0, less/2), equal/2",
        "prompt": "compute how many distances are smaller then distance and how many distances are equal to distance, among all possible distances in nums, time complexity O(len(nums))",
        "task_id": "7496",
        "test_list": [
            "assert compute_range([10, 20, 30, 40, 50], 15) == (2, 1)",
            "assert compute_range([2, 4, 6, 8, 10], 1) == (4, 1)",
            "assert compute_range([5, 10, 15, 20, 25], 5) == (3, 1)",
            "assert compute_range([1, 3, 5, 7, 9], 2) == (2, 1)",
            "assert compute_range([1, 2, 3, 4, 5], 1) == (2, 1)"
        ]
    },
    {
        "func_name": "LookupInterconnect",
        "code": "def LookupInterconnect(string):\n\n\tInterconnect = \"UNKNOWN\"\n\n\tif re.search(\"Non-Volatile memory controller\", string):\n\t\tInterconnect = \"NVME\"\n\tif re.search(\"SATA controller:\", string):\n\t\tInterconnect = \"SATA\"\n\tif (re.search(\"USB Controller:\", string)) or (re.search(\"USB controller\", string)):\n\t\tInterconnect = \"USB\"\n\tif re.search(\"Serial Attached SCSI controller:\", string):\n\t\tInterconnect = \"SAS\"\n\tif re.search(\"SCSI storage controller:\", string):\n\t\t# SCSI occasionally lies to you.  Grep the string for SAS to be sure.\n\t\tif re.search(\"SAS\", string):\n\t\t\tInterconnect = \"SAS\"\n\t\telse:\n\t\t\tInterconnect = \"SCSI\"\n\tif re.search(\"Fibre Channel:\", string):\n\t\tInterconnect = \"FC\"\n\tif re.search(\"FireWire\", string) or re.search(\"IEEE 1394\", string):\n\t\tInterconnect = \"FIREWIRE\"\n\tif re.search(\"InfiniBand:\", string):\n\t\tInterconnect = \"INFINIBAND\"\n\n\t# If it reports back \"IDE\", that's a bit of an oddball.  Grep the line\n\t# to see if it mentions SATA or \"Serial ATA\", otherwise the testing I've\n\t# done shows it's fairly safe to assume it's PATA\n\tif re.search(\"IDE interface:\", string):\n\t\tif (re.search(\"SATA\", string)) or (re.search(\"Serial ATA\", string)):\n\t\t\tInterconnect = \"SATA\"\n\t\telse:\n\t\t\tInterconnect = \"PATA\"\n\n\t# This is also another PITA instance.  The RAID hides the interconnect\n\t# used.  Offhand I don't know to see through it, other than\n\t# grep the \"lspci\" output and hope there's a keyword I can latch onto.\n\t# Saving that for later though.\n\tif re.search(\"RAID bus controller:\", string):\n\t\tInterconnect = \"RAID\"\n\n\treturn Interconnect",
        "prompt": "This function is just a lookup table to convert strings from lspci to something a bit more useful",
        "task_id": "7644",
        "test_list": [
            "assert LookupInterconnect('Fibre Channel: FC') == 'FC'",
            "assert LookupInterconnect('Non-Volatile memory controller: NVMe') == 'NVME'",
            "assert LookupInterconnect('USB Controller: USB') == 'USB'",
            "assert LookupInterconnect('SCSI storage controller: SCSI') == 'SCSI'",
            "assert LookupInterconnect('FireWire: IEEE 1394') == 'FIREWIRE'"
        ]
    },
    {
        "func_name": "format_atom_names",
        "code": "\nimport string\n\ndef format_atom_names(atoms, part='', resinum=''):\n    alphabet = string.ascii_uppercase\n    numpart = ''\n    part = str(part)\n    resinum = str(resinum)\n    if not resinum:\n        resinum = ''\n    try:\n        int(part)\n        if int(part) > 0:\n            partsymbol = alphabet[int(part) - 1]  # turns part number into a letter\n        else:\n            print('Warning! Part symbol with non-numeric character detected.')\n            partsymbol = ''\n    except ValueError:\n        partsymbol = ''\n    if resinum and partsymbol:\n        numpart = '_' + resinum + partsymbol\n    if not resinum and partsymbol:\n        numpart = '_' + partsymbol\n    if resinum and not partsymbol:\n        numpart = '_' + resinum\n    if not resinum and not partsymbol:\n        numpart = ''\n    # add the _'num''partsymbol' to each atom to be able to find them in the\n    # list file:\n    atomnames = [i + numpart for i in atoms]\n    return atomnames\n",
        "prompt": "needs a list of atoms ['C1', 'C2', 'O1', ..] with part number and a residue number. returns a list with atoms like ['C1_4b', 'C2_4b', 'O1_4b', ..]",
        "task_id": "7646",
        "test_list": [
            "assert format_atom_names(['C1', 'C2', 'O1'], part='5', resinum='') == ['C1_5', 'C2_5', 'O1_5']",
            "assert format_atom_names(['C1', 'C2', 'O1'], part='4', resinum='b') == ['C1_4b', 'C2_4b', 'O1_4b']",
            "assert format_atom_names(['C1', 'C2', 'O1'], part='a', resinum='b') == ['C1_a_b', 'C2_a_b', 'O1_a_b']",
            "assert format_atom_names(['C1', 'C2', 'O1'], part='0', resinum='') == ['C1', 'C2', 'O1']",
            "assert format_atom_names(['C1', 'C2', 'O1'], part='3', resinum='a') == ['C1_3a', 'C2_3a', 'O1_3a']"
        ]
    },
    {
        "func_name": "boundary_points",
        "code": "def boundary_points(branch_pts):\n    # First try on box.\n    maxx = 2*max(x for x,y in branch_pts)\n    minx = 2*min(x for x,y in branch_pts)\n    maxy = 2*max(y for x,y in branch_pts)\n    miny = 2*min(y for x,y in branch_pts)\n\n    # degenerate case: a boundary box edge lies on the real axis, in which case\n    # some branch points may lie on an edge\n    if abs(maxx) < 10**(-5):\n        maxx = -minx\n    if abs(minx) < 10**(-5):\n        minx = -maxx\n    if abs(maxy) < 10**(-5):\n        maxy = -miny\n    if abs(miny) < 10**(-5):\n        miny = -maxy\n\n    # degenerate case: boundary box consists of an edge or point\n    #\n    # note: this code, at the moment, assumes that the curve has at least two\n    # finite branch points. this is a very strong assumption and should be made\n    # more general\n    if (abs(minx - maxx) < 10**(-5)):\n        x_shift = (abs(maxy) + abs(miny))/2\n        minx = branch_pts[0][0] - x_shift\n        maxx = branch_pts[0][0] + x_shift\n\n    if (abs(miny - maxy) < 10**(-5)):\n        y_shift = (abs(maxx) + abs(minx))/2\n        miny = branch_pts[0][1] - y_shift\n        maxy = branch_pts[0][1] + y_shift\n\n    # compute the box vertices and return\n    boundary_pts =  [(x,y) for x in [minx,maxx] for y in [miny,maxy]]\n    return boundary_pts",
        "prompt": "r\"\"\"Returns a list of boundary / ghost points to add to the branch locus. The Voronoi diagram of just the branch points will return rays going off to infinity. We add points \"around\" the branch points such that the Voronoi edges can be used to construct monodromy cycles.",
        "task_id": "7705",
        "test_list": [
            "assert boundary_points([(1, 0), (1, 1), (1, 2)]) == [(1, 0), (1, 2), (1, 1)]",
            "assert boundary_points([(0, 0), (1, 1), (2, 2)]) == [(0, 0), (2, 2), (0, 2), (2, 0)]",
            "assert boundary_points([(0, 0), (0, 1), (0, 2)]) == [(0, 0), (0, 2), (0, 1)]",
            "assert boundary_points([(0, 0), (0, 1e-05), (0, 2e-05)]) == [(0, 0), (0, 2e-05), (0, 1e-05)]",
            "assert boundary_points([(0, 0), (0, 0), (0, 0)]) == [(0, 0)]"
        ]
    },
    {
        "func_name": "attribute_extractor",
        "code": "def attribute_extractor(inside: str) -> dict:\n    attributes = dict()\n    attribute = \"\"\n    value = \"\"\n    in_value = False\n    in_icon = False  # prevents padding cause an infinite loop\n    for i in range(len(inside)):\n        if (inside[i].isspace() or inside[i] == '\\n') and not in_value:\n            continue\n        elif inside[i] == '=' and not in_value:\n            in_value = True\n        elif not in_value:\n            attribute += inside[i]\n        elif in_value:\n            if inside[i] == '\"' and inside[i - 1] == '=' and not in_icon:\n                if attribute == 'ICON':\n                    in_icon = True\n                continue\n            elif inside[i] == '\"':\n                in_icon = False\n                in_value = False\n            if not in_value:\n                attributes[attribute] = value\n                attribute = \"\"\n                value = \"\"\n                continue\n            else:\n                value += inside[i]\n    return attributes",
        "prompt": "Extracts the attributes and its values and put them in a dictionary",
        "task_id": "7742",
        "test_list": [
            "assert attribute_extractor('name=\"John Doe\" age=30 icon=\"\ud83d\ude0a\"') == {'name': 'John Doe', 'age': '30', 'icon': '\ud83d\ude0a'}",
            "assert attribute_extractor('color=\"blue\" size=\"large\"') == {'color': 'blue', 'size': 'large'}",
            "assert attribute_extractor('is_member=\"true\" level=\"gold\"') == {'is_member': 'true', 'level': 'gold'}",
            "assert attribute_extractor('username=\"johndoe\" password=\"secret\" active=true') == {'username': 'johndoe', 'password': 'secret', 'active': 'true'}",
            "assert attribute_extractor('height=\"180cm\" weight=\"75kg\"') == {'height': '180cm', 'weight': '75kg'}"
        ]
    },
    {
        "func_name": "five_gon_rings",
        "code": "def five_gon_rings(n):\n    rings = [([a, b, c], [d, c, e], [f, e, g], [h, g, i], [j, i, b])\n             for a in range(1, 10+1)\n             for b in range(1, 10+1) if b != a\n             for c in range(1, 10+1) if c not in [a, b]\n             if a + b + c == n\n             for d in range(1, 10+1) if d not in [a, b, c]\n             for e in range(1, 10+1) if e not in [a, b, c, d]\n             if d + c + e == n\n             for f in range(1, 10+1) if f not in [a, b, c, d, e]\n             for g in range(1, 10+1) if g not in [a, b, c, d, e, f]\n             if f + e + g == n\n             for h in range(1, 10+1) if h not in [a, b, c, d, e, f, g]\n             for i in range(1, 10+1) if i not in [a, b, c, d, e, f, g, h]\n             if h + g + i == n\n             for j in range(1, 10+1) if j not in [a, b, c, d, e, f, g, h, i]\n             if j + i + b == n\n             if a < min(d, f, h, j)]\n    # Each solution can be described uniquely starting from the group of three\n    # with the numerically lowest external node and working clockwise.\n    # So we specified at the end that a < min(d, f, h, j)\n    return rings",
        "prompt": "Return list of solutions to the 'magic' 5gon ring problem, each line summing to n. The empty list will be returned if there are no solutions.",
        "task_id": "7748",
        "test_list": [
            "assert five_gon_rings(15) == [[(1, 5, 9), (4, 9, 2), (6, 2, 7), (8, 7, 1), (5, 1, 9)]]",
            "assert five_gon_rings(35) == [[(5, 12, 18), (6, 18, 11), (7, 11, 17), (8, 17, 10), (5, 10, 20)]]",
            "assert five_gon_rings(25) == [[(3, 9, 13), (4, 13, 8), (5, 8, 12), (6, 12, 7), (3, 7, 15)]]",
            "assert five_gon_rings(30) == [[(4, 11, 15), (5, 15, 10), (6, 10, 14), (7, 14, 9), (4, 9, 17)]]",
            "assert five_gon_rings(20) == [[(2, 8, 10), (3, 10, 7), (5, 7, 8), (6, 8, 6), (2, 6, 12)]]"
        ]
    },
    {
        "func_name": "adjustBboxFormat",
        "code": "\ndef adjustBboxFormat(bb):\n    border_list = [5, 10, 15, 20]\n    img_width = 100\n    img_length = 100\n    left_top = (bb[0], bb[1])\n    right_bottom = (bb[2], bb[3])\n    cmin = int(left_top[0]) + 1\n    cmax = int(right_bottom[0]) - 1\n    rmin = int(left_top[1]) + 1\n    rmax = int(right_bottom[1]) - 1\n    r_b = rmax - rmin\n    for tt in range(len(border_list)):\n        if r_b > border_list[tt] and r_b < border_list[tt + 1]:\n            r_b = border_list[tt + 1]\n            break\n    c_b = cmax - cmin\n    for tt in range(len(border_list)):\n        if c_b > border_list[tt] and c_b < border_list[tt + 1]:\n            c_b = border_list[tt + 1]\n            break\n    center = [int((rmin + rmax) / 2), int((cmin + cmax) / 2)]\n    rmin = center[0] - int(r_b / 2)\n    rmax = center[0] + int(r_b / 2)\n    cmin = center[1] - int(c_b / 2)\n    cmax = center[1] + int(c_b / 2)\n    if rmin < 0:\n        delt = -rmin\n        rmin = 0\n        rmax += delt\n    if cmin < 0:\n        delt = -cmin\n        cmin = 0\n        cmax += delt\n    if rmax > img_width:\n        delt = rmax - img_width\n        rmax = img_width\n        rmin -= delt\n    if cmax > img_length:\n        delt = cmax - img_length\n        cmax = img_length\n        cmin -= delt\n    return rmin, rmax, cmin, cmax\n",
        "prompt": "return rmin, rmax, cmin, cmax",
        "task_id": "7777",
        "test_list": [
            "assert adjustBboxFormat((20, 20, 80, 80)) == (50, 80, 50, 80)",
            "assert adjustBboxFormat((5, 5, 95, 95)) == (45, 95, 45, 95)",
            "assert adjustBboxFormat((0, 0, 99, 99)) == (49, 99, 49, 99)",
            "assert adjustBboxFormat((10, 10, 50, 50)) == (25, 75, 25, 75)",
            "assert adjustBboxFormat((10, 10, 90, 90)) == (45, 90, 45, 90)"
        ]
    },
    {
        "func_name": "solve_logic_puzzle",
        "code": "def solve_logic_puzzle():\n  ## your code here; you are free to define additional functions if needed\n\n  names = ['Hamming', 'Knuth', 'Minsky', 'Simon', 'Wilkes']\n  items = ['laptop', 'droid', 'tablet', 'iphone']\n  job = ['programmer', 'writer', 'manager', 'designer']\n\n  dates_list = Monday, Tuesday, Wednesday, Thursday, Friday = (1, 2, 3, 4, 5)\n  orderings = list(itertools.permutations(dates_list))\n\n  return next([Hamming, Knuth, Minsky, Simon, Wilkes]\n              for (Hamming, Knuth, Minsky, Simon, Wilkes) in orderings\n              if Knuth == Simon + 1  # 6\n              for (laptop, droid, tablet, iphone, _) in orderings\n              if Wednesday is laptop  # 1\n              if Friday is not tablet  # 8\n              for (programmer, writer, manager, designer, _) in orderings\n              if Thursday is not designer  # 7\n              if programmer is not Wilkes  # 2\n              if (programmer is Wilkes and droid is Hamming) or (programmer is Hamming and droid is Wilkes)  # 3\n              if writer is not Minsky  # 4\n              if Knuth is not manager and tablet is not manager  # 5\n              if designer is not droid  # 9\n              if Knuth == manager + 1  # 10\n              if (laptop is Monday and Wilkes is writer) or (laptop is writer and Wilkes is Monday)  # 11\n              if (iphone is Tuesday) or (tablet is Tuesday)  # 12\n              )",
        "prompt": "Return a list of the names of the people, in the order they arrive.",
        "task_id": "7897",
        "test_list": [
            "assert solve_logic_puzzle() == ['Knuth', 'Minsky', 'Simon', 'Wilkes', 'Hamming']",
            "assert solve_logic_puzzle() == ['Simon', 'Wilkes', 'Hamming', 'Knuth', 'Minsky']",
            "assert solve_logic_puzzle() == ['Hamming', 'Knuth', 'Minsky', 'Simon', 'Wilkes']",
            "assert solve_logic_puzzle() == ['Wilkes', 'Hamming', 'Knuth', 'Minsky', 'Simon']",
            "assert solve_logic_puzzle() == ['Minsky', 'Simon', 'Wilkes', 'Hamming', 'Knuth']"
        ]
    },
    {
        "func_name": "generate_random_data",
        "code": "def generate_random_data(length=None, type=None):\n\n    if type == 'string':\n        return ''.join(random.choice(string.ascii_lowercase) for i in range(length))\n\n    elif type == 'integer':\n        return int(''.join(random.choice(string.digits) for i in range(length)))\n\n    elif type == 'float':\n        return float(''.join(random.choice(string.digits) for i in range(length)))\n\n    # Datetime format '2017-02-18' or 'YYYY-MM-DD'\n    elif type == 'datetime':\n        year = random.randint(1990, 2018)\n\n        month = random.randint(1, 12)\n        if month < 10:\n            month = '0{0}'.format(month)\n\n        day = random.randint(1, 28)\n        if day < 10:\n            day = '0{0}'.format(day)\n        return '{0}-{1}-{2}'.format(year, month, day)\n\n    # Time format '01:30' or 'HH:MM'\n    elif type == 'time':\n        hour = random.randint(0, 23)\n        if hour < 10:\n            hour = '0{0}'.format(hour)\n\n        minute = random.randint(0, 60)\n        if minute < 10:\n            minute = '0{0}'.format(minute)\n\n        return '{0}:{1}'.format(hour, minute)\n\n    # If type not correct we return None\n    else:\n        return None",
        "prompt": "Random data generator. It's can be string, integer, float, datetime, time. Function take length it's a number of symbol of result data and object type. It's mean result will be that object type.",
        "task_id": "7914",
        "test_list": [
            "assert generate_random_data(7, 'string') == 'abcdefg'",
            "assert generate_random_data(10, 'string') == 'abcdefghij'",
            "assert generate_random_data(8, 'string') == 'abcdefgh'",
            "assert generate_random_data(10, 'integer') == 1234567890",
            "assert generate_random_data(5, 'string') == 'abcde'"
        ]
    },
    {
        "func_name": "determine_turn_modifiers",
        "code": "def determine_turn_modifiers(command_mod, fleet_strength, engagement_level):\n\n    fleet_strength_vals = {'Full Strength': 1, 'Minimal Damage': 0, 'Suffering Minor Losses': -1,\n                           'Suffering Heavy Losses': -3, 'Routed': -4}\n\n    engagement_level_vals = {'No Contact': 0, 'Enemy Sighted': 1, 'Engaging Enemy': 0, 'Under Fire': -1,\n                             'Under Heavy Fire': -2}\n\n    strength = fleet_strength_vals[fleet_strength]\n    engagement = engagement_level_vals[engagement_level]\n    turn_mod = command_mod + strength + engagement\n\n    if fleet_strength == 'Full Strength' and turn_mod < 0:\n        turn_mod = 0\n    elif fleet_strength == 'Minimal Damage' and turn_mod < 0:\n        turn_mod += 1\n    elif fleet_strength == 'Suffering Heavy Losses' and turn_mod > 0:\n        turn_mod -= 1\n    elif fleet_strength == 'Routed':\n        turn_mod = -15\n\n    if engagement_level == 'No Contact':\n        turn_mod = 0\n    elif engagement_level == 'Enemy Sighted' and turn_mod < 0:\n        turn_mod += 1\n    elif engagement_level == 'Under Heavy Fire' and turn_mod > 0:\n        turn_mod -= 1\n\n    return turn_mod",
        "prompt": "Generates an overall modifier based on fleet strength, engagement level, and command modifier to be used each turn with determine_ship_orders().",
        "task_id": "7948",
        "test_list": [
            "assert determine_turn_modifiers('Command Modifier', 'Suffering Heavy Losses', 'Under Fire') == -16",
            "assert determine_turn_modifiers('Command Modifier', 'Minimal Damage', 'No Contact') == 1",
            "assert determine_turn_modifiers('Command Modifier', 'Full Strength', 'Enemy Sighted') == 2",
            "assert determine_turn_modifiers('Command Modifier', 'Suffering Minor Losses', 'Under Heavy Fire') == -2",
            "assert determine_turn_modifiers('Command Modifier', 'Routed', 'Enemy Sighted') == -14"
        ]
    },
    {
        "func_name": "perms_canonical_labels_from",
        "code": "def perms_canonical_labels_from(x, y, j0, verbose=False):\n    n = len(x)\n\n    k = 0\n    mapping = [None] * n\n    waiting = [[] for i in range(len(y))]\n\n    while k < n:\n        if verbose:\n            print(\"complete from {}\".format(j0))\n        # initialize at j0\n        mapping[j0] = k\n        waiting[0].append(j0)\n        k += 1\n        # complete x cycle from j0\n        j = x[j0]\n        while j != j0:\n            mapping[j] = k\n            waiting[0].append(j)\n            k += 1\n            j = x[j]\n        if verbose:\n            print(\"completed cycle mapping = {}\".format(mapping))\n\n        # find another guy\n        if verbose:\n            print(\"try to find somebody in {}\".format(waiting))\n        l = 0\n        while l < len(waiting):\n            i = 0\n            while i < len(waiting[l]):\n                j1 = waiting[l][i]\n                if mapping[y[l][j1]] is None:\n                    break\n                i += 1\n\n            if i == len(waiting[l]):  # not found: go further in waiting\n                if l < len(waiting) - 1:\n                    waiting[l + 1].extend(waiting[l])\n                waiting[l] = []\n                l += 1\n                i = 0\n\n            else:  # found: complete cycle from new guy\n                j0 = y[l][j1]\n                if l < len(waiting) - 1:\n                    waiting[l + 1].extend(waiting[l][:i + 1])\n                del waiting[l][:i + 1]\n                break\n\n    return mapping",
        "prompt": "r\"\"\" Return canonical labels for ``x``, ``y`` that starts at ``j0``",
        "task_id": "8034",
        "test_list": [
            "assert perms_canonical_labels_from([0, 1, 2, 3], [[0, 1, 2], [2, 3, 0]], 0, True) == [0, 1, 2, 3]",
            "assert perms_canonical_labels_from([1, 0, 2, 1], [[0, 1, 2], [1, 2, 0]], 0, True) == [0, 1, 2, 0]",
            "assert perms_canonical_labels_from([0, 1, 2, 0], [[0, 1, 2], [2, 0, 1]], 0, True) == [0, 1, 2, 0]",
            "assert perms_canonical_labels_from([2, 0, 1, 2], [[1, 0, 2], [2, 1, 0]], 1, True) == [1, 0, 2, 1]",
            "assert perms_canonical_labels_from([0, 1, 2, 3, 4], [[0, 1, 2], [2, 3, 4], [4, 0, 1]], 0, True) == [0, 1, 2, 3, 4]"
        ]
    },
    {
        "func_name": "add2chain2nd",
        "code": "\ndef add2chain2nd(splitted_text):\n    startKey = 'start'\n    endKey = 'end'\n    chain = {}\n    inputText = splitted_text\n    if len(inputText) > 1:\n        for i, word in enumerate(inputText):\n            if i == 0:\n                if (None, startKey) not in chain:\n                    chain[(None, startKey)] = [word]\n                else:\n                    chain[(None, startKey)].append(word)\n            elif i == 1:\n                if (startKey, inputText[i-1]) not in chain:\n                    chain[(startKey, inputText[i-1])] = [word]\n                else:\n                    chain[(startKey, inputText[i-1])].append(word)\n            else:\n                if (inputText[i-2], inputText[i-1]) not in chain:\n                    chain[(inputText[i-2], inputText[i-1])] = [word]\n                else:\n                    chain[(inputText[i-2], inputText[i-1])].append(word)\n            if i == len(inputText)-1:\n                if (inputText[i-1], word) not in chain:\n                    chain[(inputText[i-1], word)] = [endKey]\n                else:\n                    chain[(inputText[i-1], word)].append(endKey)\n        if (None, startKey) not in chain:\n            chain[(None, startKey)] = [inputText[0]]\n        else:\n            chain[(None, startKey)].append(inputText[0])\n        if (inputText[0], endKey) not in chain:\n            chain[(inputText[0], endKey)] = [None]\n        else:\n            chain[(inputText[0], endKey)].append(None)\n",
        "prompt": "Creates a 2nd order markov chain",
        "task_id": "8060",
        "test_list": [
            "assert add2chain2nd(['x', 'y', 'z', 'x', 'y', 'z', 'x', 'y', 'z', 'x']) == {('x', 'y'): ['end'], ('y', 'z'): ['end'], ('z', 'x'): ['start'], ('x', 'x'): ['start'], ('y', 'y'): ['start'], ('z', 'z'): ['start'], ('x', 'end'): [None], ('y', 'end'): [None], ('z', 'end'): [None], ('start', 'x'): [None], ('start', 'y'): [None], ('start', 'z'): [None]}",
            "assert add2chain2nd(['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c']) == {('a', 'b'): ['end'], ('b', 'c'): ['end'], ('c', 'a'): ['start'], ('a', 'a'): ['start'], ('b', 'b'): ['start'], ('c', 'c'): ['start'], ('a', 'end'): [None], ('b', 'end'): [None], ('c', 'end'): [None], ('start', 'a'): [None], ('start', 'b'): [None], ('start', 'c'): [None]}",
            "assert add2chain2nd(['apple', 'banana', 'apple', 'banana', 'apple', 'banana', 'apple', 'banana', 'apple', 'banana']) == {('apple', 'banana'): ['end'], ('banana', 'apple'): ['end'], ('apple', 'apple'): ['start'], ('banana', 'banana'): ['start'], ('apple', 'end'): [None], ('banana', 'end'): [None], ('start', 'apple'): [None], ('start', 'banana'): [None], ('start', 'end'): [None]}",
            "assert add2chain2nd(['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three', 'one']) == {('one', 'two'): ['end'], ('two', 'three'): ['end'], ('three', 'one'): ['start'], ('one', 'one'): ['start'], ('two', 'two'): ['start'], ('three', 'three'): ['start'], ('one', 'end'): [None], ('two', 'end'): [None], ('three', 'end'): [None], ('start', 'one'): [None], ('start', 'two'): [None], ('start', 'three'): [None]}",
            "assert add2chain2nd(['hello', 'world', 'hello', 'world']) == {('hello', 'world'): ['end'], ('world', 'hello'): ['end'], ('hello', 'hello'): ['start'], ('world', 'world'): ['start'], ('hello', 'end'): [None], ('world', 'end'): [None], ('start', 'hello'): [None], ('start', 'world'): [None]}"
        ]
    },
    {
        "func_name": "_recursive_rectangles",
        "code": "def _recursive_rectangles(x, y):\n    if x < 1 or y < 1:\n        raise ValueError(\"Invalid input\")\n    if x == 1 and y == 1:\n        return {((0, 0), (1, 1)), }\n    if x == 1:\n        return _recursive_rectangles(x, y-1) | set(((0, j), (x, y)) for j in range(y))\n    if y == 1:\n        return _recursive_rectangles(x-1, y) | set(((i, 0), (x, y)) for i in range(x))\n    return _recursive_rectangles(x-1, y) | _recursive_rectangles(x, y-1) | \\\n           set(((i, j), (x, y)) for i in range(x) for j in range(y))",
        "prompt": "The meat of the algorithm.",
        "task_id": "8162",
        "test_list": [
            "assert _recursive_rectangles(3, 1) == {((0, 0), (1, 1)), ((1, 0), (2, 1)), ((2, 0), (3, 1))}",
            "assert _recursive_rectangles(2, 2) == {((0, 0), (1, 1)), ((0, 1), (1, 2)), ((1, 0), (2, 1)), ((1, 1), (2, 2))}",
            "assert _recursive_rectangles(2, 3) == {((0, 0), (1, 1)), ((0, 1), (1, 2)), ((0, 2), (1, 3)), ((1, 0), (2, 1)), ((1, 1), (2, 2)), ((1, 2), (2, 3))}",
            "assert _recursive_rectangles(1, 3) == {((0, 0), (1, 1)), ((0, 1), (1, 2)), ((0, 2), (1, 3))}",
            "assert _recursive_rectangles(3, 3) == {((0, 0), (1, 1)), ((0, 1), (1, 2)), ((0, 2), (1, 3)), ((1, 0), (2, 1)), ((1, 1), (2, 2)), ((1, 2), (2, 3)), ((2, 0), (3, 1)), ((2, 1), (3, 2)), ((2, 2), (3, 3))}"
        ]
    },
    {
        "func_name": "rail_fence_encrypt",
        "code": "\ndef rail_fence_encrypt(string, key):\n    try:\n        cols_size = len(string)\n        arr_of_words = [[0 for i in range(cols_size)] for j in range(key)]\n        pos = 0\n        direction = 1\n        for j in range(0, cols_size):\n            #  direction variable sets the moving direction\n            arr_of_words[pos][j] = string[j]\n            pos += direction\n            if pos == 0 or pos == key-1:\n                direction *= (-1)\n\n        str_to_return = \"\"  # concat the new string\n        for i in range(key):\n            for j in range(cols_size):\n                if arr_of_words[i][j] != 0:\n                    str_to_return += arr_of_words[i][j]\n        return str_to_return\n    except (ValueError, IndexError) as ex:\n        print(\"An exception occurred:\", ex)\n",
        "prompt": "encrypt function that gets string and key and uses rail fence cipher",
        "task_id": "8396",
        "test_list": [
            "assert rail_fence_encrypt('RAILFENCECIPHER', 4) == 'RCRFNEEALFIC'",
            "assert rail_fence_encrypt('TESTCASE', 5) == 'TTSCEAE'",
            "assert rail_fence_encrypt('PYTHON', 2) == 'PYTHON'",
            "assert rail_fence_encrypt('HACKTHECODE', 3) == 'HCAKTEODCE'",
            "assert rail_fence_encrypt('WEAREDISCOVEREDFLEEATONCE', 3) == 'WECRLTEAOEADSIUY'"
        ]
    },
    {
        "func_name": "num_agreeing_tuples",
        "code": "def num_agreeing_tuples(perm1,perm2,k):\n    if len(perm1) != len(perm2) or len(set(perm1)) != len(perm1) or len(set(perm2)) != len(perm2):\n        raise Exception(\"Incompatible lists\")\n    perm1 = perm1[1:-1]\n    perm2 = perm2[1:-1]\n    agree = 0\n    disagree = 0\n    for index_tuple in itertools.combinations(range(len(perm1)),k):\n        tuple1 = [perm1[ind] for ind in index_tuple]\n        tuple2 = [perm2[ind] for ind in index_tuple]\n        ordered_tuple1 = sorted(tuple1)\n        ordered_tuple2 = sorted(tuple2)\n        ordinals1 = [bisect.bisect_left(ordered_tuple1,x) for x in tuple1]\n        ordinals2 = [bisect.bisect_left(ordered_tuple2,x) for x in tuple2]\n        if ordinals1 == ordinals2:\n            agree += 1\n        else:\n            disagree += 1\n    return agree,agree+disagree",
        "prompt": "same as num_swaps, but for ktuples.",
        "task_id": "8461",
        "test_list": [
            "assert num_agreeing_tuples([1, 2, 3, 4], [4, 3, 2, 1], 2) == (1, 2)",
            "assert num_agreeing_tuples([1, 2, 3, 4, 5], [5, 4, 3, 2, 1], 3) == (1, 2)",
            "assert num_agreeing_tuples([1, 2, 3, 4], [1, 2, 3, 4], 1) == (4, 4)",
            "assert num_agreeing_tuples([1, 2, 3, 4], [1, 2, 3, 4], 0) == (0, 4)",
            "assert num_agreeing_tuples([1, 2, 3, 4, 5], [5, 4, 3, 2, 1], 5) == (0, 5)"
        ]
    },
    {
        "func_name": "make_dp",
        "code": "def make_dp(arr, n, value):\n    dp = [[False for i in range(value+1)] for j in range(n+1)]\n    \n    for i in range(n+1):\n        for j in range(value+1):\n            if j ==0:\n                dp[i][j] = True\n            elif i == 0:\n                dp[i][j] = False\n            else:\n                if dp[i-1][j]:\n                    dp[i][j] = True\n                elif j >=arr[i-1]:\n                    if dp[i-1][j-arr[i-1]]:\n                        dp[i][j] = True\n    return dp",
        "prompt": "This function makes a table of target sum equal to the value",
        "task_id": "8475",
        "test_list": [
            "assert make_dp([1, 2, 3, 4], 4, 5) == [[True, True, True, True, True], [False, True, True, True, True], [False, False, True, True, True], [False, False, False, True, True]]",
            "assert make_dp([1, 1, 1, 1, 1], 5, 3) == [[True, True, True, True, True, True], [False, True, True, True, True, True], [False, False, True, True, True, True], [False, False, False, True, True, True], [False, False, False, False, True, True]]",
            "assert make_dp([3, 34, 4, 12, 5, 2], 6, 9) == [[True, True, True, True, True, True, True], [False, True, True, True, True, True, True], [False, False, True, True, True, True, True], [False, False, False, True, True, True, True], [False, False, False, False, True, True, True], [False, False, False, False, False, True, True]]",
            "assert make_dp([1, 2, 3], 3, 5) == [[True, True, True, True, True], [False, True, True, True, True], [False, False, True, True, True]]",
            "assert make_dp([5, 3, 4, 2], 4, 7) == [[True, True, True, True, True], [False, True, True, True, True], [False, False, True, True, True], [False, False, False, True, True]]"
        ]
    },
    {
        "func_name": "check_para_tilling",
        "code": "def check_para_tilling(in_tile, in_node, in_size, ncruns, cas_ncsize):\n    # ~~ Default values ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    ncnode = 1\n    if in_node != 0:\n        ncnode = max(1, in_node)\n    # By default taking the input ncsize\n    if in_size != -1:\n        ncsize = in_size\n    else:\n        ncsize = cas_ncsize\n\n    # ~~ Special case of nctile ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    nctile = 1\n    if in_tile != 0:\n        nctile = max(1, in_tile)\n    elif ncnode > 1:\n        if ncsize > 1:\n            nctile = ncsize // ncnode\n        elif ncruns > 1:\n            nctile = ncruns // ncnode\n\n    # ~~ Special case of batching ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    if in_node == 0:\n        # ~~> temporary measure before doing each run in parallel of one another\n        ncnode = max(1, ncsize) // nctile\n        if ncnode * nctile < max(1, ncsize):\n            ncnode = ncnode + 1\n        # ~~> valid for runs in parallel of one another\n        #ncnode = int( max( 1,ncsize ) * ncruns / nctile )\n        #if ncnode * nctile < max( 1,ncsize ) * ncruns: ncnode = ncnode + 1\n\n    if ncruns == 1:\n    # ~~ Standard cases ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    # If the command line options.nctile and options.ncnode are fixed\n        if in_tile != 0 and in_node != 0 and ncsize == 0:\n            ncsize = ncnode * nctile\n    # If options.ncsize is set, it will have priority over the others\n        elif in_size != 0:\n            # ncnode is an integer of nctile and ncsize is re-ajusted\n            if in_tile != 0:\n                ncnode = max(1, ncsize) // nctile\n                while ncnode * nctile < max(1, ncsize):\n                    ncnode = ncnode + 1\n            # nctile is an integer of ncnode and ncsize is re-ajusted\n            if in_node != 0:\n                nctile = max(1, ncsize) // ncnode\n                while ncnode * nctile < max(1, ncsize):\n                    nctile = nctile + 1\n            # local processor with 1 node and many cores\n            if in_tile == 0 and in_node == 0:\n                ncnode = 1\n                nctile = max(1, ncsize)\n\n    return nctile, ncnode, ncsize",
        "prompt": "Check the consistency between number of core / processors and domains.",
        "task_id": "8497",
        "test_list": [
            "assert check_para_tilling(0, 1, 16, 1, 4) == (16, 1, 16)",
            "assert check_para_tilling(0, 0, 0, 1, 4) == (1, 1, 4)",
            "assert check_para_tilling(0, 1, 0, 1, 4) == (1, 1, 4)",
            "assert check_para_tilling(2, 0, -1, 4, 8) == (4, 2, 8)",
            "assert check_para_tilling(0, 0, 16, 1, 4) == (16, 1, 16)"
        ]
    },
    {
        "func_name": "b_TP_FN_sentence",
        "code": "def b_TP_FN_sentence(train):\n    tp = 0\n    fn = 0\n    tmp_t = \"\"\n    tmp_r = \"\"\n    for i in range(len(train)):\n        if(train[i][0] != '_'):\n            tmp_t += train[i][0]\n            tmp_r += train[i][1]\n        elif(train[i][0] == '_'):\n            if(tmp_t == tmp_r and tmp_t !=\"\" and tmp_r != \"\"):\n                tp += 1\n            elif(tmp_t != tmp_r and tmp_t !=\"\" and tmp_r != \"\"):\n                fn += 1\n            tmp_r = \"\"\n            tmp_t = \"\"\n    return tp, fn",
        "prompt": "dogru ve yanlis ogrenilmis kelime sayisi",
        "task_id": "8635",
        "test_list": [
            "assert b_TP_FN_sentence([['_', 'dog'], ['_', 'dog'], ['_', 'cat'], ['_', 'dog'], ['_', 'cat']]) == (2, 1)",
            "assert b_TP_FN_sentence([['_', 'cat'], ['_', 'dog'], ['_', 'cat'], ['_', 'dog'], ['_', 'dog']]) == (0, 0)",
            "assert b_TP_FN_sentence([['_', 'cat'], ['_', 'dog'], ['_', 'cat'], ['_', 'dog'], ['_', 'cat']]) == (1, 1)",
            "assert b_TP_FN_sentence([['_', 'cat'], ['_', 'dog'], ['_', 'cat'], ['_', 'cat'], ['_', 'dog']]) == (1, 1)",
            "assert b_TP_FN_sentence([['_', 'cat'], ['_', 'cat'], ['_', 'cat'], ['_', 'cat'], ['_', 'cat']]) == (0, 0)"
        ]
    },
    {
        "func_name": "TP_FN_sentence",
        "code": "def TP_FN_sentence(test, result):\n    tp = 0\n    fn = 0\n    tmp_t = \"\"\n    tmp_r = \"\"\n    for i in range(len(test)):\n        if(test[i][0] != '_'):\n            tmp_t += test[i][0]\n            tmp_r += result[i]\n        elif(test[i][0] == '_'):\n            if(tmp_t == tmp_r and tmp_t !=\"\" and tmp_r != \"\"):\n                tp += 1\n            elif(tmp_t != tmp_r and tmp_t !=\"\" and tmp_r != \"\"):\n                fn += 1\n            tmp_r = \"\"\n            tmp_t = \"\"\n    return tp, fn",
        "prompt": "dogru ve yanlis ogrenilmis kelime sayisi",
        "task_id": "8636",
        "test_list": [
            "assert TP_FN_sentence([['_', 'dog'], ['_', 'barked'], ['_', 'loudly'], ['_', 'at'], ['_', 'the'], ['_', 'park'], ['_', 'dog'], ['_', 'barked']], ['dog', 'barked', 'loudly', 'at', 'the', 'park', 'dog', 'barked']) == (1, 1)",
            "assert TP_FN_sentence([['_', 'cat'], ['_', 'sat'], ['_', 'on'], ['_', 'the'], ['_', 'mat']], ['cat', 'sat', 'on', 'the', 'mat']) == (1, 0)",
            "assert TP_FN_sentence([['_', 'dog'], ['_', 'barked'], ['_', 'loudly'], ['_', 'at'], ['_', 'the'], ['_', 'park']], ['dog', 'barked', 'loudly', 'at', 'the', 'park']) == (1, 0)",
            "assert TP_FN_sentence([['_', 'dog'], ['_', 'ro'], ['_', 'g'], ['_', 'u'], ['_', 've'], ['_', 'yan'], ['_', 'lis'], ['_', 'o'], ['_', 'grenilmis'], ['_', 'kelime'], ['_', 'sayisi']], ['dog', 'ro', 'g', 'u', 've', 'yan', 'lis', 'o', 'grenilmis', 'kelime', 'sayisi']) == (1, 0)",
            "assert TP_FN_sentence([['_', 'dog'], ['_', 'barked'], ['_', 'loudly'], ['_', 'at'], ['_', 'the'], ['_', 'park'], ['_', 'dog']], ['dog', 'barked', 'loudly', 'at', 'the', 'park', 'dog']) == (1, 1)"
        ]
    },
    {
        "func_name": "Neighbourgs",
        "code": "\ndef Neighbourgs(abcd, h):\n\n    Nelem = len(abcd)\n\n    a = abcd[h][0]\n    b = abcd[h][1]\n    c = abcd[h][2]\n    d = abcd[h][3]\n\n    el1, el2, el3, el4 = 0, 0, 0, 0\n\n    N = 0\n\n    for j in range(0, Nelem):\n\n        if N == 4:\n            break\n\n        if a in abcd[j] and b in abcd[j] and j != h:\n            N += 1\n            el1 = j + 1\n\n        if b in abcd[j] and c in abcd[j] and j != h:\n            N += 1\n            el2 = j + 1\n\n        if c in abcd[j] and d in abcd[j] and j != h:\n            N += 1\n            el3 = j + 1\n\n        if d in abcd[j] and a in abcd[j] and j != h:\n            N += 1\n            el4 = j + 1\n\n    return [el1, el2, el3, el4]\n",
        "prompt": "Function to fill the final mesh file.",
        "task_id": "8685",
        "test_list": [
            "assert Neighbourgs([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]], 0) == [1, 2, 3, 4]",
            "assert Neighbourgs([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]], 4) == [0, 1, 2, 3]",
            "assert Neighbourgs([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]], 2) == [0, 1, 3, 4]",
            "assert Neighbourgs([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]], 1) == [0, 2, 3, 4]",
            "assert Neighbourgs([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]], 3) == [0, 1, 2, 3]"
        ]
    },
    {
        "func_name": "_dim_compressor",
        "code": "def _dim_compressor(dims, inds):  # pragma: no cover\n    blocksize_id = blocksize_op = 1\n    autoplace_count = 0\n    for i, dim in enumerate(dims):\n        if dim < 0:\n            if blocksize_op > 1:\n                yield (blocksize_op, 1)\n                blocksize_op = 1\n            elif blocksize_id > 1:\n                yield (blocksize_id, 0)\n                blocksize_id = 1\n            autoplace_count += dim\n        elif i in inds:\n            if blocksize_id > 1:\n                yield (blocksize_id, 0)\n                blocksize_id = 1\n            elif autoplace_count < 0:\n                yield (autoplace_count, 1)\n                autoplace_count = 0\n            blocksize_op *= dim\n        else:\n            if blocksize_op > 1:\n                yield (blocksize_op, 1)\n                blocksize_op = 1\n            elif autoplace_count < 0:\n                yield (autoplace_count, 1)\n                autoplace_count = 0\n            blocksize_id *= dim\n    yield (\n        (blocksize_op, 1)\n        if blocksize_op > 1\n        else (blocksize_id, 0)\n        if blocksize_id > 1\n        else (autoplace_count, 1)\n    )",
        "prompt": "Helper function for ``dim_compress`` that does the heavy lifting.",
        "task_id": "8694",
        "test_list": [
            "assert list(_dim_compressor([1, 2, -3, 4], [1, 3])) == [(1, 1), (2, 1), (1, 0), (4, 1)]",
            "assert list(_dim_compressor([2, -1, 3, 4], [1, 3])) == [(2, 1), (1, 0), (3, 1), (4, 1)]",
            "assert list(_dim_compressor([0, 0, 0, 0], [])) == [(1, 1), (1, 1), (1, 1), (1, 1)]",
            "assert list(_dim_compressor([-2, 3, -1, 4], [0, 2])) == [(1, 0), (3, 1), (1, 0), (4, 1)]",
            "assert list(_dim_compressor([5, -2, 0, 3], [0, 2])) == [(5, 1), (1, 0), (1, 1), (3, 1)]"
        ]
    },
    {
        "func_name": "find_gridsize",
        "code": "def find_gridsize(row):\n    y = 0\n    min_y = 0\n    max_y = 0\n    x = 0\n    min_x = 0\n    max_x = 0\n\n    for item in row:\n        if item[0] == 'D':\n            y -= int(item[1:])\n            if y < min_y: min_y = y\n        elif item[0] == 'U':\n            y += int(item[1:])\n            if y > max_y: max_y = y\n        elif item[0] == 'L':\n            x -= int(item[1:])\n            if x < min_x: min_x = x\n        elif item[0] == 'R':\n            x += int(item[1:])\n            if x > max_x: max_x = x\n        else: print('ERROR - should never reach this')\n    return min_y, max_y, min_x, max_x",
        "prompt": "Finds minimum dimensions for a grid",
        "task_id": "8830",
        "test_list": [
            "assert find_gridsize(['D10', 'U5', 'L3', 'R2']) == (7, 12, -3, 2)",
            "assert find_gridsize(['U20', 'R20', 'D20', 'L20']) == (20, 40, 20, 20)",
            "assert find_gridsize(['U10', 'R5', 'D5', 'L5']) == (5, 15, 5, 5)",
            "assert find_gridsize(['D5', 'U5', 'L5', 'R5']) == (0, 0, 0, 0)",
            "assert find_gridsize(['D20', 'U10', 'L10', 'R10']) == (-20, 10, -10, 10)"
        ]
    },
    {
        "func_name": "simple_filler",
        "code": "\nWHITE = 0\nBLACK = 1\nEITHER = 2\n\ndef simple_filler(arr, runs):\n    k = 0  # index for runs\n    on_black = 0\n    allowed = arr[:]\n    for i in range(len(arr)):\n        if arr[i] == WHITE:\n            if on_black > 0:\n                k += 1  # move to the next pattern\n            on_black = 0\n        elif arr[i] == BLACK:\n            on_black += 1\n        else:  # arr[i] == EITHER\n            if k >= len(runs):\n                break\n            elif 0 < on_black < runs[k]:  # this must be part of this sequence\n                allowed[i] = BLACK\n                on_black += 1\n            elif on_black == 0 and k > 0 and i > 0 and arr[i - 1] == BLACK:  # this must be a white ending a sequence\n                allowed[i] = WHITE\n            else:\n                break  # too many unknowns\n\n    # put whites next to any 1 runs. Very special case\n    if all([r == 1 for r in runs]):\n        for i in range(len(arr)):\n            if arr[i] == BLACK:\n                if i > 0:\n                    allowed[i - 1] = WHITE\n                if i < len(arr) - 1:\n                    allowed[i + 1] = WHITE\n\n    return allowed\n",
        "prompt": "fill in black gaps and whites ending sequences. The overlap algorithm might miss these",
        "task_id": "8959",
        "test_list": [
            "assert simple_filler([0, 0, 0, 0, 1, 0, 2, 0, 1, 0, 0, 1, 0], [1, 1, 1, 1]) == [0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0]",
            "assert simple_filler([0, 1, 0, 2, 0, 1, 0, 0, 1, 0], [1, 1, 1]) == [0, 1, 0, 1, 0, 1, 0, 0, 1, 0]",
            "assert simple_filler([0, 0, 0, 0, 0, 1, 0, 2, 0, 1, 0, 0, 1, 0], [1, 1, 1, 1]) == [0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0]",
            "assert simple_filler([0, 0, 1, 0, 2, 0, 1, 0, 0], [1, 1, 1]) == [0, 0, 1, 0, 1, 0, 1, 0, 0]",
            "assert simple_filler([0, 0, 0, 1, 0, 2, 0, 1, 0, 0, 1, 0], [1, 1, 1, 1]) == [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0]"
        ]
    },
    {
        "func_name": "updateRHS",
        "code": "\ndef updateRHS(vname, expr, i='i', j='j', k='k', update=False, updateq=False, rhs=None):\n    varname = {'velocity': 'rhs_x', 'pressure': 'rhs_y', 'temperature': 'rhs_z'}\n    dim = 3 if rhs == 'rhs_z' else 2 if rhs == 'rhs_y' else 1\n\n    if dim == 3:\n        rhs_expr = 'rhs('+i+','+j+','+k+',indvars('+str(varname[vname])+'))'\n    elif dim == 2:\n        rhs_expr = 'rhs('+i+','+j+',indvars('+str(varname[vname])+'))'\n    elif dim == 1:\n        rhs_expr = 'rhs('+i+',indvars('+str(varname[vname])+'))'\n\n    if not update:\n        out = rhs_expr + ' = ' + ' ' + expr\n    else:\n        out = rhs_expr + ' = ' + rhs_expr + ' ' + expr\n\n    if updateq:\n        if dim == 3:\n            q = 'q('+i+','+j+','+k+',indvars('+str(varname[vname])+'))'\n        elif dim == 2:\n            q = 'q('+i+','+j+',indvars('+str(varname[vname])+'))'\n        elif dim == 1:\n            q = 'q('+i+',indvars('+str(varname[vname])+'))'\n\n        if not update:\n            out = q + ' = ' + ' ' + expr\n        else:\n            out = q + ' = ' + q + ' ' + expr\n\n    return out\n",
        "prompt": "updateRHS is a kernelinternal function. Produces Fortran code with arithmetic expression corresponding to the RHS or an update of the RHS.",
        "task_id": "8978",
        "test_list": [
            "assert updateRHS('temperature', 'T', i='k', update=False, updateq=True) == 'rhs(k,indvars(rhs_z)) = q(k,indvars(rhs_z)) T rhs(k,indvars(rhs_z))'",
            "assert updateRHS('velocity', 'u', update=True, updateq=True) == 'rhs(i,j,indvars(rhs_x)) = rhs(i,j,indvars(rhs_x)) u rhs(i,j,indvars(rhs_x)) = q(i,j,indvars(rhs_x)) u rhs(i,j,indvars(rhs_x))'",
            "assert updateRHS('velocity', 'u', i='i', j='j', k='k', update=False, updateq=False) == 'rhs(i,j,indvars(rhs_x)) = u rhs(i,j,indvars(rhs_x))'",
            "assert updateRHS('pressure', 'p', i='x', j='y', update=False, updateq=False) == 'rhs(x,y,indvars(rhs_y)) = p rhs(x,y,indvars(rhs_y))'",
            "assert updateRHS('pressure', 'p', i='x', j='y', update=True, updateq=False) == 'rhs(x,y,indvars(rhs_y)) = rhs(x,y,indvars(rhs_y)) p rhs(x,y,indvars(rhs_y))'"
        ]
    },
    {
        "func_name": "poker_hand",
        "code": "\nDEALT = 5\nCARDS = ['Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King']\n\ndef poker_hand(phand):\n    x = 0\n    y = 1\n    count = 13\n    evaluate = \"\"\n    while x < DEALT:\n        while y < DEALT:\n            if phand[x] == phand[y]:\n                evaluate = \"Loser\"   \n            y += 1\n        x += 1\n    \n    if evaluate != \"Loser\":\n        while count > DEALT:\n            if phand[DEALT-1] == count:\n                evaluate = \"{}\".format(CARDS[count-1])\n            elif phand[DEALT-1] == (DEALT-1):\n                evaluate = \"Wheel\"\n            count -= 1\n    if evaluate == \"Loser\" or evaluate == \"Wheel\":\n        return evaluate\n    else:\n        evaluate = \" {} Low\".format(evaluate)\n        return evaluate\n",
        "prompt": "Formatted print of a hand of cards.",
        "task_id": "9076",
        "test_list": [
            "assert poker_hand(['Ace', 'Ace', '2', '3', '4']) == 'Ace Low'",
            "assert poker_hand(['Ace', '2', '3', '4', '5']) == 'Ace Low'",
            "assert poker_hand(['Ace', 'Ace', 'Ace', 'Ace', 'Ace']) == 'Ace Low'",
            "assert poker_hand(['Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King']) == 'Wheel'",
            "assert poker_hand(['Ace', 'Ace', 'Ace', 'Ace', 'Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King']) == 'Ace Low'"
        ]
    },
    {
        "func_name": "Merge",
        "code": "\ndef Merge(arr, l, m, r, final_state):\n    temp_state = final_state\n    en, val = final_state\n    enum = [None, None, None, None]\n    if arr[m] > arr[m+1]:\n        if en == enum[0]:\n            temp_state = [enum[3], arr[m]]  # Maxima\n        elif en == enum[1] or en is None:\n            temp_state = [enum[1], arr[r]]  # Decreasing\n        elif en == enum[2]:  # Specific Minima\n            temp_state = [en, arr[m + 1]]\n        else:  # Add elif for maxima and minima case\n            temp_state = [en, arr[m]]\n    elif arr[m] < arr[m+1]:\n        if en == enum[1]:\n            temp_state = [enum[2], arr[m]]  # Minima\n        elif en == enum[0] or en is None:\n            temp_state = [enum[0], arr[l]]  # Increasing\n        elif en == enum[3]:  # Specific Maxima case\n            temp_state = [en, arr[m + 1]]\n        else:\n            temp_state = [en, arr[m]]\n    return temp_state\n",
        "prompt": "Conquer method that just compares the middle and next to middle element and decides the state based on the previous persisted state.",
        "task_id": "9287",
        "test_list": [
            "assert Merge([2, 2, 2, 2, 2], 0, 2, 4, [None, 2, 2, 2, 2, 2]) == [2, 2]",
            "assert Merge([1, 3, 2, 4, 5], 0, 2, 4, [None, 1, 3, 2, 4, 5]) == [1, 3]",
            "assert Merge([5, 4, 3, 2, 1], 0, 2, 4, [None, 5, 4, 3, 2, 1]) == [5, 4]",
            "assert Merge([1, 3, 5, 7, 9], 0, 2, 4, [None, 1, 3, 5, 7, 9]) == [1, 3]",
            "assert Merge([9, 7, 5, 3, 1], 0, 2, 4, [None, 9, 7, 5, 3, 1]) == [9, 7]"
        ]
    },
    {
        "func_name": "local_computecov",
        "code": "def local_computecov(start_list, end_list, local_entry):\n        ret_cov = 0\n        Ls = local_entry[0]\n        Le = local_entry[1]\n        for Ts, Te in zip(start_list, end_list):\n            if Ls > Ts and Ls < Te and Le > Ts and Le < Te:\n                # in\n                ret_cov += Le - Ls\n            if Ls < Ts and Ls < Te and Le > Ts and Le < Te:\n                # start out\n                ret_cov += Le - Ts\n            if Ls > Ts and Ls < Te and Le > Ts and Le > Te:\n                # end out\n                ret_cov += Te - Ls\n            if Ls < Ts and Ls < Te and Le > Ts and Le > Te:\n                # start&end out\n                ret_cov += Te - Ts\n        return (ret_cov)",
        "prompt": "Computes the local cov value Ls = local entry start Le = local entry end Ts = true start of core gene Te = true end of core gene",
        "task_id": "9312",
        "test_list": [
            "assert local_computecov([0, 1, 2], [3, 4, 5], [1, 4]) == 6",
            "assert local_computecov([0, 1, 2], [3, 4, 5], [0, 0]) == 0",
            "assert local_computecov([1, 2, 3], [4, 5, 6], [3, 6]) == 0",
            "assert local_computecov([5, 6, 7], [8, 9, 10], [6, 9]) == 6",
            "assert local_computecov([1, 2, 3], [4, 5, 6], [2, 5]) == 4"
        ]
    },
    {
        "func_name": "calcfwhm",
        "code": "def calcfwhm(x,y):\n\tymin,ymax = min(y),max(y)\n\ty_hpeak = ymin + .5 *(ymax-ymin)\n\tx_hpeak = []\n\tNPT = len(x)\n\tfor i in range(NPT):\n\t\tif y[i] >= y_hpeak:\n\t\t\ti1 = i\n\t\t\tbreak\n\tfor i in range(i1+1,NPT):\n\t\tif y[i] <= y_hpeak:\n\t\t\ti2 = i\n\t\t\tbreak\n\t\tif i == NPT-1: i2 = i\n\tif y[i1] == y_hpeak: x_hpeak_l = x[i1]\n\telse:\n\t\tx_hpeak_l = (y_hpeak-y[i1-1])/(y[i1]-y[i1-1])*(x[i1]-x[i1-1])+x[i1-1]\n\tif y[i2] == y_hpeak: x_hpeak_r = x[i2]\n\telse:\n\t\tx_hpeak_r = (y_hpeak-y[i2-1])/(y[i2]-y[i2-1])*(x[i2]-x[i2-1])+x[i2-1]\n\tx_hpeak = [x_hpeak_l,x_hpeak_r]\n\n\tfwhm = abs(x_hpeak[1]-x_hpeak[0])\n\tfor i in range(NPT):\n\t\tif y[i] == ymax: \n\t\t\tjmax = i\n\t\t\tbreak\n\txpeak = x[jmax]\n\treturn (fwhm,xpeak,ymax)",
        "prompt": "calcfwhm(x,y) with input x,y vector this function calculate fwhm and return (fwhm,xpeak,ymax) x input independent variable y input dependent variable fwhm return full width half maximum xpeak return x value at y = ymax",
        "task_id": "9513",
        "test_list": [
            "assert calcfwhm([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == (4, 5, 5)",
            "assert calcfwhm([1, 2, 3, 4, 5, 6, 7, 8, 9], [9, 8, 7, 6, 5, 4, 3, 2, 1]) == (8, 1, 9)",
            "assert calcfwhm([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == (10, 1, 11)",
            "assert calcfwhm([1, 3, 7, 1, 3, 7, 1, 3, 7], [1, 2, 3, 4, 5, 6, 7, 8, 9]) == (6, 7, 9)",
            "assert calcfwhm([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == (9, 1, 10)"
        ]
    },
    {
        "func_name": "get_robot_angles",
        "code": "def get_robot_angles(min_human_angles, max_human_angles, min_robot_angles, max_robot_angles, human_angles, robot_angles):\n\n    # approach for index, middle and thumb: high finger human_angle should lead to small robot_angles\n    for i in range(3):\n\n        human_angle = human_angles[i]\n        max_human_angle = max_human_angles[i]\n        min_human_angle = min_human_angles[i]\n        max_robot_angle = max_robot_angles[i]\n        min_robot_angle = min_robot_angles[i]\n\n        # preventing to open hand too far\n        if human_angle >= max_human_angle:\n            robot_angles[i] = min_robot_angle\n\n        # preventing to close hand too far\n        elif human_angle <= min_human_angle:\n            robot_angles[i] = max_robot_angle\n\n        # angles in valid working range, interpolating\n        elif (human_angle < max_human_angle) and (human_angle > min_human_angle):\n            hand_range = max_human_angle - min_human_angle\n            robot_range = max_robot_angle - min_robot_angle\n            robot_angles[i] = (max_human_angle - human_angle) * robot_range / hand_range\n\n        else:\n            robot_angles = min_robot_angles[:]\n            break\n\n    # approach for spread: high finger human_angle should lead to high robot_angles human_angle\n    human_spread = human_angles[3]\n    max_human_spread = max_human_angles[3]\n    min_human_spread = min_human_angles[3]\n    max_robot_spread = max_robot_angles[3]\n    min_robot_spread = min_robot_angles[3]\n\n    if human_spread >= max_human_spread:\n        robot_angles[3] = max_robot_spread\n    elif human_spread <= min_human_spread:\n        robot_angles[3] = min_robot_spread\n    elif (human_spread < max_human_spread) and (human_spread > min_human_spread):\n        hand_range_spread = max_human_spread - min_human_spread\n        robot_range_spread = max_robot_spread - min_robot_spread\n        robot_angles[3] = (human_spread - min_human_spread) * robot_range_spread / hand_range_spread\n    else:\n        robot_angles = min_robot_angles[:]\n\n    return robot_angles",
        "prompt": "Creates a mapping from human finger flexion angles to robot commands. For the flexion angles of thumb, index and middle finger a high value for the human angle should result in a low value for the robotic hand angle. Contrarily, for the spread angle between index and middle finger a high value for the human angle should result in a high value for the robotic hand angle. The two code blocks are very similar, in that they clip the robotic hand angle to its specified maximum / minimum values if necessary and they map the human angle to the robotic hand angle if in the robotic hand's working range.",
        "task_id": "9518",
        "test_list": [
            "assert get_robot_angles([0, 0, 0, 90], [180, 180, 180, 90], [0, 0, 0, 0], [180, 180, 180, 90], [90, 90, 90, 90], [90, 90, 90, 90]) == [0, 0, 0, 90]",
            "assert get_robot_angles([0, 0, 0, 0], [180, 180, 180, 90], [0, 0, 0, 0], [180, 180, 180, 90], [180, 180, 180, 90], [180, 180, 180, 90]) == [0, 0, 0, 0]",
            "assert get_robot_angles([90, 90, 90, 0], [180, 180, 180, 90], [0, 0, 0, 0], [180, 180, 180, 90], [90, 90, 90, 45], [90, 90, 90, 45]) == [90, 90, 90, 45]",
            "assert get_robot_angles([180, 180, 180, 90], [180, 180, 180, 90], [0, 0, 0, 0], [180, 180, 180, 90], [180, 180, 180, 90], [180, 180, 180, 90]) == [0, 0, 0, 90]",
            "assert get_robot_angles([0, 0, 0, 0], [180, 180, 180, 90], [180, 180, 180, 90], [0, 0, 0, 0], [0, 0, 0, 0], [180, 180, 180, 90]) == [180, 180, 180, 90]"
        ]
    },
    {
        "func_name": "normalizeDate",
        "code": "def normalizeDate(match):\n\tmonths = {\"Jan\": 1, \"Feb\": 2, \"Mar\": 3, \"Apr\": 4, \"May\": 5, \"Jun\": 6, \"Jul\": 7, \n\t\"Aug\": 8, \"Sep\": 9,  \"Oct\": 10, \"Nov\": 11, \"Dec\": 12, \"January\": 1,  \"February\": 2, \n\t\"March\": 3, \"April\": 4, \"May\": 5, \"June\": 6, \"July\": 7, \"August\": 8, \n\t\"September\": 9, \"October\": 10, \"November\": 11, \"December\": 12}\n\tmonth30Day = set([4, 6, 9, 11])\n\tmonth31Day = set([1, 3, 5, 7, 8, 10, 12])\n\n\t# Date format: Month Name DD, YYY \n\tif match[0] != '':\n\t\tmonth = months[match[0].replace(\".\", \"\")]\n\t\tday = int(match[1])\n\t\tyear = int(match[2])\n\n\t# Date format: MM/DD/YYYY || MM-DD-YYYY\n\telif match[3] != '':\n\t\tmonth = int(match[4])\n\t\tday = int(match[5])\n\t\tyear = int(match[6])\n\n\t# Rule out invalid dates\n\tif (month < 1 or month > 12) or (month == 2 and (day < 1 or day > 29)) or \\\n\t\t(month in month30Day and (day < 1 or day > 30)) or \\\n\t\t(month in month31Day and (day < 1 or day > 31)):\n\t\t\treturn\n\n\t# Change YY to YYYY\n\tif len(str(year)) == 2:\n\t\tif year < 19:\n\t\t\tyear = int('20' + str(year))\n\t\telse:\n\t\t\tyear = int('19' + str(year))\n\tif year < 1918 or year > 2018:\n\t\treturn\n\n\tmonth = str(month) if len(str(month)) == 2 else '0' + str(month)\n\tday = str(day) if len(str(day)) == 2 else '0' + str(day)\n\treturn (month + '-' + day + '-' + str(year))",
        "prompt": "Change date tokens to MMDDYYYY format.",
        "task_id": "9626",
        "test_list": [
            "assert normalizeDate(['03', '15', '2021']) == '03-15-2021'",
            "assert normalizeDate(['April', '31', '2021']) == '04-31-2021'",
            "assert normalizeDate(['June', '15', '2021']) == '06-15-2021'",
            "assert normalizeDate(['March', '15', '2021']) == '03-15-2021'",
            "assert normalizeDate(['January', '1', '2021']) == '01-01-2021'"
        ]
    },
    {
        "func_name": "divide_num_by_weights_and_round",
        "code": "def divide_num_by_weights_and_round(in_num, weights):\n\n    assert isinstance(in_num, int)\n    for weight in weights:\n        assert isinstance(weight, int) or isinstance(weight, float)\n\n    num_vals = len(weights)\n\n    # Normalized the weights\n    norm_weights = [weight/float(sum(weights)) for weight in weights]\n\n    unrounded_vals = [in_num * norm_weight for norm_weight in norm_weights]\n\n\n    initial_guess_rounded_vals = [int(val) for val in unrounded_vals]\n\n    max_search_diff = 2\n    search_diff_range = range(-max_search_diff, max_search_diff + 1)\n\n    best_rounded_vals = None\n    best_total_abs_deviation = None\n\n    for diffs in itertools.product(search_diff_range, repeat=num_vals):\n        rounded_vals = initial_guess_rounded_vals[:]  # Hard-copy\n        total_abs_deviation = 0\n        for index in range(num_vals):\n            rounded_vals[index] += diffs[index]\n            total_abs_deviation += abs(rounded_vals[index] - unrounded_vals[index])\n\n        if sum(rounded_vals) == in_num:\n            if best_rounded_vals == None or total_abs_deviation < best_total_abs_deviation:\n                best_rounded_vals = rounded_vals\n                best_total_abs_deviation = total_abs_deviation\n\n    # Consistent checks\n    assert best_rounded_vals != None\n    assert best_total_abs_deviation != None\n    assert num_vals == len(best_rounded_vals)\n    for val in best_rounded_vals:\n        assert isinstance(val, int)\n\n    return best_rounded_vals",
        "prompt": "Divide up the input value (an integer) by the pieces according to the specified weights and round the return values. Notes",
        "task_id": "9656",
        "test_list": [
            "assert divide_num_by_weights_and_round(100, [0, 50, 50]) == [0, 25, 25]",
            "assert divide_num_by_weights_and_round(100, [1, 1, 1]) == [33, 33, 33]",
            "assert divide_num_by_weights_and_round(100, [0, 0, 0]) == [0, 0, 0]",
            "assert divide_num_by_weights_and_round(100, [0, 100, 0]) == [0, 100, 0]",
            "assert divide_num_by_weights_and_round(100, [1, 2, 3]) == [0, 0, 33]"
        ]
    },
    {
        "func_name": "get_inout_dims",
        "code": "\nfrom typing import Union\n\ndef get_inout_dims(net_name: str, dim_node_label: int, dim_arc_label: int, dim_target: int, problem: str, dim_state: int,\n                   hidden_units: Union[None, int, list[int]],\n                   *, layer: int = 0, get_state: bool = False, get_output: bool = False) -> tuple[int, list[int]]:\n    assert net_name in ['state', 'output']\n    assert layer >= 0\n    if len(problem) == 1: problem += '1'\n    DS = dim_state\n    NL, AL, T = dim_node_label, dim_arc_label, dim_target\n\n    # if LGNN, get MLPs layers for gnn in layer 2+\n    if layer > 0:\n        GS, GO, P = get_state, get_output, problem[0]\n        if DS != 0: NL, AL = NL + DS * GS + T * (P != 'a') * GO, AL + T * (P == 'a') * GO\n        else: NL, AL = NL + layer * NL * GS + ((layer - 1) * GS + 1) * T * (P != 'a') * GO, AL + T * (P == 'a') * GO\n\n    # MLP output\n    if net_name == 'output':\n        input_shape = (problem[0] == 'a') * (NL + AL + DS) + NL + dim_state\n        output_shape = T\n\n    # MLP state\n    else:\n        input_shape = AL + 2 * NL + DS * (1 + (problem[1] == '1'))\n        input_shape += NL * (DS == 0) * (problem[1] == '2')\n        output_shape = DS if DS else NL\n\n    # hidden part\n    if hidden_units is None or type(hidden_units) == int and hidden_units <= 0: hidden_units = []\n    if type(hidden_units) == list: layers = hidden_units + [output_shape]\n    else: layers = [hidden_units, output_shape]\n    return input_shape, layers\n",
        "prompt": "Calculate input and output dimension for the MLP of state and output",
        "task_id": "9897",
        "test_list": [
            "assert get_inout_dims('state', 2, 1, 1, 'a', 0, None, layer=0, get_state=True, get_output=False) == (5, [5])",
            "assert get_inout_dims('output', 2, 1, 1, 'a', 0, None, layer=2, get_state=False, get_output=True) == (5, [5])",
            "assert get_inout_dims('state', 2, 1, 1, 'a', 0, None, layer=1, get_state=True, get_output=False) == (7, [7])",
            "assert get_inout_dims('state', 2, 1, 1, 'a', 0, [3, 2], layer=0, get_state=True, get_output=False) == (9, [9, 2])",
            "assert get_inout_dims('output', 2, 1, 1, 'a', 0, None, layer=0, get_state=False, get_output=True) == (3, [3])"
        ]
    },
    {
        "func_name": "steerShip",
        "code": "def steerShip(directionCommandsList):\n    #first value is north or south. Second value is east or west. Integers.\n    currentPosition = (0, 0)\n    # first value is north or south. Second value is east or west. Binary.\n    currentDirection = (0, 1)\n    directionDict = {\n                    \"N\" : (1, 0),\n                    \"S\" : (-1, 0),\n                    \"E\" : (0, 1),\n                    \"W\" : (0, -1),\n                    }\n    angleDict = {\n                    (1, 0) : 90,\n                    (-1, 0) : 270,\n                    (0, 1) : 0,\n                    (0, -1) : 180,\n                    }\n\n    for directionCommand in directionCommandsList:\n\n        if directionCommand[0] == \"F\":\n            tempPosition = tuple(map(operator.mul, currentDirection, (int(directionCommand[1]), int(directionCommand[1]) )))\n            currentPosition = tuple(map(operator.add, currentPosition, tempPosition))\n\n        elif directionCommand[0] in [\"N\", \"S\", \"E\", \"W\"]:\n            tempDirection = directionDict[directionCommand[0]]\n            tempPosition = tuple(map(operator.mul, tempDirection, (int(directionCommand[1]), int(directionCommand[1]) )))\n            currentPosition = tuple(map(operator.add, currentPosition, tempPosition))\n\n        elif directionCommand[0]  in [\"R\", \"L\"]:\n\n            angleDirection = angleDict[currentDirection]\n\n            if directionCommand[0]  == \"R\":\n                angleDirection = angleDirection - int(directionCommand[1])\n            elif directionCommand[0]  == \"L\":\n                angleDirection = angleDirection + int(directionCommand[1])\n\n            if angleDirection in [-90, 270] :\n                currentDirection = (-1, 0)\n            elif angleDirection in [180, -180, 540]:\n                currentDirection = (0, -1)\n            elif angleDirection in [90, -270, 450]:\n                currentDirection = (1, 0)\n            elif angleDirection in [0, 360]:\n                currentDirection = (0, 1)\n\n    return currentPosition, currentDirection",
        "prompt": "Steer ship by command directions.",
        "task_id": "9923",
        "test_list": [
            "assert steerShip([('W', 10), ('F', 10), ('L', 90), ('F', 10), ('R', 180), ('F', 10)]) == ((0, -10), (0, -1))",
            "assert steerShip([('N', 8), ('F', 2), ('R', 90), ('F', 1), ('L', 90), ('F', 2)]) == ((0, 8), (0, 1))",
            "assert steerShip([('F', 5), ('L', 90), ('F', 5), ('R', 180), ('F', 5)]) == ((0, 0), (0, -1))",
            "assert steerShip([('E', 5), ('F', 5), ('L', 90), ('F', 5), ('R', 180), ('F', 5)]) == ((5, 0), (1, 0))",
            "assert steerShip([('F', 10), ('N', 3), ('F', 7), ('R', 90), ('F', 11)]) == ((10, 4), (1, 0))"
        ]
    },
    {
        "func_name": "extract_css_rule",
        "code": "def extract_css_rule(content, pos, is_backward=False):\n\tresult = '' \n\tc_len = len(content)\n\toffset = pos \n\tbrace_pos = -1\n\t\n\t# search left until we find rule edge\n\twhile offset >= 0:\n\t\tch = content[offset]\n\t\tif ch == '{':\n\t\t\tbrace_pos = offset\n\t\t\tbreak\n\t\telif ch == '}' and not is_backward:\n\t\t\toffset += 1\n\t\t\tbreak\n\t\t\n\t\toffset -= 1\n\t\n\t# search right for full rule set\n\twhile offset < c_len:\n\t\tch = content[offset]\n\t\tif ch == '{':\n\t\t\tbrace_pos = offset\n\t\telif ch == '}':\n\t\t\tif brace_pos != -1:\n\t\t\t\tresult = content[brace_pos:offset + 1]\n\t\t\tbreak\n\t\t\n\t\toffset += 1\n\t\n\tif result:\n\t\t# find CSS selector\n\t\toffset = brace_pos - 1\n\t\tselector = ''\n\t\twhile offset >= 0:\n\t\t\tch = content[offset]\n\t\t\tif ch in '{}/\\\\<>': break\n\t\t\toffset -= 1\n\t\t\n\t\t# also trim whitespace\n\t\tre_white = re.compile(r'^[\\s\\n\\r]+', re.MULTILINE)\n\t\tselector = re.sub(re_white, '', content[offset + 1:brace_pos])\n\t\treturn (brace_pos - len(selector), brace_pos + len(result))\n\t\n\treturn None",
        "prompt": "Extracts single CSS selector definition from source code {String} content CSS source code",
        "task_id": "9955",
        "test_list": [
            "assert extract_css_rule('h1 { font-size: 2em; }', 4) == (4, 19)",
            "assert extract_css_rule('body { color: red; }', 4) == (4, 13)",
            "assert extract_css_rule('a { color: blue; }', 4) == (4, 13)",
            "assert extract_css_rule('div { margin: 0; padding: 0; }', 4) == (4, 21)",
            "assert extract_css_rule('ul { list-style-type: none; }', 4) == (4, 22)"
        ]
    },
    {
        "func_name": "color_variant",
        "code": "\nimport six\n\ndef color_variant(color, brightness_offset=1):\n    # https://chase-seibert.github.io/blog/2011/07/29/python-calculate-lighterdarker-rgb-colors.html\n    def clamp(x):\n        return max(0, min(x, 255))\n\n    if isinstance(color, list) and len(color) == 3:\n        color = \"#{0:02x}{1:02x}{2:02x}\".format(clamp(color[0]), clamp(color[1]), clamp(color[2]))\n    if isinstance(color, six.string_types) and len(color) == 7:\n        rgb_hex = [color[x:x + 2] for x in [1, 3, 5]]\n        new_rgb_int = [int(hex_value, 16) + brightness_offset for hex_value in rgb_hex]\n        # make sure new values are between 0 and 255\n        new_rgb_int = [min([255, max([0, i])]) for i in new_rgb_int]\n        for i, n in enumerate(new_rgb_int):\n            v = hex(n)[2:]  # hex() produces \"0x88\", we want just \"88\"\n            try:\n                v = int(v)\n                v = '{:02d}'.format(v)\n            except ValueError:\n                pass\n            new_rgb_int[i] = v\n        return \"#\" + \"\".join(new_rgb_int)\n    raise NotImplementedError(\"Input provided must be RGB or hex color format\")\n",
        "prompt": "Make a color darker or lighter. Shift a color towards more darker (negative ``brightness_offset``) or more lighter (positive ``brightness_offset``).",
        "task_id": "10084",
        "test_list": [
            "assert color_variant('#000000', 255) == '#000000', 'Black should remain black when brightness offset is maximum'",
            "assert color_variant('#000000', 0) == '#000000', 'Black should remain black when brightness offset is 0'",
            "assert color_variant('#808080', 20) == '#7f7f7f', 'Gray should become lighter when brightness offset is positive'",
            "assert color_variant('#ff0000', 10) == '#ff0a0a', 'Red should become darker when brightness offset is positive'",
            "assert color_variant([255, 255, 255], 0) == '#ff', 'White should remain white when brightness offset is 0'"
        ]
    },
    {
        "func_name": "add_dummy_tags",
        "code": "def add_dummy_tags(tree, tag='*'):\n    assert isinstance(tree, str), tree\n    assert len(tree) > 0, tree\n\n    i = 0\n    max_idx = (len(tree) - 1)\n    new_tree = ''\n    while i <= max_idx:\n        if tree[i] == '(':\n            new_tree += tree[i]\n            i += 1\n            while tree[i] != ' ':\n                new_tree += tree[i]\n                i += 1\n        elif tree[i] == ')':\n            new_tree += tree[i]\n            if i == max_idx:\n                break\n            i += 1\n        else: # it's a terminal symbol\n            new_tree += '(' + tag + ' '\n            while tree[i] not in (' ', ')'):\n                new_tree += tree[i]\n                i += 1\n            new_tree += ')'\n        while tree[i] == ' ':\n            if i == max_idx:\n                break\n            new_tree += tree[i]\n            i += 1\n    assert i == max_idx, i\n    return new_tree",
        "prompt": "Turns '(NP The tagless tree)' into '(NP ( The) ( tagless) ( tree))'.",
        "task_id": "10091",
        "test_list": [
            "assert add_dummy_tags('') == 'Invalid input: string is empty'",
            "assert add_dummy_tags(123) == 'Invalid input: not a string'",
            "assert add_dummy_tags('(S (NP John) (VP (V sees) (NP Mary)))') == '(S ( (NP John) (VP ( (V sees) (NP Mary)))))'",
            "assert add_dummy_tags('(NP The tagless tree)') == '(NP ( The) ( tagless) ( tree))'",
            "assert add_dummy_tags('(NP John)') == '(NP ( John))'"
        ]
    },
    {
        "func_name": "_lcsmatrix",
        "code": "def _lcsmatrix(s1, s2):\n    m = len(s1)\n    n = len(s2) \n    mtx = [[0 for x in range(n)] for y in range(m)]\n    for i,c1 in enumerate(s1):\n        for j,c2 in enumerate(s2): \n            if c1 == c2 : \n                if i == 0 or j == 0:\n                    mtx[i][j] = 1\n                else:\n                    mtx[i][j] = mtx[i-1][j-1]+1\n            else :\n                if j == 0: \n                    mtx[i][j] = mtx[i-1][j]\n                elif i == 0:\n                    mtx[i][j] = mtx[i][j-1]\n                else :\n                    mtx[i][j] = max(mtx[i][j-1],mtx[i-1][j])\n    return mtx",
        "prompt": "compute the LCS matricx of 2 sequecnce",
        "task_id": "10159",
        "test_list": [
            "assert _lcsmatrix('ABC', 'A') == [[1, 0, 0], [1, 0, 0], [1, 0, 0]]",
            "assert _lcsmatrix('ABC', 'DEF') == [[0, 0, 0], [0, 0, 0], [0, 0, 0]]",
            "assert _lcsmatrix('AGGTAB', 'GXTXAYB') == [[0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]",
            "assert _lcsmatrix('ABC', 'ABC') == [[1, 1, 1], [1, 1, 1], [1, 1, 1]]",
            "assert _lcsmatrix('ABC', 'AC') == [[0, 1, 1], [0, 1, 1], [0, 1, 1]]"
        ]
    },
    {
        "func_name": "get_number_shards",
        "code": "\ndef get_number_shards(\n      total_size: int,\n      num_examples: int,\n      uses_precise_sharding: bool = True,\n  ) -> int:\n    overhead = 0.1\n    min_shard_size = 128 * 1024 * 1024\n    max_shard_size = 256 * 1024 * 1024\n    num_shards = 0\n    total_size += num_examples * overhead\n    max_shards_number = total_size // min_shard_size\n    if uses_precise_sharding:\n      max_shard_size = max_shard_size\n    else:\n      max_shard_size = 0.9 * max_shard_size\n    min_shards_number = total_size // max_shard_size\n    if min_shards_number <= 1024 <= max_shards_number and num_examples >= 1024:\n      return 1024\n    elif min_shards_number > 1024:\n      i = 2\n      while True:\n        n = 1024 * i\n        if n >= min_shards_number and num_examples >= n:\n          return n\n        i += 1\n    else:\n      for n in [512, 256, 128, 64, 32, 16, 8, 4, 2]:\n        if min_shards_number <= n <= max_shards_number and num_examples >= n:\n          return n\n    return 1\n",
        "prompt": "Returns number of shards for num_examples of total_size in bytes. Each shard should be at least 128MB. A pod has 1616=256 TPU devices containing 1024 TPU chips (2048 cores). So if the dataset is large enough, we want the number of shards to be a multiple of 1024, but with shards as big as possible. If the dataset is too small, we want the number of shards to be a power of two so it distributes better on smaller TPU configs (8, 16, 32, ... cores).",
        "task_id": "10167",
        "test_list": [
            "assert get_number_shards(64 * 1024 * 1024, 512, uses_precise_sharding=True) == 512",
            "assert get_number_shards(64 * 1024 * 1024, 512) == 512",
            "assert get_number_shards(128 * 1024 * 1024, 2048) == 2048",
            "assert get_number_shards(128 * 1024 * 1024, 1024) == 1024",
            "assert get_number_shards(128 * 1024 * 1024, 2048, uses_precise_sharding=True) == 2048"
        ]
    },
    {
        "func_name": "find_sim_position",
        "code": "def find_sim_position(sim_time, sim_pos, tstart, tstop):\n    sim_avg = 0\n    dsum    = 0\n    smin    =  1000000\n    smax    = -1000000\n    tcnt    = 0\n\n    tstart  = float(tstart)\n    tstop   = float(tstop)\n\n    for istep in range(0, len(sim_time)):\n        stime = sim_time[istep]\n\n        if stime > tstart and stime <= tstop:\n            dsum += sim_pos[istep]\n\n            if sim_pos[istep] < smin:\n                smin = sim_pos[istep]\n\n            if sim_pos[istep] > smax:\n                smax = sim_pos[istep]\n\n            tcnt += 1\n\n        elif stime > tstop:\n            if tcnt == 0:\n#\n#--- for the case there is no data corrected at the end of the file...\n#\n                sim_avg = 0.5 * (sim_pos[istep-1] + sim_pos[istep])\n\n                if sim_pos[istep -1] == sim_pos[istep]:\n                    smin = sim_avg\n                    smax = sim_avg\n\n                elif sim_pos[istep -1] > sim_pos[istep]:\n                    smin = sim_pos[istep]\n                    smax = sim_pos[istep-1]\n                else:\n                    smin = sim_pos[istep-1]\n                    smax = sim_pos[istep]\n                break;\n\n    if tcnt > 0:\n        sim_avg = int(dsum / tcnt)\n    \n    if sim_avg == 0:\n        smin  = 0\n        smax  = 0\n\n    return  [sim_avg, smin, smax]",
        "prompt": "for a given time find where the sim is located",
        "task_id": "10235",
        "test_list": [
            "assert find_sim_position([0, 1, 2, 3, 4], [0, 1, 2, 3, 4], 1, 3) == [2, 2, 3]",
            "assert find_sim_position([0, 1, 2, 3, 4], [0, 1, 0, 1, 0], 1, 4) == [1, 1, 1]",
            "assert find_sim_position([0, 1, 2, 3, 4], [0, 1, 2, 3, 4], 2, 4) == [3, 2, 3]",
            "assert find_sim_position([0, 1, 2, 3, 4], [0, 1, 2, 3, 4], 0, 5) == [4, 4, 4]",
            "assert find_sim_position([0, 1, 2, 3, 4], [0, 0, 0, 0, 0], 0, 4) == [0, 0, 0]"
        ]
    },
    {
        "func_name": "updateBall",
        "code": "\nimport math\nimport random\n\nWINDOW_WIDTH = 800\nWINDOW_HEIGHT = 600\nBALL_WIDTH = 10\nBALL_HEIGHT = 10\nPADDLE_WIDTH = 10\nPADDLE_HEIGHT = 80\nPADDLE_BUFFER = 10\n\ndef updateBall(paddle1YPos, paddle2YPos, ballXPos, ballYPos, ballXDirection, ballAngle):\n    BALL_X_SPEED = 5\n    BALL_Y_SPEED = 5\n\n    ballXPos = ballXPos + ballXDirection * BALL_X_SPEED * math.cos(ballAngle)\n    ballYPos = ballYPos + ballXDirection * BALL_Y_SPEED * -math.sin(ballAngle)\n    score1 = 0\n    score2 = 0\n\n    if (ballXPos <= PADDLE_BUFFER + PADDLE_WIDTH and ballYPos + BALL_HEIGHT >= paddle1YPos and\n            ballYPos <= paddle1YPos + PADDLE_HEIGHT):\n        ballXDirection = 1\n        diff = (paddle1YPos + PADDLE_HEIGHT / 2) - (ballYPos + BALL_HEIGHT / 2)\n        if diff != 0:\n            ballAngle = math.radians(diff / 35 * 80)\n        else:\n            ballAngle = math.radians(0)\n\n    elif (ballXPos <= 0):\n        score1 = 0\n        score2 = 1\n        ballXPos = WINDOW_WIDTH / 2 - BALL_WIDTH / 2\n        ballYPos = WINDOW_HEIGHT / 2 - BALL_HEIGHT / 2\n        num = random.randint(0, 1)\n        ballXDirection = 1 if num == 0 else -1\n        ballAngle = math.radians(70)\n        ballAngle = -ballAngle if random.randint(0, 1) == 0 else ballAngle\n        return [score1, score2, ballXPos, ballYPos, ballXDirection, ballAngle]\n\n    if (ballXPos + BALL_WIDTH >= WINDOW_WIDTH - PADDLE_WIDTH - PADDLE_BUFFER and ballYPos + BALL_HEIGHT >= paddle2YPos and\n            ballYPos <= paddle2YPos + PADDLE_HEIGHT):\n        ballXDirection = -1\n        diff = (paddle2YPos + PADDLE_HEIGHT / 2) - (ballYPos + BALL_HEIGHT / 2)\n        if diff != 0:\n            ballAngle = math.radians(-diff / 35 * 80)\n        else:\n            ballAngle = math.radians(0)\n\n    elif (ballXPos >= WINDOW_WIDTH - BALL_WIDTH):\n        score1 = 1\n        score2 = 0\n        ballXPos = WINDOW_WIDTH / 2 - BALL_WIDTH / 2\n        ballYPos = WINDOW_HEIGHT / 2 - BALL_HEIGHT / 2\n        num = random.randint(0, 1)\n        ballXDirection = 1 if num == 0 else -1\n        ballAngle = math.radians(70)\n        ballAngle = -ballAngle if random.randint(0, 1) == 0 else ballAngle\n        return [score1, score2, ballXPos, ballYPos, ballXDirection, ballAngle]\n\n    if (ballYPos <= 0):\n        ballYPos = 0\n        ballAngle *= -1\n    elif (ballYPos >= WINDOW_HEIGHT - BALL_HEIGHT):\n        ballYPos = WINDOW_HEIGHT - BALL_HEIGHT\n        ballAngle *= -1\n\n    return [score1, score2, ballXPos, ballYPos, ballXDirection, ballAngle]\n",
        "prompt": "computes the new ball position given the position of both paddles, its own postion and direction, also provides the score",
        "task_id": "10283",
        "test_list": [
            "assert updateBall(100, 200, 750, 550, -1, 0) == [1, 0, 745, 545, -1, 0]",
            "assert updateBall(100, 200, 750, 300, -1, 0) == [1, 0, 745, 295, -1, 0]",
            "assert updateBall(100, 200, 50, 550, 1, 0) == [0, 0, 55, 545, 1, 0]",
            "assert updateBall(100, 200, 400, 300, 1, 0) == [0, 0, 405, 295, 1, 0]",
            "assert updateBall(100, 200, 50, 50, 1, 0) == [0, 0, 55, 45, 1, 0]"
        ]
    },
    {
        "func_name": "ball_movement",
        "code": "\nimport random\n\ndef ball_movement(vertical_direct, horizontal_direct, collision=False, out=False):\n    global x_change, y_change\n    ball = {'x': 0, 'y': 0}  # Initialize ball position\n    ver = vertical_direct\n    hor = horizontal_direct\n    y_change = 10  # Define y_change\n    x_change = 10  # Define x_change\n    if vertical_direct == 'up':\n        if ball['y'] - y_change > 0:\n            ball['y'] -= y_change\n        else:\n            if collision:\n                change = random.choice((4, -4))\n                if change == 4:\n                    if y_change + change < 14:\n                        y_change += change\n                else:\n                    if y_change + change < 6:\n                        y_change += change\n                ver = 'down'\n    else:\n        if ball['y'] + y_change < 700:\n            ball['y'] += y_change\n        else:\n            if collision:\n                change = random.choice((4, -4))\n                if change == 4:\n                    if y_change + change < 14:\n                        y_change += change\n                else:\n                    if y_change + change < 6:\n                        y_change += change\n                ver = 'up'\n\n    if horizontal_direct == 'left':\n        if ball['x'] + x_change < 970:\n            ball['x'] += x_change\n        else:\n            if collision:\n                change = random.choice((4, -4))\n                if change == 4:\n                    if y_change + change < 14:\n                        y_change += change\n                else:\n                    if y_change + change < 6:\n                        y_change += change\n                hor = 'right'\n            else:\n                out = True\n    else:\n        if ball['x'] - x_change > 0:\n            ball['x'] -= x_change\n        else:\n            if collision:\n                change = random.choice((4, -4))\n                if change == 4:\n                    if y_change + change < 14:\n                        y_change += change\n                else:\n                    if y_change + change < 6:\n                        y_change += change\n                hor = 'left'\n            else:\n                out = True\n    return ver, hor, out\n",
        "prompt": "a function that controls the ball movement",
        "task_id": "10301",
        "test_list": [
            "assert ball_movement('down', 'right') == ('up', 'left', False)",
            "assert ball_movement('up', 'right') == ('down', 'right', False)",
            "assert ball_movement('up', 'left') == ('down', 'right', False)",
            "assert ball_movement('up', 'left', collision=True) == ('down', 'left', False)",
            "assert ball_movement('down', 'left') == ('up', 'left', False)"
        ]
    },
    {
        "func_name": "edit_modified_distance_dp",
        "code": "def edit_modified_distance_dp(pattern,text):\n\n    dp_matrix = [[0 for _ in range(len(text)+1)] for _ in range(len(pattern)+1)]\n    for v in range(len(pattern)+1): dp_matrix[v][0] = v\n    for h in range(len(text)+1): dp_matrix[0][h] = h\n    # Compute DP Matrix\n    for h in range(1,len(text)+1):\n        for v in range(1,len(pattern)+1):\n            dp_matrix[v][h]=min(dp_matrix[v - 1][h - 1] + (0 if pattern[v - 1] == text[h - 1] else 1),\n            dp_matrix[v][h - 1] + 1,dp_matrix[v - 1][h] + 1)\n            if v > 1 and h > 1 and pattern[v-1] == text[h - 2] and pattern[v - 2] == text[h-1]: # The tranposition condition.\n                dp_matrix[v][h] = min(dp_matrix[v][h], dp_matrix[v - 2][h - 2] + 1)\n    \n    return dp_matrix",
        "prompt": "This function takes 'pattern' and 'text' nucleotide sequences and compares them forming the DP matrix, which contains the path of the optimal alignment. It uses a modified version of the edit distance approach, which contemplates the presence of transpositions of 2 bases (its score is also 1). PARAMETERS",
        "task_id": "10340",
        "test_list": [
            "assert edit_modified_distance_dp('AG', 'AG') == [[0, 1, 2], [1, 1, 2], [2, 2, 1]]",
            "assert edit_modified_distance_dp('ACGT', 'ACG') == [[0, 1, 2, 3], [1, 1, 2, 3], [2, 2, 1, 2], [3, 3, 2, 3]]",
            "assert edit_modified_distance_dp('ACGT', 'TGCA') == [[0, 1, 2, 3, 4], [1, 1, 2, 3, 4], [2, 2, 1, 2, 3], [3, 3, 2, 1, 2], [4, 4, 3, 2, 1]]",
            "assert edit_modified_distance_dp('A', 'A') == [[0], [0, 0]]",
            "assert edit_modified_distance_dp('GATTACA', 'GCATGCU') == [[0, 1, 2, 3, 4, 5, 6, 7], [1, 1, 2, 3, 4, 5, 6, 7], [2, 2, 1, 2, 3, 4, 5, 6], [3, 2, 2, 1, 2, 3, 4, 5], [4, 3, 2, 2, 1, 2, 3, 4], [5, 4, 3, 2, 2, 1, 2, 3], [6, 5, 4, 3, 2, 2, 1, 2], [7, 6, 5, 4, 3, 2, 2, 1]]"
        ]
    },
    {
        "func_name": "poker_test",
        "code": "def poker_test(bits):\n    combination_counter=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    i=0\n    while i<=(len(bits)-3):\n        combination = [bits[i], bits[i + 1], bits[i + 2], bits[i + 3]]\n        if combination == ['0', '0', '0', '0']:\n            combination_counter[0]+=1\n        if combination == ['0', '0', '0', '1']:\n            combination_counter[1]+=1\n        if combination == ['0', '0', '1', '0']:\n            combination_counter[2]+=1\n        if combination == ['0', '0','1', '1']:\n            combination_counter[3] += 1\n        if combination == ['0', '1', '0', '0']:\n            combination_counter[4] += 1\n        if combination == ['0', '1', '0', '1']:\n            combination_counter[5] += 1\n        if combination == ['0', '1', '1', '0']:\n            combination_counter[6] += 1\n        if combination == ['0', '1', '1', '1']:\n            combination_counter[7] += 1\n        if combination == ['1', '0', '0', '0']:\n            combination_counter[8] += 1\n        if combination == ['1', '0', '0', '1']:\n            combination_counter[9] += 1\n        if combination == ['1', '0', '1', '0']:\n            combination_counter[10] += 1\n        if combination == ['1', '0', '1', '1']:\n            combination_counter[11] += 1\n        if combination == ['1', '1', '0', '0']:\n            combination_counter[12] += 1\n        if combination == ['1', '1', '0', '1']:\n            combination_counter[13] += 1\n        if combination == ['1', '1', '1', '0']:\n            combination_counter[14] += 1\n        if combination == ['1','1', '1', '1']:\n            combination_counter[15] += 1\n        i=i+4\n    return combination_counter",
        "prompt": "Test that returns ammount of 16 different combinations of bits",
        "task_id": "10352",
        "test_list": [
            "assert poker_test(['1', '1', '1', '1', '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0']) == [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0]",
            "assert poker_test(['1', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1']) == [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
            "assert poker_test(['0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1']) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
            "assert poker_test(['0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']) == [16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
            "assert poker_test(['0', '0', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1']) == [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
        ]
    },
    {
        "func_name": "follow_movements",
        "code": "\nfrom typing import List, Tuple\n\ndef follow_movements(instructions: List[str]) -> Tuple[int, int]:\n    start = 0j\n    heading = 1\n    for line in instructions:\n        direction = line[0]\n        amount = int(line[1:])\n        if direction == \"F\":\n            start += heading * amount\n        elif direction == \"N\":\n            start += 1j * amount\n        elif direction == \"S\":\n            start += -1j * amount\n        elif direction == \"E\":\n            start += amount\n        elif direction == \"W\":\n            start -= amount\n        elif direction == \"L\":\n            if amount not in {0, 90, 180, 270}:\n                raise ValueError(f\"unknown turn left amount {amount}\")\n            while amount > 0:\n                heading *= 1j\n                amount -= 90\n        elif direction == \"R\":\n            if amount not in {0, 90, 180, 270}:\n                raise ValueError(f\"unknown turn right amount {amount}\")\n            while amount > 0:\n                heading *= -1j\n                amount -= 90\n        else:\n            raise ValueError(f\"unknown command {line}\")\n    return int(start.real), int(start.imag)\n",
        "prompt": "Follow the movements as described in part 1",
        "task_id": "10450",
        "test_list": [
            "assert follow_movements(['N10', 'E5', 'S2', 'W3', 'L180', 'F1']) == (3, 8)",
            "assert follow_movements(['F10', 'R180', 'F10', 'L90', 'F10', 'R90', 'F10', 'L90']) == (0, 10)",
            "assert follow_movements(['L270', 'F10', 'R180', 'F5', 'N2', 'W1']) == (15, 2)",
            "assert follow_movements(['F10', 'N3', 'F7', 'R90', 'F11']) == (20, 3)",
            "assert follow_movements(['R270', 'F20', 'L180', 'F10', 'N5', 'E5', 'R90', 'F10']) == (20, 5)"
        ]
    },
    {
        "func_name": "replaceArray",
        "code": "def replaceArray(jsonString):\n    if jsonString[0] != \"[\" or jsonString[-1] != \"]\":\n        # return None if its not a valid json array\n        return None\n        \n    origIndex = 1\n    resIndex = 1\n    res = \"{\"\n    itemCount = 0\n    bracketCount = 0\n    \n    \n    \n    # check if its an object array or string array\n    isJsonObjectArray = jsonString[origIndex] == \"{\"\n    \n    if not isJsonObjectArray:\n        res += \"\\\"\" + str(itemCount) + \"\\\":\"\n        resIndex += len(str(itemCount)) + 3\n        \n    while origIndex < len(jsonString):\n        c = jsonString[origIndex]\n        if c == \"]\":\n            # because we recurse everytime we see \"[\", \"]\" is always a return\n            res += \"}\"\n            resIndex += 1\n            origIndex += 1\n            return (res, origIndex, resIndex)\n        elif c == \"[\":\n            subRes = replaceArray(jsonString[origIndex:])\n            origIndex += subRes[1]\n            resIndex += subRes[2]\n            res += subRes[0]\n        elif c == \"{\" and isJsonObjectArray:\n            if bracketCount == 0:\n                res += \"\\\"\" + str(itemCount) + \"\\\":\"\n                resIndex += len(str(itemCount)) + 3\n            bracketCount += 1\n            res += c\n            resIndex += 1\n            origIndex += 1\n        elif c == \"}\" and isJsonObjectArray and bracketCount == 1:\n            # end of object in array reached\n            res += c\n            resIndex += 1\n            origIndex += 1\n            itemCount += 1\n            bracketCount -= 1\n        elif c == \"}\" and isJsonObjectArray:\n            res += c\n            resIndex += 1\n            origIndex += 1\n            bracketCount -= 1\n        elif c == \",\" and jsonString[origIndex - 1] == \"\\\"\" and not isJsonObjectArray:\n            # no arrays of mixed type so \", means you're in an array of strings\n            itemCount += 1\n            res += c + \"\\\"\" + str(itemCount) + \"\\\":\"\n            resIndex += 2 + len(str(itemCount))\n            origIndex += 1\n            \n        else:\n            res += c\n            resIndex += 1\n            origIndex += 1\n        \n\n    print(\"DEBUG: WHY AM I HERE\")\n    return (res, origIndex)     # should not happen because string should always end in \"]\"",
        "prompt": "Replaces json arrays with pseudo arrays for firebaseStr",
        "task_id": "10517",
        "test_list": [
            "assert replaceArray('[1,2,3,4,5]') == ('[1,2,3,4,5]', 13, 17)",
            "assert replaceArray('[\"apple\",\"banana\",\"cherry\"]') == ('[\"apple\",\"banana\",\"cherry\"]', 15, 21)",
            "assert replaceArray('[\"one\",\"two\",\"three\"]') == ('[\"one\",\"two\",\"three\"]', 13, 17)",
            "assert replaceArray('[{\"key\":\"value\"},{\"key\":\"value2\"}]') == ('[{\"key\":\"value\"},{\"key\":\"value2\"}]', 29, 41)",
            "assert replaceArray('[{\"key\":\"value1\"},{\"key\":\"value2\"},{\"key\":\"value3\"}]') == ('[{\"key\":\"value1\"},{\"key\":\"value2\"},{\"key\":\"value3\"}]', 29, 41)"
        ]
    },
    {
        "func_name": "draw_line_bressenham",
        "code": "def draw_line_bressenham(start, end):\n    z1, y1, x1 = start[:]\n    z2, y2, x2 = end[:]\n    ListOfPoints = [[z1],[y1],[x1]]\n    def append(z, y, x):\n        ListOfPoints[0].append(z1)\n        ListOfPoints[1].append(y1)\n        ListOfPoints[2].append(x1)\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    dz = abs(z2 - z1)\n    if (x2 > x1):\n        xs = 1\n    else:\n        xs = -1\n    if (y2 > y1):\n        ys = 1\n    else:\n        ys = -1\n    if (z2 > z1):\n        zs = 1\n    else:\n        zs = -1\n\n    # Driving axis is X-axis\"\n    if (dx >= dy and dx >= dz):\n        p1 = 2 * dy - dx\n        p2 = 2 * dz - dx\n        while (x1 != x2):\n            x1 += xs\n            if (p1 >= 0):\n                y1 += ys\n                p1 -= 2 * dx\n            if (p2 >= 0):\n                z1 += zs\n                p2 -= 2 * dx\n            p1 += 2 * dy\n            p2 += 2 * dz\n            append(z1, y1, x1)\n\n    # Driving axis is Y-axis\"\n    elif (dy >= dx and dy >= dz):\n        p1 = 2 * dx - dy\n        p2 = 2 * dz - dy\n        while (y1 != y2):\n            y1 += ys\n            if (p1 >= 0):\n                x1 += xs\n                p1 -= 2 * dy\n            if (p2 >= 0):\n                z1 += zs\n                p2 -= 2 * dy\n            p1 += 2 * dx\n            p2 += 2 * dz\n            append(z1, y1, x1)\n\n    # Driving axis is Z-axis\"\n    else:\n        p1 = 2 * dy - dz\n        p2 = 2 * dx - dz\n        while (z1 != z2):\n            z1 += zs\n            if (p1 >= 0):\n                y1 += ys\n                p1 -= 2 * dz\n            if (p2 >= 0):\n                x1 += xs\n                p2 -= 2 * dz\n            p1 += 2 * dy\n            p2 += 2 * dx\n            append(z1, y1, x1)\n    return ListOfPoints",
        "prompt": "Create a line from start to end in a 3D coordinate space using Bresenham's line algorithm.",
        "task_id": "10682",
        "test_list": [
            "assert draw_line_bressenham((0, 0, 0), (0, 5, 0)) == [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0], [0, 4, 0], [0, 5, 0]]",
            "assert draw_line_bressenham((0, 0, 0), (0, 0, 5)) == [[0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [0, 0, 4], [0, 0, 5]]",
            "assert draw_line_bressenham((0, 0, 0), (3, 3, 3)) == [[0, 0, 0], [0, 0, 0], [0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]]",
            "assert draw_line_bressenham((5, 5, 5), (0, 0, 0)) == [[5, 5, 5], [4, 4, 4], [3, 3, 3], [2, 2, 2], [1, 1, 1], [0, 0, 0]]",
            "assert draw_line_bressenham((0, 0, 0), (5, 0, 0)) == [[0, 0, 0], [1, 0, 0], [2, 0, 0], [3, 0, 0], [4, 0, 0], [5, 0, 0]]"
        ]
    },
    {
        "func_name": "BLDC_ideal_commutator",
        "code": "def BLDC_ideal_commutator(i, f):\n    # Gates signal\n    G1 = 1 if f[0] >= 1 else 0\n    G2 = 1 if f[0] <= -1 else 0\n    G3 = 1 if f[1] >= 1 else 0\n    G4 = 1 if f[1] <= -1 else 0\n    G5 = 1 if f[2] >= 1 else 0\n    G6 = 1 if f[2] <= -1 else 0\n\n    # Diodes work\n    Fd1 = 1 if i[0] < 0 and G2 == 0 else 0\n    Fd2 = 1 if i[0] > 0 and G1 == 0 else 0\n    Fd3 = 1 if i[1] < 0 and G4 == 0 else 0\n    Fd4 = 1 if i[1] > 0 and G3 == 0 else 0\n    Fd5 = 1 if i[2] < 0 and G6 == 0 else 0\n    Fd6 = 1 if i[2] > 0 and G5 == 0 else 0\n\n    # Gates final signal\n    Gz1 = G1 or Fd1\n    Gz2 = G2 or Fd2\n    Gz3 = G3 or Fd3\n    Gz4 = G4 or Fd4\n    Gz5 = G5 or Fd5\n    Gz6 = G6 or Fd6\n\n    return Gz1, Gz2, Gz3, Gz4, Gz5, Gz6",
        "prompt": "Calculates impulses for inverter gates.",
        "task_id": "10740",
        "test_list": [
            "assert BLDC_ideal_commutator([1, 1, 1], [-1, -1, -1]) == (0, 0, 0, 0, 0, 0)",
            "assert BLDC_ideal_commutator([0, 0, 0], [0, 0, 0]) == (0, 0, 0, 0, 0, 0)",
            "assert BLDC_ideal_commutator([1, -1, 1], [-1, 1, -1]) == (1, 1, 1, 1, 1, 1)",
            "assert BLDC_ideal_commutator([1, 1, 1], [1, 1, 1]) == (0, 0, 0, 0, 0, 0)",
            "assert BLDC_ideal_commutator([-1, 1, -1], [1, -1, 1]) == (1, 1, 1, 1, 1, 1)"
        ]
    },
    {
        "func_name": "check_short_utt",
        "code": "\nclass Conv1dSubsampling2:\n    pass\n\nclass Conv1dSubsampling3:\n    pass\n\nclass Conv2dSubsampling1:\n    pass\n\nclass Conv2dSubsampling2:\n    pass\n\nclass Conv2dSubsampling:\n    pass\n\nclass Conv2dSubsampling6:\n    pass\n\nclass Conv2dSubsampling8:\n    pass\n\ndef check_short_utt(ins, size):\n    if isinstance(ins, Conv1dSubsampling2) and size < 5:\n        return True, 5\n    if isinstance(ins, Conv1dSubsampling3) and size < 7:\n        return True, 7\n    if isinstance(ins, Conv2dSubsampling1) and size < 5:\n        return True, 5\n    if isinstance(ins, Conv2dSubsampling2) and size < 7:\n        return True, 7\n    if isinstance(ins, Conv2dSubsampling) and size < 7:\n        return True, 7\n    if isinstance(ins, Conv2dSubsampling6) and size < 11:\n        return True, 11\n    if isinstance(ins, Conv2dSubsampling8) and size < 15:\n        return True, 15\n    return False, -1\n",
        "prompt": "Check if the utterance is too short for subsampling.",
        "task_id": "10759",
        "test_list": [
            "assert check_short_utt(Conv2dSubsampling1, 5) == (True, 5)",
            "assert check_short_utt(Conv1dSubsampling3, 6) == (False, -1)",
            "assert check_short_utt(Conv2dSubsampling8, 14) == (True, 15)",
            "assert check_short_utt(Conv2dSubsampling, 6) == (False, -1)",
            "assert check_short_utt(Conv1dSubsampling2, 4) == (True, 5)"
        ]
    },
    {
        "func_name": "levenshtein_shortcircuit_dist",
        "code": "def levenshtein_shortcircuit_dist(s, t, max_dist=3):\r\n    #as seen from https://www.python-course.eu/levenshtein_distance.php\r\n    rows = len(s)+1\r\n    cols = len(t)+1\r\n    if abs(rows-cols)> max_dist:\r\n        return False, 10000\r\n\r\n    dist = [[0 for x in range(cols)] for x in range(rows)]\r\n    # source prefixes can be transformed into empty strings \r\n    # by deletions:\r\n    for i in range(1, rows):\r\n        dist[i][0] = i\r\n    # target prefixes can be created from an empty source string\r\n    # by inserting the characters\r\n    for i in range(1, cols):\r\n        dist[0][i] = i\r\n        \r\n    for col in range(1, cols):\r\n        max_num = 1000000\r\n        for row in range(1, rows):\r\n            if s[row-1] == t[col-1]:\r\n                cost = 0\r\n            else:\r\n                cost = 1\r\n            dist[row][col] = min(dist[row-1][col] + 1,      # deletion\r\n                                 dist[row][col-1] + 1,      # insertion\r\n                                 dist[row-1][col-1] + cost) # substitution\r\n            if dist[row][col] < max_num:\r\n                max_num = dist[row][col]\r\n        if max_num >= max_dist:\r\n            return False, 100000\r\n    #print dist[row][col]\r\n    if dist[row][col] < max_dist:\r\n        return True, dist[row][col]\r\n    return False, 100000\r\n    #return dist[row][col]\r",
        "prompt": "iterative_levenshtein(s, t) > ldist ldist is the Levenshtein distance between the strings s and t. For all i and j, dist[i,j] will contain the Levenshtein distance between the first i characters of s and the first j characters of t",
        "task_id": "10807",
        "test_list": [
            "assert levenshtein_shortcircuit_dist('computer', 'computers', 3) == (True, 3)",
            "assert levenshtein_shortcircuit_dist('algorithm', 'altruistic', 3) == (True, 5)",
            "assert levenshtein_shortcircuit_dist('kitten', 'sitting', 3) == (True, 3)",
            "assert levenshtein_shortcircuit_dist('intention', 'execution', 3) == (True, 5)",
            "assert levenshtein_shortcircuit_dist('flaw', 'lawn', 3) == (True, 2)"
        ]
    },
    {
        "func_name": "make_sql_select_command",
        "code": "def make_sql_select_command(table_name, table_header_list, where_columns=None, where_options=None,\n                            where_values=None, where_bools=None, group=None, having_columns=None, having_bools=None,\n                            having_values=None):\n\n    if where_columns is not None and where_options is not None and where_values is not None and where_bools is not None:\n        if (len(where_columns) != len(where_options) and len(where_options) != len(where_values) and len(\n                where_values) != (len(where_bools) - 1)):\n            raise Exception(\"Invalid argument\")\n    elif where_columns is not None or where_options is not None or where_values is not None or where_bools is not None:\n        raise Exception(\"Invalid argument\")\n\n    # must have a table name\n    if table_name is None or len(table_name) == 0:\n        raise Exception(\"a table name must be provided.\")\n\n    sql_select_command = \"SELECT \"\n    if table_header_list == \"*\":\n        sql_select_command += \" * \"\n    else:\n        for table_header_index in range(len(table_header_list)):\n            sql_select_command += table_header_list[table_header_index]\n            if table_header_index != len(table_header_list) - 1:\n                sql_select_command += \", \"\n            else:\n                sql_select_command += \" \"\n    sql_select_command += \"\\n\" + \"FROM \" + table_name + \" \"\n\n    if where_columns is not None:\n        sql_select_command += \"\\n\" + \"WHERE \"\n        for where_index in range(len(where_columns)):\n            sql_select_command += where_columns[where_index] + \" \" + where_options[where_index] + \" \" + str(\n                where_values[where_index]) + \" \"\n            if where_index < len(where_bools):\n                sql_select_command += where_bools[where_index] + \" \"\n\n    if group is not None:\n        sql_select_command += \"\\n\" + \"GROUP BY \" + group\n\n    if having_columns is not None and having_bools is not None and having_values is not None:\n        sql_select_command += \"\\n\" + \"HAVING \" + having_columns + \" \" + having_bools + \" \" + str(having_values)\n    sql_select_command += \";\"\n\n    return sql_select_command",
        "prompt": "Make SQL select command. table_header_list list of columns to be selected where_columns column names for where clause where_options operator for where clause where_values variable for where clause where_bools boolean for where clause group group name for GROUP BY clause having_columns",
        "task_id": "10826",
        "test_list": [
            "assert make_sql_select_command('users', ['id', 'name'], ['age'], ['>'], [30], [True], None, None, None, None) == 'SELECT id, name FROM users WHERE age > 30;'",
            "assert make_sql_select_command('inventory', ['product_id', 'product_name', 'quantity'], None, None, None, None, None, None, None, None) == 'SELECT product_id, product_name, quantity FROM inventory;'",
            "assert make_sql_select_command('employees', ['id', 'name', 'department'], ['department'], ['='], ['HR'], [True], None, None, None, None) == \"SELECT id, name, department FROM employees WHERE department = 'HR';\"",
            "assert make_sql_select_command('orders', ['id', 'customer_id', 'amount'], None, None, None, None, 'customer_id', None, None, None) == 'SELECT id, customer_id, amount FROM orders GROUP BY customer_id;'",
            "assert make_sql_select_command('products', ['id', 'name', 'price'], ['category'], ['IN'], ['Electronics', 'Books'], [True, True], 'category', [True, True], ['Electronics', 'Books']) == \"SELECT id, name, price FROM products WHERE category IN ('Electronics', 'Books') GROUP BY category HAVING category IN ('Electronics', 'Books');\""
        ]
    },
    {
        "func_name": "unionruns",
        "code": "def unionruns(*seqs):\n        allpairs = sorted(pair for seq in seqs for pair in seq)\n        if len(allpairs) == 0:\n            return\n        lastPairStart = allpairs[0][0]\n        lastPairLen = 0\n        for (s, l) in allpairs:\n            if l <= 0:\n                continue\n            if lastPairStart + lastPairLen >= s:\n                # extend existing run\n                if lastPairStart + lastPairLen < s + l:\n                    lastPairLen = s + l - lastPairStart\n            else:\n                if lastPairLen > 0:\n                    yield (lastPairStart, lastPairLen)\n                lastPairStart, lastPairLen = s, l\n        if lastPairLen > 0:\n            yield (lastPairStart, lastPairLen)",
        "prompt": "Compute the union of a sequence of iterables of intervals. The intervals are in (start, length) format. Good for combining the last frame's spritecovered dirty tiles (things to erase) with this frame's changed and spritecovered tiles (things to draw).",
        "task_id": "10881",
        "test_list": [
            "assert list(unionruns([(1, 1), (2, 1), (3, 1)])) == [(1, 1), (2, 1), (3, 1)]",
            "assert list(unionruns([(1, 0), (2, 1), (3, 0)])) == [(2, 1)]",
            "assert list(unionruns([(5, 2), (6, 1), (7, 3)])) == [(5, 3), (7, 3)]",
            "assert list(unionruns([(1, 2), (2, 1), (4, 3)])) == [(1, 3), (4, 3)]",
            "assert list(unionruns([(1, 2), (3, 2), (4, 2)])) == [(1, 4), (4, 2)]"
        ]
    },
    {
        "func_name": "horizontalMaxs",
        "code": "def horizontalMaxs(a):\r\n\tmax1, max2 = 0,0\r\n\tposMax1, posMax2 = 0,0\r\n\tfor i in range(1,len(a)-1):\r\n\t\tif a[i]>a[i+1] and a[i]>a[i-1]:\r\n\t\t\tif a[i]>max1:\r\n\t\t\t\tmax1 = a[i]\r\n\t\t\t\tposMax1 = i\r\n\tfor i in range(1,len(a)-1):\r\n\t\tif a[i]>a[i+1] and a[i]>a[i-1]:\t\t\r\n\t\t\tif a[i]>max2 and a[i]<max1:\r\n\t\t\t\tmax2 = a[i]\r\n\t\t\t\tposMax2 = i\r\n\t#print posMax1, posMax2\r\n\t#plt.plot(a)\r\n\t#plt.plot(posMax1, max1, marker='o')\r\n\t#plt.plot(posMax2, max2, marker='o')\r\n\t#plt.show()\r\n\treturn posMax1, max1, posMax2, max2",
        "prompt": "metodo che data in ingresso un array 'a' riporti in uscita le posizioni e i valori dei 2 elementi di 'a' che hanno valore massimo tra i massimi locali",
        "task_id": "10923",
        "test_list": [
            "assert horizontalMaxs([5, 5, 5, 5, 5, 5, 5, 5, 5, 5]) == (4, 5, 4, 5)",
            "assert horizontalMaxs([1, 3, 2, 5, 4, 6, 3, 7, 8, 5]) == (3, 5, 7, 8)",
            "assert horizontalMaxs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == (4, 10, 4, 10)",
            "assert horizontalMaxs([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == (0, 10, 0, 10)",
            "assert horizontalMaxs([1, 3, 2, 5, 4, 6, 3, 7, 8, 5, 9]) == (7, 8, 9, 9)"
        ]
    },
    {
        "func_name": "time_difference_good_format",
        "code": "def time_difference_good_format(t1: float, t2: float) -> str:\n    delta_t = int(t2 - t1)\n    if delta_t < 60:\n        if delta_t <= 1:\n            return '{} second'.format(delta_t)\n        else:\n            return '{} seconds'.format(delta_t)\n    elif delta_t < 3600:\n        minutes = int(delta_t / 60)\n        sec = delta_t % 60\n        if minutes <= 1:\n            if sec <= 1:\n                return '{} minute and {} second'.format(minutes, sec)\n            else:\n                return '{} minute and {} seconds'.format(minutes, sec)\n        else:\n            if sec <= 1:\n                return '{} minutes and {} second'.format(minutes, sec)\n            else:\n                return '{} minutes and {} seconds'.format(minutes, sec)\n    elif delta_t < 3600 * 24:\n        hours = int(delta_t / 3600)\n        if hours <= 1:\n            hours_s = ''\n        else:\n            hours_s = 's'\n        minutes = int((delta_t % 3600) / 60)\n        if minutes <= 1:\n            minutes_s = ''\n        else:\n            minutes_s = 's'\n        sec = delta_t % 60\n        if sec <= 1:\n            sec_s = ''\n        else:\n            sec_s = 's'\n        return '{} hour{}, {} minute{} and {} second{}'.format(hours, hours_s, minutes, minutes_s, sec, sec_s)\n    else:\n        days = int(delta_t / (3600 * 24))\n        if days <= 1:\n            days_s = ''\n        else:\n            days_s = 's'\n        hours = int((delta_t % (3600 * 24)) / 3600)\n        if hours <= 1:\n            hours_s = ''\n        else:\n            hours_s = 's'\n        minutes = int((delta_t % 3600) / 60)\n        if minutes <= 1:\n            minutes_s = ''\n        else:\n            minutes_s = 's'\n        return '{} day{}, {} hour{} and {} minute{}'.format(days, days_s, hours, hours_s, minutes, minutes_s)",
        "prompt": "From two seconds time, compute the difference and give a relevant string of that time delta",
        "task_id": "11126",
        "test_list": [
            "assert time_difference_good_format(0, 30) == '30 seconds'",
            "assert time_difference_good_format(0, 3600) == '1 hour and 0 seconds'",
            "assert time_difference_good_format(3600 * 24, 3600 * 25) == '1 day, 1 hour and 0 seconds'",
            "assert time_difference_good_format(3600 * 24 + 3600, 3600 * 24 + 3600 + 1) == '1 day, 1 hour and 1 second'",
            "assert time_difference_good_format(3600, 7200) == '1 hour and 0 seconds'"
        ]
    },
    {
        "func_name": "pre_processing",
        "code": "def pre_processing(name: str, short_description_text: str, short_description_mm_text: str,\n                       long_description_text: str,\n                       long_description_mn_text: str, marketing_text_mm_text: str) -> str:\n        text = \" \".join(name) + \"[SEP]\"\n        if type(short_description_text) == str and len(short_description_text) > 5 and short_description_text not in name:\n            text += short_description_text + \" [SEP] \"\n\n        if type(long_description_text) == str and len(long_description_text) > 5:\n            text += long_description_text + \" [SEP] \"\n        if type(long_description_mn_text) == str and len(long_description_mn_text) > 5:\n            text += long_description_mn_text + \" [SEP] \"\n\n        if type(marketing_text_mm_text) == str and len(marketing_text_mm_text) > 5 and marketing_text_mm_text not in name:\n            text += marketing_text_mm_text + \" [SEP] \"\n\n        return text",
        "prompt": "Prepare the input string to feed into the model",
        "task_id": "11128",
        "test_list": [
            "assert pre_processing('Product', 'Short', 'Short MM', 'Short', 'Short MN', 'Short MM') == 'Product [SEP] Short [SEP] Short MM [SEP] Short [SEP] Short MN [SEP] Short MM [SEP]'",
            "assert pre_processing('Product', 'Short desc', 'Short desc MM', '', 'Long desc MN', '') == 'Product [SEP] Short desc [SEP] Short desc MM [SEP] Long desc MN [SEP]'",
            "assert pre_processing('Product', 'Short desc', 'Short desc MM', 'Long desc', 'Long desc MN', 'Marketing MM') == 'Product [SEP] Short desc [SEP] Long desc [SEP] Long desc MN [SEP] Marketing MM [SEP]'",
            "assert pre_processing('Short desc', 'Short desc', 'Short desc MM', 'Long desc', 'Long desc MN', 'Marketing MM') == 'Short desc [SEP] Short desc [SEP] Long desc [SEP] Long desc MN [SEP] Marketing MM [SEP]'",
            "assert pre_processing('Short desc Short desc MM Long desc Long desc MN Marketing MM', 'Short desc', 'Short desc MM', 'Long desc', 'Long desc MN', 'Marketing MM') == 'Short desc Short desc MM Long desc Long desc MN Marketing MM [SEP] Short desc [SEP] Short desc MM [SEP] Long desc [SEP] Long desc MN [SEP] Marketing MM [SEP]'"
        ]
    },
    {
        "func_name": "letter_extremal_occurrences",
        "code": "def letter_extremal_occurrences(w, u):\n    if len(u) == 0:\n        return [()]\n\n    pos = [[] for _ in range(len(u))]\n\n    letters = set(w)\n    n = len(w)\n\n    # 1. find next left and next right occurrences of letters\n    next_left = [None]*n\n    next_right = [None]*n\n    last = {letter: -1 for letter in letters}\n    for i,letter in enumerate(w):\n        next_left[i] = last[letter]\n        last[letter] = i\n    last = {letter: n for letter in letters}\n    for i,letter in enumerate(reversed(w)):\n        next_right[n-i-1] = last[letter]\n        last[letter] = n-i-1\n\n    # 2. run through w\n    for i,letter in enumerate(w):\n        for j in range(len(u)-1,0,-1):\n            if letter == u[j]:\n                for x in pos[j-1]:\n                    if next_left[x[-1]] <= x[-2] or next_right[x[-1]] >= i:\n                        pos[j].append(x + (i,))\n            else:\n                k = 0\n                while k < len(pos[j-1]):\n                    x = pos[j-1][k]\n                    if next_left[x[-1]] > x[-2] and next_right[x[-1]] < i:\n                        del pos[j-1][k]\n                    else:\n                        k += 1\n        if letter == u[0]:\n            pos[0].append((-1,i))\n\n    return [x[1:] for x in pos[-1] if next_left[x[-1]] <= x[-2] or next_right[x[-1]] >= n]",
        "prompt": "r\"\"\" Return the set of letterextremal occurrences of ``u`` in ``w``. An occurrence is letterextremal if the letters can not move inside the occurrence. This is a subset of all occurrences of ``u`` in ``w`` but much that defines the same convex hull.",
        "task_id": "11184",
        "test_list": [
            "assert letter_extremal_occurrences('aabbcc', 'b') == [(1, 2), (3, 4)]",
            "assert letter_extremal_occurrences('aabbcc', 'abc') == [(0, 1, 2), (3, 4, 5)]",
            "assert letter_extremal_occurrences('ababc', 'ab') == [(0, 1), (2, 3)]",
            "assert letter_extremal_occurrences('aabbcc', 'a') == [(0, 1), (2, 3)]",
            "assert letter_extremal_occurrences('aabbcc', 'c') == [(4, 5)]"
        ]
    },
    {
        "func_name": "get_round_type",
        "code": "def get_round_type(ct_equip, t_equip, round_num):\n        round_types = {\"CT\": \"None\", \"T\": \"None\"}\n        # Pistol Round\n        if (round_num == 1) or (round_num == 16):\n            round_types[\"CT\"] = \"Pistol\"\n            round_types[\"T\"] = \"Pistol\"\n            return round_types\n        # Full Eco\n        if ct_equip < 2000:\n            round_types[\"CT\"] = \"Full Eco\"\n        if t_equip < 2000:\n            round_types[\"CT\"] = \"Full Eco\"\n        # Eco\n        if (ct_equip >= 2000) and (ct_equip < 8500):\n            round_types[\"CT\"] = \"Eco\"\n        if (t_equip >= 2000) and (t_equip < 8500):\n            round_types[\"T\"] = \"Eco\"\n        # Anti-Eco\n        if (\n            (round_types[\"T\"] == \"Eco\" or round_types[\"T\"] == \"Full Eco\")\n            and (ct_equip < 18500)\n            and (ct_equip >= 8500)\n        ):\n            round_types[\"CT\"] = \"Anti-Eco\"\n        if (\n            (round_types[\"CT\"] == \"Eco\" or round_types[\"CT\"] == \"Full Eco\")\n            and (t_equip < 18500)\n            and (t_equip >= 8500)\n        ):\n            round_types[\"T\"] = \"Anti-Eco\"\n        # Half Buy\n        if (ct_equip >= 8500) and (ct_equip < 22000):\n            round_types[\"CT\"] = \"Half Buy\"\n        if (t_equip >= 8500) and (t_equip < 20000):\n            round_types[\"T\"] = \"Half Buy\"\n        # Full Buy\n        if ct_equip >= 22000:\n            round_types[\"CT\"] = \"Full Buy\"\n        if t_equip > 20000:\n            round_types[\"T\"] = \"Full Buy\"\n        return round_types",
        "prompt": "Return team round types for a given dollar amount",
        "task_id": "11272",
        "test_list": [
            "assert get_round_type(1500, 2500, 1) == {'CT': 'Pistol', 'T': 'Pistol'}",
            "assert get_round_type(18500, 18500, 1) == {'CT': 'Anti-Eco', 'T': 'Anti-Eco'}",
            "assert get_round_type(22000, 25000, 1) == {'CT': 'Full Buy', 'T': 'Full Buy'}",
            "assert get_round_type(9000, 9000, 1) == {'CT': 'Pistol', 'T': 'Pistol'}",
            "assert get_round_type(2000, 2000, 1) == {'CT': 'Eco', 'T': 'Eco'}"
        ]
    },
    {
        "func_name": "extract_cluster_amount",
        "code": "def extract_cluster_amount(ordering, radius):\n    amount_clusters = 1\n\n    cluster_start = False\n    cluster_pick = False\n    total_similarity = True\n    previous_cluster_distance = None\n    previous_distance = None\n\n    for dist in ordering:\n        if (dist >= radius):\n            if not cluster_start:\n                cluster_start = True\n                amount_clusters += 1\n\n            else:\n                if dist < previous_cluster_distance and not cluster_pick:\n                    cluster_pick = True\n\n                elif dist > previous_cluster_distance and cluster_pick:\n                    cluster_pick = False\n                    amount_clusters += 1\n\n            previous_cluster_distance = dist\n\n        else:\n            cluster_start = False\n            cluster_pick = False\n\n        if previous_distance is not None and dist != previous_distance:\n            total_similarity = False\n\n        previous_distance = dist\n\n    if total_similarity and previous_distance > radius:\n        amount_clusters = 0\n\n    return amount_clusters",
        "prompt": "Amount of clustering that can be allocated using specifiedradius for ordering diagram. When growth of reachabilitydistances is detected than it is considered as a start point of cluster, than pick is detected and after that recession is observed until new growth (that means end of the current cluster and start of a new one) or end of diagram.",
        "task_id": "11314",
        "test_list": [
            "assert extract_cluster_amount([1, 2, 3, 4, 5, 6, 7, 8, 9], 1) == 1",
            "assert extract_cluster_amount([1, 2, 3, 4, 5, 6, 7, 8, 9], 0) == 1",
            "assert extract_cluster_amount([1, 2, 3, 10, 11, 12, 20, 21, 22], 5) == 2",
            "assert extract_cluster_amount([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == 3",
            "assert extract_cluster_amount([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) == 1"
        ]
    },
    {
        "func_name": "extend_alignment",
        "code": "def extend_alignment(rseq, pos5p, pos3p, is_read1, strand, genome):\n    rcnt = {'A':'T', 'C':'G', 'G':'C', 'T':'A'}\n    glen = len(genome)\n    if is_read1:\n        # Start from the last position and move on to the 5' end\n        if strand == '-':\n            ipos = 0\n            try:\n                while rcnt[genome[(pos3p+ipos)%glen]] == rseq[-(ipos+1)]:\n                    ipos += 1\n            except IndexError:\n                return ipos - 1\n            return ipos\n        else:\n            ipos = 0\n            try:\n                while genome[(pos3p-ipos)%glen] == rseq[-(ipos+1)]:\n                    ipos += 1\n            except IndexError:\n                return ipos-1\n            return ipos\n    else:\n        if strand == '-':\n            ipos = 0\n            try:\n                while rcnt[genome[(pos5p-ipos)%glen]] == rseq[ipos]:\n                    ipos += 1\n            except IndexError:\n                return ipos -1\n            return ipos \n        else:\n            ipos = 0\n            try:\n                while genome[(pos5p+ipos)%glen] == rseq[ipos]:\n                    ipos += 1\n            except IndexError:\n                return ipos - 1\n            return ipos",
        "prompt": "Align the rseq to the genome in the specified position. Return the last position of the read mapped to the genome. Use local alignment",
        "task_id": "11385",
        "test_list": [
            "assert extend_alignment('GATTACA', 0, 0, True, '+', 'GATTACAGATTACA') == 7",
            "assert extend_alignment('TACG', 0, 0, True, '-', 'GCTAGCTAGCTAGCTAGCTACG') == 7",
            "assert extend_alignment('ACGT', 0, 0, True, '+', 'ACGTACGTACGT') == 7",
            "assert extend_alignment('CGTA', 0, 0, False, '+', 'CGTACGTAGCTAGCTAGC') == 4",
            "assert extend_alignment('TGCA', 0, 0, False, '-', 'ACGTACGTACGT') == 4"
        ]
    },
    {
        "func_name": "Compress",
        "code": "def Compress(history):\n    i = 0\n    while i < len(history)-1:\n        change = True\n        while change and i < len(history)-1:\t\t\t# allows us to assume the current element is at least 1 from the end\n            equiv1 = history[i] == history[i+1]\t\t\t# stores bool for if element i equals the next element in equiv1\n            if len(history)-i >= 3:\t\t\t\t\t\t# if current element is more than 1 element from the end\n                equiv2 = history[i] == history[i+2]\t\t# stores bool for if element i equals the next-next element in equiv2\n            else:\t\t\t\t\t\t\t\t\t\t# if current element is fewer than 2 elements from the end...\n                equiv2 = False\t\t\t\t\t\t\t# there is no equivalence for the next-next element\n            if len(history)-i >= 4:\t\t\t\t\t\t# if the current element is more than 2 elements from the end\n                equiv3 = history[i] == history[i+3]\t\t# stores bool for if current element equals next-next-next element in equiv3\n            else:\t\t\t\t\t\t\t\t\t\t# if the current element is fewer than 3...\n                equiv3 = False\t\t\t\t\t\t\t# there is no equivalence for the next-next-next element\n            if equiv1 and equiv2 and equiv3:\t\t\t# if the current element is the same as the next 3\n                del history[i]\t\t\t\t\t\t\t# constitutes 360 deg so all four are removed\n                del history[i]\n                del history[i]\n                del history[i]\n\n            elif history[i][0] == history[i+1][0] and not equiv1:\t# else if the first letter of the current element equals \" \" \" \" second\n                del history[i]\t\t\t\t\t\t\t\t\t\t# \tand the elements themselves are not equal\n                del history[i]\t\t\t\t\t\t\t\t\t\t# constitutes a move and an opposite move. both are removed\n\n            elif equiv1 and equiv2:\t\t\t\t\t\t\t# otherwise, if the current element equals the next two\n                if len(history[i]) == 2:\t\t\t\t\t# constitutes 270 deg.\n                    history[i] = history[i][0] + 'CC'\t\t# change the current element to be opposite\n                elif len(history[i]) == 3:\n                    history[i] = history[i][0] + 'C'\n                del history[i+1]\t\t\t\t\t\t\t# delete the next two elements\n                del history[i+1]\n\n            else:\t\t\t\t\t\t\t\t\t# if there are no available compressions in range\n                change = False\t\t\t\t\t\t# set change to false to move the current element by one\n        i += 1\n\n    i = 0\n    while i < len(history)-1:\t\t\t\t\t\t\t# second pass for 180 movements\n        if history[i] == history[i+1]:\t\t\t\t# combining like movements makes the motor movement more precise\n            history[i] = history[i][0]+'180'\n            del history[i+1]\n        i += 1\n\n    return history\t\t\t\t\t# return the compressed history",
        "prompt": "Compresses redundant moves to be more efficient",
        "task_id": "11443",
        "test_list": [
            "assert Compress(['A', 'A', 'A', 'A', 'B', 'B', 'C', 'C', 'C', 'C']) == ['A180', 'B', 'C180']",
            "assert Compress(['X', 'X', 'Y', 'Y', 'Z', 'Z', 'X', 'X', 'Y', 'Y', 'Z', 'Z']) == ['X180', 'Y180', 'Z180']",
            "assert Compress(['R', 'R', 'R', 'L', 'L', 'L', 'R', 'R', 'L', 'L', 'R', 'R']) == ['R180', 'L180']",
            "assert Compress(['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G']) == ['G360']",
            "assert Compress(['A', 'B', 'A', 'B', 'C', 'D', 'C', 'D', 'E', 'F', 'E', 'F']) == ['A', 'B', 'C', 'D', 'E', 'F']"
        ]
    },
    {
        "func_name": "actual_exon_numbers",
        "code": "def actual_exon_numbers(exons):\n    exon_list = list()\n    if len(exons) < 4 or len(exons) > 12:\n        return [0, 0, 0, 0]\n    if len(exons) == 4:\n        exon_list = list(exons)\n    if len(exons) == 5:\n        exon_list = map(str, [7, 9, 8, 10])\n    if len(exons) == 6:\n        exon_list = map(str, [8, 10, 9, 11])\n    if len(exons) == 7:\n        exon_list = map(str, [9, 11, 10, 12])\n    if len(exons) == 8:\n        exon_list = [exons[0:2], exons[2:4], exons[4:6], exons[6:8]]\n    if len(exons) == 9:\n        exon_list = map(str, [97, 99, 98, 100])\n    if len(exons) == 10:\n        exon_list = map(str, [98, 100, 99, 101])\n    if len(exons) == 11:\n        exon_list = map(str, [99, 101, 100, 102])\n    if len(exons) == 12:\n        exon_list = [exons[0:3], exons[3:6], exons[6:9], exons[9:12]]\n    return exon_list",
        "prompt": "Takes a string from transcript name Returns list of actual exon numbers in transcript",
        "task_id": "11463",
        "test_list": [
            "assert actual_exon_numbers('transcript_name') == [8, 10, 9, 11]",
            "assert actual_exon_numbers('transcript_name') == [0, 0, 0, 0]",
            "assert actual_exon_numbers('transcript_name') == [97, 99, 98, 100]",
            "assert actual_exon_numbers('transcript_name') == [98, 100, 99, 101]",
            "assert actual_exon_numbers('transcript_name') == [99, 101, 100, 102]"
        ]
    },
    {
        "func_name": "rsplit_longest_suffix",
        "code": "def rsplit_longest_suffix(uname, suffixes):\n    minindex = len(uname)\n    for suffix in suffixes:\n        # FIXME: prevent suffix from starting with '_'?\n        index = len(uname) - len(suffix)\n        if index == 0 and uname == suffix:\n            return None, suffix\n        elif index > 0 and index < minindex and uname[index:] == suffix \\\n             and uname[index-1] == '_':\n            minindex = index\n    if minindex < len(uname):\n        if minindex <= 1:\n            return None, uname[minindex:]\n        else:\n            return uname[:minindex-1], uname[minindex:]\n    else:\n        return uname, None",
        "prompt": "Splitout longest matching suffix from uniform name string.",
        "task_id": "11467",
        "test_list": [
            "assert rsplit_longest_suffix('example_string', ['ing', 'str', 'test_', 'test', 'ex', 'ample']) == ('exam', 'ple_string')",
            "assert rsplit_longest_suffix('test_string', ['ing', 'str', 'test']) == ('test', 'string')",
            "assert rsplit_longest_suffix('example_string', ['ing', 'str', 'test_', 'test', 'ex']) == ('exam', 'ple_string')",
            "assert rsplit_longest_suffix('example_string', ['ing', 'str', 'test']) == ('example', 'string')",
            "assert rsplit_longest_suffix('example_string', ['ing', 'str', 'test_', 'test']) == ('example', 'string')"
        ]
    },
    {
        "func_name": "compute_right",
        "code": "\nfrom typing import List, Optional\n\ndef compute_right(k: int, word: List[int]) -> List[Optional[int]]:\n    w = word\n    curr_cont: List[int] = [0 for _ in range(max(w) + 1)]\n    curr_k: int = 0\n    right_k: List[Optional[int]] = [None for _ in range(len(w))]\n    j: int = -1\n    for i in range(len(w)):\n        if i > 0:\n            curr_cont[w[i - 1]] -= 1\n            if curr_cont[w[i - 1]] == 0:\n                curr_k -= 1\n        while j < len(w) - 1 and (curr_cont[w[j + 1]] != 0 or curr_k < k):\n            j += 1\n            if curr_cont[w[j]] == 0:\n                curr_k += 1\n            curr_cont[w[j]] += 1\n        if curr_k == k:\n            right_k[i] = j\n    return right_k\n",
        "prompt": "Precompute the prefix maximal content`k` subwords of `word`.",
        "task_id": "11573",
        "test_list": [
            "assert compute_right(3, [3, 1, 2, 3, 1, 2, 3]) == [None, None, None, 6, 5, 4, None]",
            "assert compute_right(4, [4, 3, 2, 1, 4, 3, 2, 1]) == [None, None, None, None, 7, 6, 5, 4]",
            "assert compute_right(0, [1, 2, 3, 4, 5]) == [None, None, None, None, None]",
            "assert compute_right(2, [1, 2, 1, 2, 1]) == [None, None, 4, 3, None]",
            "assert compute_right(1, [1, 1, 1, 1, 1]) == [None, 0, 1, 2, 3]"
        ]
    },
    {
        "func_name": "get_nearest_week_time",
        "code": "def get_nearest_week_time(wday, hour, min=0, sec=0):\r\n    # \u6309\u661f\u671f\u4e3a\u5468\u671f\r\n    now_time = time.localtime()\r\n    wday -= 1\r\n    dif_day = wday - now_time.tm_wday\r\n    if dif_day < 0:\r\n        dif_day += 7\r\n\r\n    dif_hour = hour - now_time.tm_hour\r\n    if dif_hour < 0:\r\n        if not dif_day:\r\n            dif_day += 7\r\n    dif_min = min - now_time.tm_min\r\n    if dif_min < 0:\r\n        if not dif_day and not dif_hour:\r\n            dif_day += 7\r\n    dif_sec = sec - now_time.tm_sec\r\n    if dif_sec < 0:\r\n        if not dif_day and not dif_hour and not dif_min:\r\n            dif_day += 7\r\n    day_sec = dif_day * 24 * 60 * 60 + dif_hour * 60 * 60 + dif_min * 60 + dif_sec\r\n    t_s = time.mktime(now_time) + day_sec\r\n    return int(t_s)",
        "prompt": "hour 023 min 059 sec 059 wday 17",
        "task_id": "11639",
        "test_list": [
            "assert get_nearest_week_time(4, 23, 59, 59) == 1672573599",
            "assert get_nearest_week_time(5, 23, 59, 59) == 1672537199",
            "assert get_nearest_week_time(6, 23, 59, 59) == 1672613599",
            "assert get_nearest_week_time(1, 0, 0, 0) == 1672597600",
            "assert get_nearest_week_time(0, 0, 0, 0) == 1672537600"
        ]
    },
    {
        "func_name": "dinamic",
        "code": "def dinamic(a, b):\n\n    dp = [[0 for i in range(len(b))] for j in range(len(a))]\n\n    for i in range(0, len(a)):\n        for j in range(0, len(b)):\n            if i == 0:\n                if a[i] == b[j] and dp[i][j] == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = 0\n            elif j == 0:\n                if a[i] == b[j] and dp[i][j] == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = 0\n            elif a[i] == b[j]:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    return dp",
        "prompt": "calculeaza cel mai lung subsir comun a doua siruri",
        "task_id": "11677",
        "test_list": [
            "assert dinamic('abc', 'def') == [[0, 0, 0], [0, 0, 0], [0, 0, 0]]",
            "assert dinamic('abc', 'abcde') == [[0, 0, 0, 0, 0], [0, 0, 1, 1, 1], [0, 0, 1, 2, 2], [0, 0, 1, 2, 3], [0, 0, 1, 2, 3]]",
            "assert dinamic('abc', 'ac') == [[0, 0, 0], [0, 1, 1], [0, 1, 2]]",
            "assert dinamic('abc', 'abc') == [[1, 1, 1], [1, 1, 1], [1, 1, 1]]",
            "assert dinamic('abcde', 'ace') == [[0, 0, 0, 0, 0], [0, 0, 1, 1, 1], [0, 0, 1, 2, 2], [0, 0, 1, 2, 3], [0, 0, 1, 2, 3]]"
        ]
    },
    {
        "func_name": "char_span_to_token_span",
        "code": "\nfrom typing import List, Optional, Tuple\n\ndef char_span_to_token_span(\n    token_offsets: List[Optional[Tuple[int, int]]], character_span: Tuple[int, int]\n) -> Tuple[Tuple[int, int], bool]:\n    error = False\n    start_index = 0\n    while start_index < len(token_offsets) and (\n        token_offsets[start_index] is None\n        or token_offsets[start_index][0] < character_span[0]\n    ):\n        start_index += 1\n\n    # If we overshot and the token prior to start_index ends after the first character, back up.\n    if (\n        start_index > 0\n        and token_offsets[start_index - 1] is not None\n        and token_offsets[start_index - 1][1] > character_span[0]\n    ) or (\n        start_index <= len(token_offsets)\n        and token_offsets[start_index] is not None\n        and token_offsets[start_index][0] > character_span[0]\n    ):\n        start_index -= 1\n\n    if start_index >= len(token_offsets):\n        raise ValueError(\"Could not find the start token given the offsets.\")\n\n    if (\n        token_offsets[start_index] is None\n        or token_offsets[start_index][0] != character_span[0]\n    ):\n        error = True\n\n    end_index = start_index\n    while end_index < len(token_offsets) and (\n        token_offsets[end_index] is None\n        or token_offsets[end_index][1] < character_span[1]\n    ):\n        end_index += 1\n    if end_index == len(token_offsets):\n        # We want a character span that goes beyond the last token. Let's see if this is salvageable.\n        # We consider this salvageable if the span we're looking for starts before the last token ends.\n        # In other words, we don't salvage if the whole span comes after the tokens end.\n        if token_offsets[-1] is not None:\n            if character_span[0] < token_offsets[-1][1]:\n                # We also want to make sure we aren't way off. We need to be within 8 characters to salvage.\n                if character_span[1] - 8 < token_offsets[-1][1]:\n                    end_index -= 1\n\n    return (start_index, end_index), error\n",
        "prompt": "Converts a character span from a passage into the corresponding token span in the tokenized version of the passage. If you pass in a character span that does not correspond to complete tokens in the tokenized version, we'll do our best, but the behavior is officially undefined. We return an error flag in this case, and have some debug logging so you can figure out the cause of this issue (in SQuAD, these are mostly either tokenization problems or annotation problems; there's a fair amount of both). The basic outline of this method is to find the token span that has the same offsets as the input character span. If the tokenizer tokenized the passage correctly and has matching offsets, this is easy. We try to be a little smart about cases where they don't match exactly, but mostly just find the closest thing we can. The returned ``(begin, end)`` indices are `inclusive` for both ``begin`` and ``end``. So, for example, ``(2, 2)`` is the one word span beginning at token index 2, ``(3, 4)`` is the twoword span beginning at token index 3, and so on. Returns",
        "task_id": "11696",
        "test_list": [
            "assert char_span_to_token_span([(0, 4), (5, 9), (10, 14)], (8, 12)) == ((1, 1), False)",
            "assert char_span_to_token_span([(0, 4), (5, 9), (10, 14)], (5, 5)) == ((1, 1), False)",
            "assert char_span_to_token_span([(0, 4), (5, 9), (10, 14)], (11, 13)) == ((2, 2), False)",
            "assert char_span_to_token_span([(0, 4), (5, 9), (10, 14)], (0, 0)) == ((0, 0), False)",
            "assert char_span_to_token_span([(0, 4), (5, 9), (10, 14)], (3, 7)) == ((1, 1), False)"
        ]
    },
    {
        "func_name": "areas_not_covered",
        "code": "def areas_not_covered(list_contigs, len_genome):\n\t# plot areas not covered\n\tstart_first_contig = min([contig[0] for contig in list_contigs])\n\t#end_last_contig = max([contig[1] for contig in list_contigs])\n\tgenome_not_covered = [[start_first_contig, start_first_contig + len_genome]]\n\tfor contig in list_contigs:\n\t\tstart = contig[0]\n\t\tend = contig[1]\n\n\t\tprev_genome_part = [0,0]\n\t\ti = 0\n\t\tinside_contig = False\n\t\twhile(i < len(genome_not_covered)):\n\t\t\tgenome_part = genome_not_covered[i]\n\n\t\t\tif inside_contig:\n\t\t\t\tif (end < genome_part[0]):\n\t\t\t\t\t# end before next uncovered region\n\t\t\t\t\tgenome_not_covered = new_genome_not_covered + genome_not_covered[i:len(genome_not_covered)]\n\t\t\t\t\tinside_contig = False\n\t\t\t\t\t#print(\"should break here 3\")\n\t\t\t\t\tbreak\n\t\t\t\telif (end >= genome_part[0]) & (end <= genome_part[1]):\n\t\t\t\t\tgenome_not_covered = new_genome_not_covered + [[end+1, genome_part[1]]] + genome_not_covered[min(i+1, len(genome_not_covered)):len(genome_not_covered)]\n\t\t\t\t\tinside_contig = False\n\t\t\t\t\t#print(\"should break here 2\")\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\t# whole contig in already covered area -> do nothing\n\t\t\t\tif (start > prev_genome_part[1]) & (end < genome_part[0]):\n\t\t\t\t\t#print(\"should break here 4\")\n\t\t\t\t\tbreak\n\t\t\t\t# start in covered area\n\t\t\t\tif (start > prev_genome_part[1]) & (start < genome_part[0]):\n\t\t\t\t\tinside_contig = True\n\t\t\t\t\tnew_genome_not_covered = genome_not_covered[0:i]\n\t\t\t\t\t# is the end inside this part ?\n\t\t\t\t\tif (end >= genome_part[0]) & (end <= genome_part[1]):\n\t\t\t\t\t\tgenome_not_covered = new_genome_not_covered + [[end+1, genome_part[1]]] + genome_not_covered[min(i+1, len(genome_not_covered)):len(genome_not_covered)]\n\t\t\t\t\t\tinside_contig = False\n\t\t\t\t\t\tbreak\n\t\t\t\t# start inside a non covered area\n\t\t\t\tif (start >= genome_part[0]) & (start <= genome_part[1]):\n\t\t\t\t\tinside_contig = True\n\t\t\t\t\t# remove this part of genome, replace by not covered part\n\t\t\t\t\tnew_genome_not_covered = genome_not_covered[0:i] + [[genome_part[0], max(start-1, genome_part[0])]]\n\t\t\t\t\t#print(\"start found\")\n\t\t\t\t\t# is the end inside this part ?\n\t\t\t\t\tif (end <= genome_part[1]):\n\t\t\t\t\t\tgenome_not_covered = new_genome_not_covered + [[end+1, genome_part[1]]] + genome_not_covered[min(i+1, len(genome_not_covered)):len(genome_not_covered)]\n\t\t\t\t\t\t#print(\"should break here 1\")\n\t\t\t\t\t\tinside_contig = False\n\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\tprev_genome_part = genome_not_covered[i]\n\t\t\t#print(i, genome_not_covered[i])\n\t\t\ti +=1\n\n\t\t# if still inside contig, need to finish outside loop\n\t\tif inside_contig:\n\t\t\t# print(\"here\")\n\t\t\t# print(contig)\n\t\t\t# print(new_genome_not_covered)\n\t\t\t# print(genome_not_covered)\n\t\t\tgenome_not_covered = new_genome_not_covered\n\n\t# clean result\n\tgenome_not_covered = [area for area in genome_not_covered if area[0] < area[1]]\n\n\treturn genome_not_covered",
        "prompt": "return list of areas not covered by contigs",
        "task_id": "11800",
        "test_list": [
            "assert areas_not_covered([[0, 5], [5, 10], [10, 15], [15, 20], [20, 25]], 10) == [[0, 10], [10, 20], [20, 25]]",
            "assert areas_not_covered([[0, 5], [10, 15], [20, 25]], 30) == [[0, 5], [10, 15], [20, 25]]",
            "assert areas_not_covered([[0, 5], [5, 10], [15, 20], [20, 25]], 30) == [[0, 5], [15, 20]]",
            "assert areas_not_covered([[0, 5], [5, 10], [10, 15], [15, 20], [20, 25]], 50) == [[0, 5], [5, 10], [10, 15], [15, 20], [20, 25]]",
            "assert areas_not_covered([[0, 5], [5, 10], [10, 15], [15, 20], [20, 25]], 30) == [[0, 5], [5, 10], [10, 15], [20, 25]]"
        ]
    },
    {
        "func_name": "number_of_trees_bin_nt_partial",
        "code": "def number_of_trees_bin_nt_partial(n, l, N, e):\n    # print(\"n=%d, l=%d, N=%d, e=%d\" % (n,l,N,e))\n    if (l <= 0) or (l > n) or (n < 0) or (N < n) or (l + e > N) or (l + e > n) or (e < 0):\n        # h \"n=%d, l=%d, N=%d, e=%d, --> %d\" % (n,l,N,e,0)\n        return 0\n    if n == 1:\n        # print(\"n=%d, l=%d, N=%d, e=%d, --> %d\" % (n,l,N,e,1))\n        if (l == 1) and (N == 1) and (e == 0):\n            return 1\n        else:\n            return 0\n    count = (\n        (N - 2) * number_of_trees_bin_nt_partial(n - 1, l - 1, N - 2, e) +  # P&H\n        (N - 1) * number_of_trees_bin_nt_partial(n - 1, l, N - 1, e - 1) +  # P&L\n        (N - n + 1) * number_of_trees_bin_nt_partial(n - 1, l, N, e) +  # H&L\n        l * number_of_trees_bin_nt_partial(n - 1, l, N - 1, e - 1) +  # H&H leaf\n        (e + 1) * number_of_trees_bin_nt_partial(n - 1, l - 1, N - 1, e + 1)  # H&H elem\n    )\n    # print(\"n=%d, l=%d, N=%d, e=%d, --> %d\" % (n,l,N,e,count))\n    return count",
        "prompt": "Gives the number of phylogenetic trees on n taxa with l leaves, N nodes, e of them being elementary. Assume binary trees with nested taxa.",
        "task_id": "11858",
        "test_list": [
            "assert number_of_trees_bin_nt_partial(4, 2, 4, 0) == 1",
            "assert number_of_trees_bin_nt_partial(0, 0, 0, 0) == 1",
            "assert number_of_trees_bin_nt_partial(3, 0, 3, 0) == 1",
            "assert number_of_trees_bin_nt_partial(2, 1, 2, 0) == 1",
            "assert number_of_trees_bin_nt_partial(5, 3, 5, 1) == 10"
        ]
    },
    {
        "func_name": "process_spaces",
        "code": "def process_spaces(intext, format):\n    NORMAL=1\n    SPACE=2\n    NBSP=3\n    XML=4\n    SPACEHOLD=5\n    \n    sigcount = 0\n    state = NORMAL\n    outtext = \"\"\n    if format == 1:\n    # Pre-formatted\n        for char in intext:\n            if state == NORMAL:\n                if char == \" \":\n                    if sigcount == 0:\n                        state = NBSP\n                        outtext += \"&nbsp;\"\n                    else:\n                        state = SPACEHOLD\n                elif char == \"<\":\n                    state = XML\n                    outtext += char\n                else:\n                    sigcount += 1\n                    outtext += char\n            elif state == SPACE:\n                if char == \" \":\n                    state = NBSP\n                    outtext += \"&nbsp;\"\n                elif char == \"<\":\n                    state = XML\n                    outtext += char\n                else:\n                    sigcount += 1\n                    state = NORMAL\n                    outtext += char\n            elif state == NBSP:\n                if char == \" \":\n                    state = SPACE\n                elif char == \"<\":\n                    state = XML\n                else:\n                    sigcount += 1\n                    state = NORMAL\n                outtext += char\n            elif state == XML:\n                if char == \">\":\n                    state = NORMAL\n                outtext += char\n            elif state == SPACEHOLD:\n                if char == \" \":\n                    outtext += \" &nbsp;\"\n                    state = NORMAL\n                elif char == \"<\":\n                    outtext += \" \"+char\n                    state = XML\n                else:\n                    outtext += \" \"+char\n                    sigcount += 1\n                    state = NORMAL\n    \n    else:\n    # format == 0 flowed\n        for char in intext:\n            if char == '<' and state == NORMAL:\n                state = XML\n                outtext += char\n            elif char == '>' and state == XML:\n                state = NORMAL\n                outtext += char\n            elif state == XML:\n                outtext += char\n            else:\n                sigcount += 1\n                outtext += char\n\n    return [outtext, sigcount]",
        "prompt": "Function to process spaces in text lines for preformatted notes.",
        "task_id": "11975",
        "test_list": [
            "assert process_spaces('No spaces, no special chars', 1) == ['No spaces, no special chars', 0]",
            "assert process_spaces('Hello World', 1) == ['Hello &nbsp;World', 1]",
            "assert process_spaces('<No spaces, no special chars>', 1) == ['<No spaces, no special chars>', 0]",
            "assert process_spaces('Hello, <World>!', 1) == ['Hello, &lt;World&gt;!', 1]",
            "assert process_spaces('  Leading spaces', 1) == ['&nbsp;&nbsp;Leading spaces', 2]"
        ]
    },
    {
        "func_name": "seg_label_to_cmd_and_ref",
        "code": "def seg_label_to_cmd_and_ref(segment_label):\n    segment_label_cmd = \"\"\n    segment_reference = \"\"\n\n    for c in segment_label:\n        if c != \"_\":\n            segment_reference += c\n        else:\n            segment_reference += \" \"\n\n        if c == '1':\n            segment_label_cmd += 'One'\n        elif c == '2':\n            segment_label_cmd += 'Two'\n        elif c == '3':\n            segment_label_cmd += 'Three'\n        elif c == '4':\n            segment_label_cmd += 'Four'\n        elif c == '5':\n            segment_label_cmd += 'Five'\n        elif c == '6':\n            segment_label_cmd += 'Six'\n        elif c == '7':\n            segment_label_cmd += 'Seven'\n        elif c == '8':\n            segment_label_cmd += 'Eight'\n        elif c == '9':\n            segment_label_cmd += 'Nine'\n        elif c == '0':\n            segment_label_cmd += 'Zero'\n        elif c == '_':\n            pass\n        else:\n            segment_label_cmd += c\n\n    return segment_label_cmd, segment_reference",
        "prompt": "Convert digit representation of a number into word representation.",
        "task_id": "12235",
        "test_list": [
            "assert seg_label_to_cmd_and_ref('0_123_456') == ('Zero OneTwoThree FourFiveSix', '0123456')",
            "assert seg_label_to_cmd_and_ref('_1_2_3_4_5_6_7_8_9_0') == ('_ One Two Three Four Five Six Seven Eight Nine Zero', '_1234567890')",
            "assert seg_label_to_cmd_and_ref('987_654') == ('NineEightSeven FourFiveSix SevenEightNine', '987 654')",
            "assert seg_label_to_cmd_and_ref('123_456') == ('OneTwoThree FourFiveSix', '123 456')",
            "assert seg_label_to_cmd_and_ref('1_2_3_4_5_6_7_8_9_0') == ('One Two Three Four Five Six Seven Eight Nine Zero', '1234567890')"
        ]
    },
    {
        "func_name": "parse_received",
        "code": "def parse_received(cmd, src):\n    args = None\n    msg = None\n    #Get the len\n    i = 1\n    if src[0] != \"<\":\n        return \"CONVERT ERROR\"\n    while(i < len(src) and src[i] != \">\"):\n        i += 1\n    msg_len = int(src[1:i])\n    if msg_len > len(src[i:]):\n        return \"LEN ERROR\"\n    #Get command and args\n    if cmd:\n        #Get command\n        j = i + 1\n        while (j < len(src) and src[j] != \"(\"):\n            j += 1\n        cmd = src[i + 1:j]\n        #Get args\n        k = j + 1\n        while (k < len(src) and src[k] != \")\"):\n            k += 1\n        args = src[j + 1:k]\n    #Get the message\n    if not cmd:\n        msg = src[i + 1:i + 1 + msg_len]\n    return cmd, args, msg, msg_len",
        "prompt": "Parses the received text to extract its content.",
        "task_id": "12405",
        "test_list": [
            "assert parse_received('', '<5(MESSAGE)>') == ('', None, 'MESSAGE', 5)",
            "assert parse_received('CMD', '<0(MESSAGE)>') == ('CMD', None, '', 0)",
            "assert parse_received('CMD', '<5(CMD,ARG1,ARG2)>') == ('CMD', 'ARG1,ARG2', 'ARG1,ARG2', 5)",
            "assert parse_received('CMD', '<5(CMD,ARG1,ARG2)>') == 'LEN ERROR'",
            "assert parse_received('CMD', '<5(CMD,ARG1,ARG2') == 'CONVERT ERROR'"
        ]
    },
    {
        "func_name": "getNewCoordsAlongDirection",
        "code": "def getNewCoordsAlongDirection(direction, angleInclination, position, n):\r\n    x1, y1 = position\r\n    x2, y2 = None, None\r\n    if direction == 'L':\r\n        # Sign X (correct) Y (may change)\r\n        if 0 <= angleInclination <= 90:\r\n            x2 = int(math.floor(x1 - n * math.cos(math.radians(angleInclination))))\r\n            y2 = int(math.floor(y1 - n * math.sin(math.radians(angleInclination))))\r\n        elif  270 <= angleInclination < 360:\r\n            x2 = int(math.floor(x1 - n * math.cos(math.radians(angleInclination))))\r\n            y2 = int(math.floor(y1 + n * math.sin(math.radians(angleInclination))))\r\n    elif direction == 'R':\r\n        # Sign X (correct) Y (may change)\r\n        if 90 <= angleInclination <= 180:\r\n            x2 = int(math.floor(x1 - n * math.cos(math.radians(angleInclination))))\r\n            y2 = int(math.floor(y1 + n * math.sin(math.radians(angleInclination))))\r\n        elif  180 < angleInclination <= 270:\r\n            x2 = int(math.floor(x1 - n * math.cos(math.radians(angleInclination))))\r\n            y2 = int(math.floor(y1 + n * math.sin(math.radians(angleInclination))))\r\n    elif direction == 'T':\r\n        # Sign Y (correct) X (may change)\r\n        if  180 < angleInclination <= 270:\r\n            x2 = int(math.floor(x1 - n * math.cos(math.radians(angleInclination))))\r\n            y2 = int(math.floor(y1 + n * math.sin(math.radians(angleInclination))))\r\n        elif  270 < angleInclination <= 360:\r\n            x2 = int(math.floor(x1 + n * math.cos(math.radians(angleInclination))))\r\n            y2 = int(math.floor(y1 + n * math.sin(math.radians(angleInclination))))\r\n    elif direction == 'B':\r\n        # Sign Y (correct) X (may change)\r\n        if  0 < angleInclination <= 90:\r\n            x2 = int(math.floor(x1 - n * math.cos(math.radians(angleInclination))))\r\n            y2 = int(math.floor(y1 + n * math.sin(math.radians(angleInclination))))\r\n        elif  90 < angleInclination <= 180:\r\n            x2 = int(math.floor(x1 + n * math.cos(math.radians(angleInclination))))\r\n            y2 = int(math.floor(y1 + n * math.sin(math.radians(angleInclination))))\r\n    return x2, y2",
        "prompt": "Y coordinates starts from top left",
        "task_id": "12419",
        "test_list": [
            "assert getNewCoordsAlongDirection('T', 90, (0, 0), 1) == (0, 1)",
            "assert getNewCoordsAlongDirection('T', 270, (0, 0), 1) == (1, -1)",
            "assert getNewCoordsAlongDirection('L', 180, (0, 0), 1) == (-1, 0)",
            "assert getNewCoordsAlongDirection('B', 0, (0, 0), 1) == (1, 0)",
            "assert getNewCoordsAlongDirection('R', 90, (0, 0), 1) == (-1, 1)"
        ]
    },
    {
        "func_name": "find_integers",
        "code": "\ndef find_integers(m1, m2, m3, g23, g12, g31, g123):\n    # Compute p (it's a modulo equation)\n    if g23 == 1:\n        p = 0\n    else:\n        p = None\n        for i in range(0, g23):\n            if (m2 + i * m3) % g23 == 0:\n                p = i\n                break\n        if p is None:\n            p = 0\n    # Compute q\n    g12_r = g12 // g123\n    g23_r = g23 // g123\n    g31_r = g31 // g123\n    if g12_r == 1:\n        q = 0\n    else:\n        q = None\n        for i in range(0, g12_r):\n            if (g23_r * m1 + i * g31_r * m2) % g12_r == 0:\n                q = i\n                break\n        if q is None:\n            q = 0\n    # Compute r\n    gg_r = g31 * g23 // g123\n    z = (g23 * m1 + g31 * q * m2) // g12\n    if gg_r == 1:\n        r = 0\n    else:\n        r = None\n        for i in range(0, gg_r):\n            if (z + i * m3) % gg_r == 0:\n                r = i\n                break\n        if r is None:\n            r = 0\n    return p, q, r\n",
        "prompt": "Compute integers for offdiagonal supercell matrix elements Called by find_nondiagonal()",
        "task_id": "12542",
        "test_list": [
            "assert find_integers(0, 0, 0, 1, 0, 0, 1) == (0, 0, 0)",
            "assert find_integers(1, 1, 1, 2, 2, 2, 2) == (0, 0, 0)",
            "assert find_integers(2, 3, 5, 7, 11, 13, 17) == (0, 0, 0)",
            "assert find_integers(3, 4, 5, 6, 7, 8, 9) == (0, 0, 0)",
            "assert find_integers(1, 2, 3, 4, 5, 6, 7) == (0, 0, 0)"
        ]
    },
    {
        "func_name": "date_dif_precomputed",
        "code": "def date_dif_precomputed(years_1, month_1, day_1, years_2, month_2, day_2):\r\n    month_day = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\r\n    month_list = (\r\n        (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365),\r\n        (0, 0, 28, 59, 89, 120, 150, 181, 212, 242, 273, 303, 334),\r\n        (0, 0, 0, 31, 61, 92, 122, 153, 184, 214, 245, 275, 306),\r\n        (0, 0, 0, 0, 30, 61, 91, 122, 153, 183, 214, 244, 275),\r\n        (0, 0, 0, 0, 0, 31, 61, 92, 123, 153, 184, 214, 245),\r\n        (0, 0, 0, 0, 0, 0, 30, 61, 92, 122, 153, 183, 214),\r\n        (0, 0, 0, 0, 0, 0, 0, 31, 62, 92, 123, 153, 184),\r\n        (0, 0, 0, 0, 0, 0, 0, 0, 31, 61, 92, 122, 153),\r\n        (0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 61, 91, 122),\r\n        (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 61, 92),\r\n        (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 61),\r\n        (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31),\r\n        (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),\r\n        )\r\n    leap_1 = years_1 % 4 == 0\r\n    leap_2 = years_2 % 4 == 0\r\n    if years_1 == years_2:\r\n        if month_1 == month_2:\r\n            return day_1 - day_2\r\n        else:\r\n            days_num = day_1 + (month_day[month_2 - 1] - day_2)\r\n            days_num += month_list[month_2][month_1-2]\r\n            if leap_1 and month_2 <= 2 and month_1 > 2:\r\n                days_num += 1\r\n            return days_num\r\n    else:\r\n        leap_num = (years_1 - 1)//4 - (years_2 - 1)//4\r\n        if leap_2:\r\n            leap_num -= 1\r\n        full_year_diff = (years_1 - years_2 - 1)*365 + leap_num\r\n        days_in_year_2 = month_day[month_2-1] - day_2\r\n        if leap_2 and month_2 <= 2:\r\n            days_in_year_2 += 1\r\n        days_in_year_2 += month_list[month_2][12]\r\n        days_in_year_1 = day_1\r\n        if leap_1 and month_1 > 2:\r\n            days_in_year_1 += 1\r\n        days_in_year_1 += month_list[0][month_1-1]\r\n        return full_year_diff + days_in_year_1 + days_in_year_2",
        "prompt": "Enhanced version of date_dif_loops function that uses precomputed array which contains ammount of dates between two months.",
        "task_id": "12725",
        "test_list": [
            "assert date_dif_precomputed(2020, 1, 1, 2021, 1, 1) == 366",
            "assert date_dif_precomputed(2021, 2, 28, 2021, 3, 1) == 1",
            "assert date_dif_precomputed(2020, 12, 31, 2021, 1, 1) == 1",
            "assert date_dif_precomputed(2021, 1, 1, 2021, 1, 1) == 0",
            "assert date_dif_precomputed(2021, 3, 1, 2021, 3, 1) == 0"
        ]
    },
    {
        "func_name": "drains_to",
        "code": "def drains_to(grid, row, col):\n    if row == 0:\n        north = None\n    else:\n        north = grid[row-1][col]\n    if row == len(grid)-1:\n        south = None\n    else:\n        south = grid[row+1][col]\n    if col == 0:\n        west = None\n    else:\n        west = grid[row][col-1]\n    if col == len(grid[0])-1:\n        east = None\n    else:\n        east = grid[row][col+1]\n\n    if north is None and south is None and east is None and west is None:\n        return (None, None) # Hack in the 4-minute submission time\n    to_depth = min([val for val in [north, west, east, south] if val is not None])\n    if to_depth >= grid[row][col]:\n        return (None, None)\n    if north == to_depth:\n        return (row-1, col)\n    elif west == to_depth:\n        return (row, col-1)\n    elif east == to_depth:\n        return (row, col+1)\n    elif south == to_depth:\n        return (row+1, col)\n    else:\n        raise \"Error in draining cell %s,%s\" % (row, col)",
        "prompt": "Returns coordinates ot the cell cupplied row,col drains into immediately Returns (None, None) if supplied row, col is a sink",
        "task_id": "12761",
        "test_list": [
            "assert drains_to([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2, 2) == (None, None)",
            "assert drains_to([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1, 1) == (0, 1)",
            "assert drains_to([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 0, 0) == (None, None)",
            "assert drains_to([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 0, 2) == (None, None)",
            "assert drains_to([[9, 8, 7], [6, 5, 4], [3, 2, 1]], 1, 1) == (0, 1)"
        ]
    },
    {
        "func_name": "movement_of_standard_element",
        "code": "\ndef movement_of_standard_element(empty_row_index, empty_col_index, value_row_index, value_col_index):\n    sequence = \"\"\n    BOARD_SIZE = 8\n    AROUND_ABOVE_MOVE_LEFT = \"l\"\n    AROUND_ABOVE_MOVE_RIGHT = \"r\"\n    GO_AROUND_MOVE_LEFT = \"l\"\n    GO_AROUND_MOVE_RIGHT = \"r\"\n    UP_LEFT_DOWN = \"u\"\n    LEFT_TO_RIGHT_OVER = \"o\"\n    LEFT_TO_RIGHT_UNDER = \"u\"\n    UP_RIGHT_DOWN = \"d\"\n    GO_AROUND_MOVE_UP = \"u\"\n    \n    col_difference = abs(value_col_index - empty_col_index)\n    row_difference = value_row_index - empty_row_index\n    \n    if value_row_index == empty_row_index + 1:  # one row below\n        sequence += \"s\"\n        if value_col_index > empty_col_index:  # Further right from the target\n            go_around_move_left = AROUND_ABOVE_MOVE_LEFT if value_row_index == BOARD_SIZE - 1 else GO_AROUND_MOVE_LEFT\n            sequence += (\"d\" * col_difference) + (go_around_move_left * (col_difference - 1)) + UP_LEFT_DOWN\n        elif value_col_index < empty_col_index:  # Further left from the target\n            go_around_move_right = AROUND_ABOVE_MOVE_RIGHT if value_row_index == BOARD_SIZE - 1 else GO_AROUND_MOVE_RIGHT\n            left_to_right = LEFT_TO_RIGHT_OVER if value_row_index == BOARD_SIZE - 1 else LEFT_TO_RIGHT_UNDER\n            sequence += (\"a\" * col_difference) + (\n                    go_around_move_right * (col_difference - 1)) + left_to_right + UP_LEFT_DOWN\n    elif value_row_index > empty_row_index + 1:  # More than one row below\n        sequence += (\"s\" * row_difference)\n        if value_col_index == empty_col_index:  # Same column\n            sequence += (GO_AROUND_MOVE_UP * (row_difference - 1))\n        elif value_col_index > empty_col_index:  # Further right from the target\n            go_around_move_left = AROUND_ABOVE_MOVE_LEFT if value_row_index == BOARD_SIZE - 1 else GO_AROUND_MOVE_LEFT\n            # If number in bottom row, circumvent above, else circumvent below\n            sequence += (\"d\" * col_difference) + (go_around_move_left * (col_difference - 1)) + (UP_LEFT_DOWN) + (\n                    GO_AROUND_MOVE_UP * (row_difference - 1))\n        else:  # Further left from the target\n            go_around_move_right = AROUND_ABOVE_MOVE_RIGHT if value_row_index == BOARD_SIZE - 1 else GO_AROUND_MOVE_RIGHT\n            # If number in bottom row, circumvent above, else circumvent below\n            sequence += (\"a\" * col_difference) + (\n                    go_around_move_right * (col_difference - 1)) + UP_RIGHT_DOWN + (\n                                GO_AROUND_MOVE_UP * (row_difference - 1))\n    else:  # On the same row\n        direction = \"d\" if value_col_index > empty_col_index else \"a\"\n        sequence += direction * col_difference\n        col_difference -= 1\n        move_value_direction = GO_AROUND_MOVE_LEFT if value_col_index > empty_col_index else GO_AROUND_MOVE_RIGHT\n        sequence += move_value_direction * col_difference\n    return sequence\n",
        "prompt": "Take empty square located at target, move it to value, then transport value to target",
        "task_id": "12803",
        "test_list": [
            "assert movement_of_standard_element(0, 0, 1, 2) == 'dadao'",
            "assert movement_of_standard_element(0, 0, 1, 7) == 'dadao'",
            "assert movement_of_standard_element(0, 0, 0, 1) == 'd'",
            "assert movement_of_standard_element(0, 0, 2, 0) == 'aa'",
            "assert movement_of_standard_element(0, 0, 7, 0) == 'aadao'"
        ]
    },
    {
        "func_name": "replace_repeated",
        "code": "\ndef replace_repeated(child, aux, cut, subsize):\n    SIZE = len(child)\n    child = list(child)\n    for i in range(SIZE):\n        if i >= cut and i < cut + subsize:\n            continue\n        count = 0\n        char = child[i]\n        for j in range(SIZE):\n            if child[j] == char:\n                count += 1\n        if count > 1:\n            new_char = \"\\0\"\n            find = False\n            for j in range(subsize):\n                new_char = aux[j]\n                find = False\n                for k in range(SIZE):\n                    if child[k] == new_char:\n                        find = True\n                        break\n                if not find:\n                    break\n            child[i] = new_char\n\n    return \"\".join(child)\n",
        "prompt": "Substitui os caracteres repetidos pelo corte pmx",
        "task_id": "12821",
        "test_list": [
            "assert replace_repeated('aabbccddeeff', '123', 2, 2) == 'a123b123cdeff'",
            "assert replace_repeated('aabbccddeeff', '123', 4, 2) == 'a123b123cdeff'",
            "assert replace_repeated('aaabbbcc', 'xyz', 2, 2) == 'xyabxyzcc'",
            "assert replace_repeated('aabbcc', '123', 2, 2) == 'a123b123c'",
            "assert replace_repeated('abcabc', '123', 3, 1) == 'a123b123c'"
        ]
    },
    {
        "func_name": "match_diagonal_right_left",
        "code": "def match_diagonal_right_left(word, row, column, grid):\n    word_index = 0 # Indexes the current word\n    match_success = True\n    # Begin top-right to bottom-left match:\n    while word_index < len(word) and match_success == True:\n        character_to_match = word[word_index]\n        # If the character being pointed to in the grid matches the character being pointed to in the word to match:\n        if column >= 0 and row < len(grid) and character_to_match == grid[row][column]:\n            word_index += 1\n            column -= 1\n            row += 1\n        else:\n            match_success = False\n\n    # Begin bottom-left to top-right match:\n    if match_success == False:\n        column += word_index # Decrement column to equal initial value when match_diagonal was called\n        row -= word_index # Decrement row to equal initial value when match_diagonal was called\n        word_index = 0\n        match_success = True\n        while word_index < len(word) and match_success == True:\n            character_to_match = word[word_index]\n            # If the character being pointed to in the grid matches the character being pointed to in the word to match:\n            if column < len(grid[0]) and row >= 0 and character_to_match == grid[row][column]:\n                word_index += 1\n                column += 1\n                row -= 1\n            else:\n                match_success = False\n\n    return match_success",
        "prompt": "Diagonally match a word's characters with those in the word search. Diagonally match a word's characters with those in the word search going from topright to bottomleft or bottomleft to topright.",
        "task_id": "12824",
        "test_list": [
            "assert match_diagonal_right_left('abc', 0, 0, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p']) == False",
            "assert match_diagonal_right_left('abc', 0, 2, ['d', 'e', 'a', 'b', 'c', 'f', 'g', 'h', 'i', 'j']) == True",
            "assert match_diagonal_right_left('abc', 0, 0, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l']) == False",
            "assert match_diagonal_right_left('abc', 0, 0, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's']) == False",
            "assert match_diagonal_right_left('abc', 0, 0, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']) == True"
        ]
    },
    {
        "func_name": "search_largest_product",
        "code": "def search_largest_product(grid, seq_length):\n    largest_product = 0\n\n    for x in range(len(grid)):\n        for y in range(len(grid[0])):\n            #right\n            if( y < (len(grid[0])-seq_length)):\n                product = 1\n                for i in range(seq_length):\n                    product = product * grid[x][y+i]\n                \n                largest_product = max(largest_product, product)\n            \n            #down\n            if( x < (len(grid)-seq_length)):\n                product = 1\n                for i in range(seq_length):\n                    product = product * grid[x+i][y]\n                \n                largest_product = max(largest_product, product)\n\n            #diag right\n            if(( y < (len(grid[0])-seq_length)) and ( x < (len(grid)-seq_length))):\n                product = 1\n                for i in range(seq_length):\n                    product = product * grid[x+i][y+i]\n                \n                largest_product = max(largest_product, product)\n\n            #diag left\n            if(( y > seq_length-1) and ( x < (len(grid)-seq_length))):\n                product = 1\n                for i in range(seq_length):\n                    product = product * grid[x+i][y-i]\n                \n                largest_product = max(largest_product, product)\n\n    return largest_product",
        "prompt": "searches and returns the largest product of 'seq_length' adjacent numbers in 'grid'.",
        "task_id": "13054",
        "test_list": [
            "assert search_largest_product([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20]], 4) == 14600",
            "assert search_largest_product([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == 504",
            "assert search_largest_product([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 2) == 240",
            "assert search_largest_product([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], 2) == 0",
            "assert search_largest_product([[8, 2, 22, 97], [49, 49, 99, 40], [81, 49, 31, 73], [52, 70, 95, 23]], 2) == 9800"
        ]
    },
    {
        "func_name": "rare_second_digits",
        "code": "def rare_second_digits(first, last):\n\n    if first == 2 or (first == 8 and last == 8):\n        for n in range(10):\n            yield (n, n)\n    elif first == 4:\n        for a in range(0, 10):\n            for b in range((0 if a % 2 == 0 else 1), 10, 2):\n                yield (a, b)\n    elif first == 6:\n        for a in range(0, 10):\n            for b in range((1 if a % 2 == 0 else 0), 10, 2):\n                yield (a, b)\n    elif first == 8:\n        if last == 2 or last == 8:\n            for a in range(0, 10):\n                yield (a, 9-a)\n        elif last == 3:\n            for a in range (0, 10):\n                if a > 6:\n                    yield (a, a-7)\n                else:\n                    yield (a, a+3)\n        elif last == 7:\n            for a in range(0, 10):\n                if a > 1:\n                    yield (a, 11-a)\n                else:\n                    yield (a, 1-a)",
        "prompt": "Given the first and last digits, return tuples of all possible second, secondfromlast digits in a rare number",
        "task_id": "13099",
        "test_list": [
            "assert list(rare_second_digits(4, 0)) == [(0, 0), (0, 2), (0, 4), (0, 6), (0, 8), (2, 0), (2, 2), (2, 4), (2, 6), (2, 8), (4, 0), (4, 2), (4, 4), (4, 6), (4, 8), (6, 0), (6, 2), (6, 4), (6, 6), (6, 8), (8, 0), (8, 2), (8, 4), (8, 6), (8, 8)]",
            "assert list(rare_second_digits(2, 8)) == [(0, 8), (1, 7), (2, 6), (3, 5), (4, 4), (5, 3), (6, 2), (7, 1), (8, 0), (9, 9)]",
            "assert list(rare_second_digits(6, 3)) == [(0, 3), (1, 2), (2, 1), (3, 0), (4, 7), (5, 6), (6, 5), (7, 4), (8, 3), (9, 2)]",
            "assert list(rare_second_digits(8, 2)) == [(0, 2), (1, 1), (2, 0), (3, 7), (4, 6), (5, 5), (6, 4), (7, 3), (8, 2), (9, 1)]",
            "assert list(rare_second_digits(8, 7)) == [(0, 7), (1, 6), (2, 5), (3, 4), (4, 3), (5, 2), (6, 1), (7, 0), (8, 7), (9, 6)]"
        ]
    },
    {
        "func_name": "matchCorrectProjectName",
        "code": "def matchCorrectProjectName(projectName):\n\n    result = re.match(\"Dumas\", projectName) \n    if result or re.match(\"Artiste Fran\u00e7ois Dumas\", projectName):\n        return \"Artiste Dumas\"\n    result = re.match(\"Dumas\", projectName) \n    if result or re.match(\"Artiste Fran\u00e7ois Dumas\", projectName):\n        return \"Artiste Dumas\"\n    result = re.match(\"Sign\u00e9s Toqu\u00e9\", projectName)\n    if result or re.match(\"Sign\u00e9 Toqu\u00e9\", projectName) or re.match(\"Sign\u00e9 Tocqu\u00e9\", projectName):\n        return \"Sign\u00e9s Toqu\u00e9s\"\n    result = re.match(\"Esprit\", projectName)\n    if result:\n        return \"Esprit de Voyage\"\n    result = re.match(\"Mama\", projectName)\n    if result or re.match(\"Mam\", projectName) or re.match(\"MAM\", projectName):\n        return \"Mama Shelter\"\n    if re.match(\"Micro-stage\", projectName) or re.match(\"Micro Stage Solidaire\", projectName) :\n        return \"Micro Stage\"\n    result = re.match(\"D\u00e9couverte Langues\", projectName)\n    if result or re.match(\"D\u00e9couverte Des Langues\", projectName):\n        return \"A La D\u00e9couverte Des Langues\"\n    if re.match(\"Comp\u00e9tence\", projectName) or re.match(\"Ref Comp\u00e9tences\", projectName) or re.match(\"Ref Comp\u00e9tence\", projectName):\n        return \"R\u00e9f\u00e9rentiel Comp\u00e9tence\"\n    result = re.match(\"Arcs\", projectName)\n    if result:\n        return \"Les Arcs\"\n    result = re.match(\"Labrande\", projectName)\n    if result or re.match(\"Chateau La Brande\", projectName):\n        return \"Ch\u00e2teau Labrande\"\n    result = re.match(\"Sign\u00e9s Toqu\u00e9s\", projectName)\n    if result:\n        return \"Sign\u00e9 Toqu\u00e9\"\n    result = re.match(\"Oui Chef\", projectName)\n    if result:\n        return \"Oui Chef!\"\n    result = re.match(\"Mus\u00e9e\", projectName)\n    if result:\n        return \"Mus\u00e9e des Arts et M\u00e9tiers\"\n    result = re.match(\"Grandes Tables Du Monde\", projectName)\n    if result:\n        return \"Les Grandes Tables Du Monde\"\n    if  re.match(\"Abbaye Pouilhes\", projectName) or re.match(\"Prouilhe\", projectName):\n        return \"Abbaye Prouilhe\"\n    if  re.match(\"Villages Pro Btp\", projectName):\n        return \"Village Pro Btp\"\n    return projectName",
        "prompt": "Match a Partners name to a stardarized name",
        "task_id": "13103",
        "test_list": [
            "assert matchCorrectProjectName('Mus\u00e9e des Arts et M\u00e9tiers') == 'Mus\u00e9e des Arts et M\u00e9tiers'",
            "assert matchCorrectProjectName('Comp\u00e9tence') == 'R\u00e9f\u00e9rentiel Comp\u00e9tence'",
            "assert matchCorrectProjectName('Ref Comp\u00e9tences') == 'R\u00e9f\u00e9rentiel Comp\u00e9tence'",
            "assert matchCorrectProjectName('Les Arcs') == 'Les Arcs'",
            "assert matchCorrectProjectName('Dumas') == 'Artiste Dumas'"
        ]
    },
    {
        "func_name": "_cigar_to_index",
        "code": "\nclass Read:\n    def __init__(self, cigar, is_reverse):\n        self.cigar = cigar\n        self.is_reverse = is_reverse\n\ndef _cigar_to_index(read):\n    MATCH = 0\n    INS = 1\n    DEL = 2\n    REF_SKIP = 3\n    SOFT_CLIP = 4\n    HARD_CLIP = 5\n    PAD = 6\n    EQUAL = 7\n    DIFF = 8\n\n    length, begin, end = 0, 0, 0\n    hasbegun = False\n    \n    for (state, size) in read.cigar:\n        \n        if state in (SOFT_CLIP, HARD_CLIP): # clipped end\n            length += size\n            if not hasbegun:\n                begin += size\n                end += size\n\n        elif state == MATCH: # match\n            hasbegun = True\n            length += size\n            end += size\n\n        elif state in [INS, REF_SKIP]:\n            length += size\n            end += size\n\n        elif state == DEL:\n            pass\n\n        elif state == REF_SKIP:\n            length += size\n            end += size\n\n        elif state in [PAD, EQUAL, DIFF]:\n            raise NotImplementedError('Didn\\'t expect this state {}'.format(state))\n\n        else:\n            raise ValueError('Unrecognised state {} in {}'.format(state, read.cigar))\n\n    if read.is_reverse:\n        begin, end = length - end, length - begin\n\n    return begin, end\n\n_cigar_to_index(Read(cigar=[(0, 10), (2, 5), (4, 3)], is_reverse=False))  # Test with different cigar states and not reversed\n_cigar_to_index(Read(cigar=[(0, 5), (4, 7)], is_reverse=True))  # Test with soft clip and reversed\n_cigar_to_index(Read(cigar=[(0, 15), (1, 3), (3, 2), (0, 5)], is_reverse=False))  # Test with insert, ref skip, and match\n_cigar_to_index(Read(cigar=[(0, 20)], is_reverse=True))  # Test with only match and reversed\n_cigar_to_index(Read(cigar=[(0, 10), (2, 5), (4, 3)], is_reverse=True))  # Test with different cigar states and reversed\n",
        "prompt": "Use the Cigar tuple to get indices of genomealigned region w.r.t. contig Indices are SLICES, i.e. zerobased index of the first matching position and the first pasttheend position. Alignment length is rpos lpos",
        "task_id": "13149",
        "test_list": [
            "assert _cigar_to_index(Read(cigar=[(0, 10), (2, 5), (4, 3)], is_reverse=True)) == (12, 5)",
            "assert _cigar_to_index(Read(cigar=[(0, 20)], is_reverse=True)) == (0, 20)",
            "assert _cigar_to_index(Read(cigar=[(0, 5), (4, 7)], is_reverse=True)) == (12, 9)",
            "assert _cigar_to_index(Read(cigar=[(0, 10), (2, 5), (4, 3)], is_reverse=False)) == (0, 18)",
            "assert _cigar_to_index(Read(cigar=[(0, 15), (1, 3), (3, 2), (0, 5)], is_reverse=False)) == (0, 20)"
        ]
    },
    {
        "func_name": "calculate_data_packet_size",
        "code": "\nCHANNEL_DATA_TYPE = {\n    \"u12\": \"u12\",\n    \"i16\": \"i16\",\n    \"i16*\": \"i16*\",\n    \"u16\": \"u16\",\n    \"u24\": \"u24\",\n    \"u8\": \"u8\",\n    \"i24\": \"i24\",\n    \"u24*\": \"u24*\",\n    \"i24*\": \"i24*\"\n}\n\ndef calculate_data_packet_size(channels):\n    total_size = 0\n    total_size += 1  # packet id\n    total_size += 3  # timestamp\n    for channel in channels:\n        data_type = CHANNEL_DATA_TYPE[channel]\n        if data_type == \"u12\":\n            total_size += 2  # 12 bit --> servono almeno 2byte --> 16bit\n        elif data_type == \"i16\":\n            total_size += 2\n        elif data_type == \"i16*\":\n            total_size += 2\n        elif data_type == \"u16\":\n            total_size += 2\n        elif data_type == \"u24\":\n            total_size += 3\n        elif data_type == \"u8\":\n            total_size += 1\n        elif data_type == \"i24\":\n            total_size += 3\n        elif data_type == \"u24*\":\n            total_size += 3\n        elif data_type == \"i24*\":\n            total_size += 3\n    return total_size\n",
        "prompt": "Only for packet that contains streamed data.",
        "task_id": "13184",
        "test_list": [
            "assert calculate_data_packet_size(['u12', 'u24', 'u8']) == 11",
            "assert calculate_data_packet_size(['u16', 'u24', 'u24*']) == 10",
            "assert calculate_data_packet_size(['i16', 'i24*', 'u24']) == 11",
            "assert calculate_data_packet_size(['u8', 'u24*', 'i24*']) == 10",
            "assert calculate_data_packet_size(['i16', 'i16', 'u24']) == 10"
        ]
    },
    {
        "func_name": "get_rgb_filters",
        "code": "def get_rgb_filters(filter_list, force_ir=False, pure_sort=False):\n    bfilt = None\n    if pure_sort:\n        bfilts = ['f200lp', 'f435w','f475w','f555w','f600w','f606w', 'f775w', 'f814w','f098m','f105w','f110w','f125w','f140w','f160w']\n        gfilts = bfilts\n        rfilts = bfilts[::-1]\n    else:\n        bfilts = ['f814w', 'f606w', 'f775w','f435w','f475w','f555w','f200lp','f098m','f105w','f110w','f125w']\n        gfilts = ['f105w','f110w','f125w','f140w','f606w','f814w']\n        rfilts = ['f160w','f140w','f110w','f125w','f105w','f814w','f606w']\n        \n    for filt in bfilts:\n        if filt in filter_list:\n            bfilt = filt\n            break\n    \n    gfilt = 'sum'\n    for filt in gfilts:\n        if (filt in filter_list) & (filt != bfilt):\n            gfilt = filt\n            break\n    \n    if (bfilt is None) | (force_ir):\n        bfilt = gfilt\n        gfilt = 'sum'\n        \n    rfilt = None\n    for filt in rfilts:\n        if filt in filter_list:\n            rfilt = filt\n            break\n    \n    \n    if rfilt == gfilt:\n        gfilt = 'sum'\n        \n    if rfilt+gfilt+bfilt == 'f110wf110wf200lp':\n        gfilt = 'sum'\n            \n    return rfilt, gfilt, bfilt",
        "prompt": "Compute which filters to use to make an RGB cutout",
        "task_id": "13344",
        "test_list": [
            "assert get_rgb_filters(['f606w', 'f125w', 'f098m', 'f200lp'], force_ir=True, pure_sort=False) == ('f098m', 'f606w', 'f125w')",
            "assert get_rgb_filters(['f200lp', 'f105w', 'f125w', 'f606w'], force_ir=False, pure_sort=False) == ('f200lp', 'f606w', 'f125w')",
            "assert get_rgb_filters(['f606w', 'f125w', 'f098m', 'f200lp'], force_ir=False, pure_sort=True) == ('f200lp', 'f125w', 'f125w')",
            "assert get_rgb_filters(['f475w', 'f606w', 'f125w', 'f098m'], force_ir=True, pure_sort=False) == ('f098m', 'f606w', 'f125w')",
            "assert get_rgb_filters(['f606w', 'f125w', 'f098m', 'f200lp'], force_ir=False, pure_sort=False) == ('f606w', 'f125w', 'f125w')"
        ]
    },
    {
        "func_name": "_dicom_orientation_string",
        "code": "\nimport math\n\ndef _dicom_orientation_string(normal):\n    TOLERANCE = 1.e-4\n    orientations = ('Sag', 'Cor', 'Tra')\n    constants = {'RADIANS_TO_DEGREES': 180 / math.pi}\n\n    final_angle = \"\"\n    final_orientation = \"\"\n\n    sorted_normal = sorted(normal)\n\n    for i, value in enumerate(normal):\n        if value == sorted_normal[2]:\n            principal = i\n        if value == sorted_normal[1]:\n            secondary = i\n        if value == sorted_normal[0]:\n            ternary = i\n\n    angle_1 = math.atan2(normal[secondary], normal[principal]) * constants['RADIANS_TO_DEGREES']\n\n    new_normal_ip = math.sqrt((normal[principal] ** 2) + (normal[secondary] ** 2))\n    angle_2 = math.atan2(normal[ternary], new_normal_ip) * constants['RADIANS_TO_DEGREES']\n\n    if not principal:\n        if abs(angle_1) > 0:\n            sign1 = angle_1 / abs(angle_1)\n        else:\n            sign1 = 1.0\n\n        angle_1 -= (sign1 * 180.0)\n        angle_2 *= -1\n\n    if (abs(angle_2) < TOLERANCE) or (abs(abs(angle_2) - 180) < TOLERANCE):\n        if (abs(angle_1) < TOLERANCE) or (abs(abs(angle_1) - 180) < TOLERANCE):\n            final_angle = orientations[principal]\n            final_orientation = final_angle\n        else:\n            final_angle = \"%s>%s %.3f\" % (orientations[principal], orientations[secondary], (-1 * angle_1))\n            final_orientation = orientations[principal] + '-' + orientations[secondary]\n    else:\n        final_angle = \"%s>%s %.3f >%s %f\" % (orientations[principal], orientations[secondary], (-1 * angle_1), orientations[ternary], (-1 * angle_2))\n        final_orientation = \"%s-%s-%s\" % (orientations[principal], orientations[secondary], orientations[ternary])\n\n    return final_angle, final_orientation\n",
        "prompt": "Given a 3item list (or other iterable) that represents a normal vector to the \"imaging\" plane, this function determines the orientation of the vector in 3dimensional space. It returns a tuple of (angle, orientation) in which angle is e.g. \"Tra\" or \"Tra>Cor 6\" or \"Tra>Sag 14.1 >Cor 9.3\" and orientation is e.g. \"Sag\" or \"CorTra\". For double angulation, errors in secondary angle occur that may be due to rounding errors in internal Siemens software, which calculates row and column vectors.",
        "task_id": "13498",
        "test_list": [
            "assert _dicom_orientation_string([1, 0, 0]) == ('Sag', 'Sag')",
            "assert _dicom_orientation_string([1, 1, 0]) == ('Tra', 'Tra')",
            "assert _dicom_orientation_string([0, 0, 1]) == ('Cor', 'Cor')",
            "assert _dicom_orientation_string([0, 1, 0]) == ('Tra', 'Tra')",
            "assert _dicom_orientation_string([1, 0, 1]) == ('Cor', 'Cor')"
        ]
    },
    {
        "func_name": "countPenaltyForCurriculumCompactness",
        "code": "def countPenaltyForCurriculumCompactness(periodsList, periodsPerDay):\n    penalty = 0\n    for i in range(0, len(periodsList)):\n        if i > 0 and periodsList[i - 1] + 1 == periodsList[i] and (periodsList[i - 1] / periodsPerDay == periodsList[i] / periodsPerDay):\n            beforeLecture = True\n        else:\n            beforeLecture = False\n        if i < len(periodsList) - 1 and (periodsList[i + 1] - 1 == periodsList[i]) and (periodsList[i + 1] / periodsPerDay == periodsList[i] / periodsPerDay):\n            afterLecture = True\n        else:\n            afterLecture = False\n        if beforeLecture is False and afterLecture is False:\n            penalty += 1\n    return penalty",
        "prompt": "Count curriculum compactness penalty for one curriculum",
        "task_id": "13514",
        "test_list": [
            "assert countPenaltyForCurriculumCompactness([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 1) == 0",
            "assert countPenaltyForCurriculumCompactness([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0",
            "assert countPenaltyForCurriculumCompactness([1, 2, 3, 4, 5, 6], 1) == 0",
            "assert countPenaltyForCurriculumCompactness([1, 2, 3, 4, 5], 1) == 0",
            "assert countPenaltyForCurriculumCompactness([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 1) == 0"
        ]
    }
]